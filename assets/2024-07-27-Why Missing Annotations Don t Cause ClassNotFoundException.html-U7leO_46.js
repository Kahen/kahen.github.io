import{_ as a}from"./plugin-vue_export-helper-DlAUqK2U.js";import{c as n,o as s,a as t}from"./app-h26Zxjak.js";const e={},p=t(`<hr><h1 id="为什么缺少注解不会导致classnotfoundexception" tabindex="-1"><a class="header-anchor" href="#为什么缺少注解不会导致classnotfoundexception"><span>为什么缺少注解不会导致ClassNotFoundException</span></a></h1><p>在本教程中，我们将熟悉Java编程语言中一个看似奇怪的特性：缺少注解不会导致运行时异常。</p><p>然后，我们将深入探讨这种行为背后的规则和原因，以及这些规则的例外情况。</p><h2 id="_2-快速回顾" tabindex="-1"><a class="header-anchor" href="#_2-快速回顾"><span>2. 快速回顾</span></a></h2><p>让我们从一个熟悉的Java示例开始。有一个类_A_，然后是依赖于_A_的类_B_：</p><div class="language-java line-numbers-mode" data-ext="java" data-title="java"><pre class="language-java"><code><span class="token keyword">public</span> <span class="token keyword">class</span> <span class="token class-name">A</span> <span class="token punctuation">{</span>
<span class="token punctuation">}</span>

<span class="token keyword">public</span> <span class="token keyword">class</span> <span class="token class-name">B</span> <span class="token punctuation">{</span>
    <span class="token keyword">public</span> <span class="token keyword">static</span> <span class="token keyword">void</span> <span class="token function">main</span><span class="token punctuation">(</span><span class="token class-name">String</span><span class="token punctuation">[</span><span class="token punctuation">]</span> args<span class="token punctuation">)</span> <span class="token punctuation">{</span>
        <span class="token class-name">System</span><span class="token punctuation">.</span>out<span class="token punctuation">.</span><span class="token function">println</span><span class="token punctuation">(</span><span class="token keyword">new</span> <span class="token class-name">A</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
    <span class="token punctuation">}</span>
<span class="token punctuation">}</span>
</code></pre><div class="line-numbers" aria-hidden="true"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><p>现在，如果我们编译这些类并运行编译后的_B_，它会在控制台为我们打印一条消息：</p><div class="language-bash line-numbers-mode" data-ext="sh" data-title="sh"><pre class="language-bash"><code><span class="token operator">&gt;&gt;</span> javac A.java
<span class="token operator">&gt;&gt;</span> javac B.java
<span class="token operator">&gt;&gt;</span> <span class="token function">java</span> B
A@d716361
</code></pre><div class="line-numbers" aria-hidden="true"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><p>然而，如果我们删除编译后的_A_的.class文件并重新运行类_B_，我们将看到一个由_ClassNotFoundException_引起的_NoClassDefFoundError_：</p><div class="language-bash line-numbers-mode" data-ext="sh" data-title="sh"><pre class="language-bash"><code><span class="token operator">&gt;&gt;</span> <span class="token function">rm</span> A.class
<span class="token operator">&gt;&gt;</span> <span class="token function">java</span> B
Exception <span class="token keyword">in</span> thread <span class="token string">&quot;main&quot;</span> java.lang.NoClassDefFoundError: A
        at B.main<span class="token punctuation">(</span>B.java:3<span class="token punctuation">)</span>
Caused by: java.lang.ClassNotFoundException: A
        at java.base/jdk.internal.loader.BuiltinClassLoader.loadClass<span class="token punctuation">(</span>BuiltinClassLoader.java:606<span class="token punctuation">)</span>
        at java.base/jdk.internal.loader.ClassLoaders<span class="token variable">$AppClassLoader</span>.loadClass<span class="token punctuation">(</span>ClassLoaders.java:168<span class="token punctuation">)</span>
        at java.base/java.lang.ClassLoader.loadClass<span class="token punctuation">(</span>ClassLoader.java:522<span class="token punctuation">)</span>
        <span class="token punctuation">..</span>. <span class="token number">1</span> <span class="token function">more</span>
</code></pre><div class="line-numbers" aria-hidden="true"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><p><strong>这是因为类加载器在运行时找不到类文件，即使它在编译期间存在</strong>。这是许多Java开发人员期望的正常行为。</p><p>现在，让我们看看在相同情况下注解会发生什么。为此，我们将改变_A_类，使其成为一个注解：</p><div class="language-java line-numbers-mode" data-ext="java" data-title="java"><pre class="language-java"><code><span class="token annotation punctuation">@Retention</span><span class="token punctuation">(</span><span class="token class-name">RetentionPolicy</span><span class="token punctuation">.</span><span class="token constant">RUNTIME</span><span class="token punctuation">)</span>
<span class="token keyword">public</span> <span class="token annotation punctuation">@interface</span> <span class="token class-name">A</span> <span class="token punctuation">{</span>
<span class="token punctuation">}</span>
</code></pre><div class="line-numbers" aria-hidden="true"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><p>如上所示，Java将在运行时保留注解信息。之后，是时候用_A_注解类_B_了：</p><div class="language-java line-numbers-mode" data-ext="java" data-title="java"><pre class="language-java"><code><span class="token annotation punctuation">@A</span>
<span class="token keyword">public</span> <span class="token keyword">class</span> <span class="token class-name">B</span> <span class="token punctuation">{</span>
    <span class="token keyword">public</span> <span class="token keyword">static</span> <span class="token keyword">void</span> <span class="token function">main</span><span class="token punctuation">(</span><span class="token class-name">String</span><span class="token punctuation">[</span><span class="token punctuation">]</span> args<span class="token punctuation">)</span> <span class="token punctuation">{</span>
        <span class="token class-name">System</span><span class="token punctuation">.</span>out<span class="token punctuation">.</span><span class="token function">println</span><span class="token punctuation">(</span><span class="token string">&quot;It worked!&quot;</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
    <span class="token punctuation">}</span>
<span class="token punctuation">}</span>
</code></pre><div class="line-numbers" aria-hidden="true"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><p>接下来，让我们编译并运行这些类：</p><div class="language-bash line-numbers-mode" data-ext="sh" data-title="sh"><pre class="language-bash"><code><span class="token operator">&gt;&gt;</span> javac A.java
<span class="token operator">&gt;&gt;</span> javac B.java
<span class="token operator">&gt;&gt;</span> <span class="token function">java</span> B
It worked<span class="token operator">!</span>
</code></pre><div class="line-numbers" aria-hidden="true"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><p>所以，我们看到_B_成功地在控制台上打印了它的信息，这是有道理的，因为一切都是编译和连接得很好。</p><p>现在，让我们删除_A_的类文件：</p><div class="language-bash line-numbers-mode" data-ext="sh" data-title="sh"><pre class="language-bash"><code><span class="token operator">&gt;&gt;</span> <span class="token function">rm</span> A.class
<span class="token operator">&gt;&gt;</span> <span class="token function">java</span> B
It worked<span class="token operator">!</span>
</code></pre><div class="line-numbers" aria-hidden="true"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><p>如上所示，<strong>即使注解类文件丢失，注解类仍然可以无异常地运行</strong>。</p><h3 id="_3-1-带有类标记的注解" tabindex="-1"><a class="header-anchor" href="#_3-1-带有类标记的注解"><span>3.1. 带有类标记的注解</span></a></h3><p>为了使事情更有趣，让我们引入另一个带有_Class<code>&lt;?&gt;</code>_属性的注解：</p><div class="language-java line-numbers-mode" data-ext="java" data-title="java"><pre class="language-java"><code><span class="token annotation punctuation">@Retention</span><span class="token punctuation">(</span><span class="token class-name">RetentionPolicy</span><span class="token punctuation">.</span><span class="token constant">RUNTIME</span><span class="token punctuation">)</span>
<span class="token keyword">public</span> <span class="token annotation punctuation">@interface</span> <span class="token class-name">C</span> <span class="token punctuation">{</span>
    <span class="token class-name">Class</span>\`\`\`<span class="token generics"><span class="token punctuation">&lt;</span><span class="token operator">?</span><span class="token punctuation">&gt;</span></span>\`\`\` <span class="token function">value</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
<span class="token punctuation">}</span>
</code></pre><div class="line-numbers" aria-hidden="true"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><p>如上所示，这个注解有一个名为_value_的属性，返回类型为_Class<code>&lt;?&gt;</code><em>。作为该属性的参数，让我们添加另一个空类_D</em>：</p><div class="language-java line-numbers-mode" data-ext="java" data-title="java"><pre class="language-java"><code><span class="token keyword">public</span> <span class="token keyword">class</span> <span class="token class-name">D</span> <span class="token punctuation">{</span>
<span class="token punctuation">}</span>
</code></pre><div class="line-numbers" aria-hidden="true"><div class="line-number"></div><div class="line-number"></div></div></div><p>现在，我们将用这个新注解注解_B_类：</p><div class="language-java line-numbers-mode" data-ext="java" data-title="java"><pre class="language-java"><code><span class="token annotation punctuation">@A</span>
<span class="token annotation punctuation">@C</span><span class="token punctuation">(</span><span class="token class-name">D</span><span class="token punctuation">.</span><span class="token keyword">class</span><span class="token punctuation">)</span>
<span class="token keyword">public</span> <span class="token keyword">class</span> <span class="token class-name">B</span> <span class="token punctuation">{</span>
    <span class="token keyword">public</span> <span class="token keyword">static</span> <span class="token keyword">void</span> <span class="token function">main</span><span class="token punctuation">(</span><span class="token class-name">String</span><span class="token punctuation">[</span><span class="token punctuation">]</span> args<span class="token punctuation">)</span> <span class="token punctuation">{</span>
        <span class="token class-name">System</span><span class="token punctuation">.</span>out<span class="token punctuation">.</span><span class="token function">println</span><span class="token punctuation">(</span><span class="token string">&quot;It worked!&quot;</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
    <span class="token punctuation">}</span>
<span class="token punctuation">}</span>
</code></pre><div class="line-numbers" aria-hidden="true"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><p>当所有类文件都存在时，一切应该正常工作。然而，当我们只删除_D_类文件而不动其他文件时会发生什么？让我们找出答案：</p><div class="language-bash line-numbers-mode" data-ext="sh" data-title="sh"><pre class="language-bash"><code><span class="token operator">&gt;&gt;</span> <span class="token function">rm</span> D.class
<span class="token operator">&gt;&gt;</span> <span class="token function">java</span> B
It worked<span class="token operator">!</span>
</code></pre><div class="line-numbers" aria-hidden="true"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><p>如上所示，尽管_D_在运行时不存在，一切仍然正常工作！因此，除了注解之外，<strong>属性中引用的类标记也不需要在运行时存在</strong>。</p><h3 id="_3-2-java语言规范" tabindex="-1"><a class="header-anchor" href="#_3-2-java语言规范"><span>3.2. Java语言规范</span></a></h3><p>所以，我们看到一些具有运行时保留的注解在运行时丢失，但注解类仍然可以完美运行。尽管这听起来可能出乎意料，但这种行为实际上完全符合Java语言规范，§9.6.4.2：</p><blockquote><p>注解可能只存在于源代码中，或者它们可能存在于类或接口的二进制形式中。存在于二进制形式中的注解<strong>可能或可能不在Java SE平台的反射库中在运行时可用</strong>。</p></blockquote><p>此外，JLS §13.5.7条目还指出：</p><blockquote><p>添加或删除注解对Java编程语言中程序的二进制表示的正确链接没有影响。</p></blockquote><p><strong>底线是，运行时不会因缺少注解而抛出异常，因为JLS允许它</strong>。</p><h3 id="_3-3-访问丢失的注解" tabindex="-1"><a class="header-anchor" href="#_3-3-访问丢失的注解"><span>3.3. 访问丢失的注解</span></a></h3><p>让我们以一种方式改变_B_类，使其通过反射检索_A_信息：</p><div class="language-java line-numbers-mode" data-ext="java" data-title="java"><pre class="language-java"><code><span class="token annotation punctuation">@A</span>
<span class="token keyword">public</span> <span class="token keyword">class</span> <span class="token class-name">B</span> <span class="token punctuation">{</span>
    <span class="token keyword">public</span> <span class="token keyword">static</span> <span class="token keyword">void</span> <span class="token function">main</span><span class="token punctuation">(</span><span class="token class-name">String</span><span class="token punctuation">[</span><span class="token punctuation">]</span> args<span class="token punctuation">)</span> <span class="token punctuation">{</span>
        <span class="token class-name">System</span><span class="token punctuation">.</span>out<span class="token punctuation">.</span><span class="token function">println</span><span class="token punctuation">(</span><span class="token class-name">A</span><span class="token punctuation">.</span><span class="token keyword">class</span><span class="token punctuation">.</span><span class="token function">getSimpleName</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
    <span class="token punctuation">}</span>
<span class="token punctuation">}</span>
</code></pre><div class="line-numbers" aria-hidden="true"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><p>如果我们编译并运行它们，一切都会很好：</p><div class="language-bash line-numbers-mode" data-ext="sh" data-title="sh"><pre class="language-bash"><code><span class="token operator">&gt;&gt;</span> javac A.java
<span class="token operator">&gt;&gt;</span> javac B.java
<span class="token operator">&gt;&gt;</span> <span class="token function">java</span> B
A
</code></pre><div class="line-numbers" aria-hidden="true"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><p>现在，如果我们删除_A_类文件并运行_B_，我们将看到相同的_NoClassDefFoundError_由_ClassNotFoundException_引起：</p><div class="language-bash line-numbers-mode" data-ext="sh" data-title="sh"><pre class="language-bash"><code>Exception <span class="token keyword">in</span> thread <span class="token string">&quot;main&quot;</span> java.lang.NoClassDefFoundError: A
        at B.main<span class="token punctuation">(</span>B.java:5<span class="token punctuation">)</span>
Caused by: java.lang.ClassNotFoundException: A
        at java.base/jdk.internal.loader.BuiltinClassLoader.loadClass<span class="token punctuation">(</span>BuiltinClassLoader.java:606<span class="token punctuation">)</span>
        at java.base/jdk.internal.loader.ClassLoaders<span class="token variable">$AppClassLoader</span>.loadClass<span class="token punctuation">(</span>ClassLoaders.java:168<span class="token punctuation">)</span>
        at java.base/java.lang.ClassLoader.loadClass<span class="token punctuation">(</span>ClassLoader.java:522<span class="token punctuation">)</span>
        <span class="token punctuation">..</span>. <span class="token number">1</span> <span class="token function">more</span>
</code></pre><div class="line-numbers" aria-hidden="true"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><p>根据JLS，注解不需在运行时可用。然而，<strong>当其他代码读取该注解并对其进行操作时（就像我们所做的），注解必须在运行时存在</strong>。否则，我们将看到一个_ClassNotFoundException_。</p><h2 id="结论" tabindex="-1"><a class="header-anchor" href="#结论"><span>结论</span></a></h2><p>在本文中，我们看到了即使注解是类二进制表示的一部分，它们在运行时也可能缺席。</p><p>像往常一样，所有示例都可以在GitHub上找到。</p>`,49),o=[p];function l(c,i){return s(),n("div",null,o)}const r=a(e,[["render",l],["__file","2024-07-27-Why Missing Annotations Don t Cause ClassNotFoundException.html.vue"]]),v=JSON.parse('{"path":"/posts/baeldung/2024-07-27/2024-07-27-Why%20Missing%20Annotations%20Don%20t%20Cause%20ClassNotFoundException.html","title":"为什么缺少注解不会导致ClassNotFoundException","lang":"zh-CN","frontmatter":{"date":"2022-04-01T00:00:00.000Z","category":["Java","Annotations"],"tag":["Java","Annotation","ClassNotFoundException"],"head":[["meta",{"name":"keywords","content":"Java, Annotation, ClassNotFoundException, Runtime, Reflection"}],["meta",{"property":"og:url","content":"https://www.kahen.xyz/posts/baeldung/2024-07-27/2024-07-27-Why%20Missing%20Annotations%20Don%20t%20Cause%20ClassNotFoundException.html"}],["meta",{"property":"og:site_name","content":"Baeldung 中文网"}],["meta",{"property":"og:title","content":"为什么缺少注解不会导致ClassNotFoundException"}],["meta",{"property":"og:description","content":"为什么缺少注解不会导致ClassNotFoundException 在本教程中，我们将熟悉Java编程语言中一个看似奇怪的特性：缺少注解不会导致运行时异常。 然后，我们将深入探讨这种行为背后的规则和原因，以及这些规则的例外情况。 2. 快速回顾 让我们从一个熟悉的Java示例开始。有一个类_A_，然后是依赖于_A_的类_B_： 现在，如果我们编译这些类..."}],["meta",{"property":"og:type","content":"article"}],["meta",{"property":"og:locale","content":"zh-CN"}],["meta",{"property":"og:updated_time","content":"2024-07-27T17:59:05.000Z"}],["meta",{"property":"article:author","content":"Kahen"}],["meta",{"property":"article:tag","content":"Java"}],["meta",{"property":"article:tag","content":"Annotation"}],["meta",{"property":"article:tag","content":"ClassNotFoundException"}],["meta",{"property":"article:published_time","content":"2022-04-01T00:00:00.000Z"}],["meta",{"property":"article:modified_time","content":"2024-07-27T17:59:05.000Z"}],["script",{"type":"application/ld+json"},"{\\"@context\\":\\"https://schema.org\\",\\"@type\\":\\"Article\\",\\"headline\\":\\"为什么缺少注解不会导致ClassNotFoundException\\",\\"image\\":[\\"\\"],\\"datePublished\\":\\"2022-04-01T00:00:00.000Z\\",\\"dateModified\\":\\"2024-07-27T17:59:05.000Z\\",\\"author\\":[{\\"@type\\":\\"Person\\",\\"name\\":\\"Kahen\\",\\"url\\":\\"https://www.kahen.xyz\\"}]}"]],"description":"为什么缺少注解不会导致ClassNotFoundException 在本教程中，我们将熟悉Java编程语言中一个看似奇怪的特性：缺少注解不会导致运行时异常。 然后，我们将深入探讨这种行为背后的规则和原因，以及这些规则的例外情况。 2. 快速回顾 让我们从一个熟悉的Java示例开始。有一个类_A_，然后是依赖于_A_的类_B_： 现在，如果我们编译这些类..."},"headers":[{"level":2,"title":"2. 快速回顾","slug":"_2-快速回顾","link":"#_2-快速回顾","children":[{"level":3,"title":"3.1. 带有类标记的注解","slug":"_3-1-带有类标记的注解","link":"#_3-1-带有类标记的注解","children":[]},{"level":3,"title":"3.2. Java语言规范","slug":"_3-2-java语言规范","link":"#_3-2-java语言规范","children":[]},{"level":3,"title":"3.3. 访问丢失的注解","slug":"_3-3-访问丢失的注解","link":"#_3-3-访问丢失的注解","children":[]}]},{"level":2,"title":"结论","slug":"结论","link":"#结论","children":[]}],"git":{"createdTime":1722103145000,"updatedTime":1722103145000,"contributors":[{"name":"Kahen","email":"Kahen@users.noreply.github.com","commits":1}]},"readingTime":{"minutes":3.92,"words":1177},"filePathRelative":"posts/baeldung/2024-07-27/2024-07-27-Why Missing Annotations Don t Cause ClassNotFoundException.md","localizedDate":"2022年4月1日","excerpt":"<hr>\\n<h1>为什么缺少注解不会导致ClassNotFoundException</h1>\\n<p>在本教程中，我们将熟悉Java编程语言中一个看似奇怪的特性：缺少注解不会导致运行时异常。</p>\\n<p>然后，我们将深入探讨这种行为背后的规则和原因，以及这些规则的例外情况。</p>\\n<h2>2. 快速回顾</h2>\\n<p>让我们从一个熟悉的Java示例开始。有一个类_A_，然后是依赖于_A_的类_B_：</p>\\n<div class=\\"language-java\\" data-ext=\\"java\\" data-title=\\"java\\"><pre class=\\"language-java\\"><code><span class=\\"token keyword\\">public</span> <span class=\\"token keyword\\">class</span> <span class=\\"token class-name\\">A</span> <span class=\\"token punctuation\\">{</span>\\n<span class=\\"token punctuation\\">}</span>\\n\\n<span class=\\"token keyword\\">public</span> <span class=\\"token keyword\\">class</span> <span class=\\"token class-name\\">B</span> <span class=\\"token punctuation\\">{</span>\\n    <span class=\\"token keyword\\">public</span> <span class=\\"token keyword\\">static</span> <span class=\\"token keyword\\">void</span> <span class=\\"token function\\">main</span><span class=\\"token punctuation\\">(</span><span class=\\"token class-name\\">String</span><span class=\\"token punctuation\\">[</span><span class=\\"token punctuation\\">]</span> args<span class=\\"token punctuation\\">)</span> <span class=\\"token punctuation\\">{</span>\\n        <span class=\\"token class-name\\">System</span><span class=\\"token punctuation\\">.</span>out<span class=\\"token punctuation\\">.</span><span class=\\"token function\\">println</span><span class=\\"token punctuation\\">(</span><span class=\\"token keyword\\">new</span> <span class=\\"token class-name\\">A</span><span class=\\"token punctuation\\">(</span><span class=\\"token punctuation\\">)</span><span class=\\"token punctuation\\">)</span><span class=\\"token punctuation\\">;</span>\\n    <span class=\\"token punctuation\\">}</span>\\n<span class=\\"token punctuation\\">}</span>\\n</code></pre></div>","autoDesc":true}');export{r as comp,v as data};
