import{_ as n}from"./plugin-vue_export-helper-DlAUqK2U.js";import{c as s,o as a,a as t}from"./app-C5QtKXnb.js";const e={},p=t(`<hr><h1 id="使用jpa返回自动生成的id" tabindex="-1"><a class="header-anchor" href="#使用jpa返回自动生成的id"><span>使用JPA返回自动生成的ID</span></a></h1><h2 id="_1-引言" tabindex="-1"><a class="header-anchor" href="#_1-引言"><span>1. 引言</span></a></h2><p>在本教程中，我们将讨论<strong>如何处理JPA中的自动生成ID</strong>。在我们看一个实际的例子之前，必须理解两个关键概念，即生命周期和ID生成策略。</p><h2 id="_2-实体生命周期和id生成" tabindex="-1"><a class="header-anchor" href="#_2-实体生命周期和id生成"><span>2. 实体生命周期和ID生成</span></a></h2><p>每个实体在其生命周期中有四种可能的状态。这些状态是<strong>新</strong>、<strong>托管</strong>、<strong>分离</strong>和<strong>删除</strong>。我们的重点将放在<strong>新</strong>和<strong>托管</strong>状态。<strong>在对象创建期间，实体处于新状态</strong>。因此，<strong>EntityManager</strong>不知道这个对象。调用<strong>EntityManager</strong>上的<strong>persist</strong>方法，对象从<strong>新</strong>转变为<strong>托管</strong>状态。此方法需要一个活动的事务。</p><p>JPA定义了四种ID生成策略。我们可以将这四种策略分为两类：</p><ul><li>ID在<strong>提交</strong>之前预先分配并可用于<strong>EntityManager</strong></li><li>ID在事务<strong>提交</strong>后分配</li></ul><p>有关每种ID生成策略的更多详细信息，请参阅我们的文章《JPA何时设置主键》。</p><h2 id="_3-问题陈述" tabindex="-1"><a class="header-anchor" href="#_3-问题陈述"><span>3. 问题陈述</span></a></h2><p>返回对象的ID可能成为一个繁琐的任务。我们需要理解上一节中提到的原则以避免问题。<strong>根据JPA配置，服务可能会返回ID等于零（或null）的对象</strong>。重点将放在服务类实现以及不同的修改如何为我们提供解决方案。</p><p>我们将创建一个带有JPA规范和Hibernate作为其实现的Maven模块。为了简单起见，我们将使用H2内存数据库。</p><p>让我们从创建一个领域实体并将其映射到数据库表开始。在这个例子中，我们将创建一个带有一些基本属性的_User_实体：</p><div class="language-java line-numbers-mode" data-ext="java" data-title="java"><pre class="language-java"><code><span class="token annotation punctuation">@Entity</span>
<span class="token keyword">public</span> <span class="token keyword">class</span> <span class="token class-name">User</span> <span class="token punctuation">{</span>
    <span class="token annotation punctuation">@Id</span>
    <span class="token annotation punctuation">@GeneratedValue</span><span class="token punctuation">(</span>strategy <span class="token operator">=</span> <span class="token class-name">GenerationType</span><span class="token punctuation">.</span><span class="token constant">IDENTITY</span><span class="token punctuation">)</span>
    <span class="token keyword">private</span> <span class="token keyword">long</span> id<span class="token punctuation">;</span>
    <span class="token keyword">private</span> <span class="token class-name">String</span> username<span class="token punctuation">;</span>
    <span class="token keyword">private</span> <span class="token class-name">String</span> password<span class="token punctuation">;</span>

    <span class="token comment">//...</span>
<span class="token punctuation">}</span>
</code></pre><div class="line-numbers" aria-hidden="true"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><p>在领域类之后，我们将创建一个_UserService_类。这个简单的服务将有一个对_EntityManager_的引用和一个将_User_对象保存到数据库的方法：</p><div class="language-java line-numbers-mode" data-ext="java" data-title="java"><pre class="language-java"><code><span class="token keyword">public</span> <span class="token keyword">class</span> <span class="token class-name">UserService</span> <span class="token punctuation">{</span>
    <span class="token class-name">EntityManager</span> entityManager<span class="token punctuation">;</span>

    <span class="token keyword">public</span> <span class="token class-name">UserService</span><span class="token punctuation">(</span><span class="token class-name">EntityManager</span> entityManager<span class="token punctuation">)</span> <span class="token punctuation">{</span>
        <span class="token keyword">this</span><span class="token punctuation">.</span>entityManager <span class="token operator">=</span> entityManager<span class="token punctuation">;</span>
    <span class="token punctuation">}</span>

    <span class="token annotation punctuation">@Transactional</span>
    <span class="token keyword">public</span> <span class="token keyword">long</span> <span class="token function">saveUser</span><span class="token punctuation">(</span><span class="token class-name">User</span> user<span class="token punctuation">)</span><span class="token punctuation">{</span>
        entityManager<span class="token punctuation">.</span><span class="token function">persist</span><span class="token punctuation">(</span>user<span class="token punctuation">)</span><span class="token punctuation">;</span>
        <span class="token keyword">return</span> user<span class="token punctuation">.</span><span class="token function">getId</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
    <span class="token punctuation">}</span>
<span class="token punctuation">}</span>
</code></pre><div class="line-numbers" aria-hidden="true"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><p>这种设置是我们之前提到的常见陷阱。我们可以通过测试证明_saveUser_方法的返回值为零：</p><div class="language-java line-numbers-mode" data-ext="java" data-title="java"><pre class="language-java"><code><span class="token annotation punctuation">@Test</span>
<span class="token keyword">public</span> <span class="token keyword">void</span> <span class="token function">whenNewUserIsPersisted_thenEntityHasNoId</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>
    <span class="token class-name">User</span> user <span class="token operator">=</span> <span class="token keyword">new</span> <span class="token class-name">User</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
    user<span class="token punctuation">.</span><span class="token function">setUsername</span><span class="token punctuation">(</span><span class="token string">&quot;test&quot;</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
    user<span class="token punctuation">.</span><span class="token function">setPassword</span><span class="token punctuation">(</span><span class="token constant">UUID</span><span class="token punctuation">.</span><span class="token function">randomUUID</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">.</span><span class="token function">toString</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">;</span>

    <span class="token keyword">long</span> index <span class="token operator">=</span> service<span class="token punctuation">.</span><span class="token function">saveUser</span><span class="token punctuation">(</span>user<span class="token punctuation">)</span><span class="token punctuation">;</span>

    <span class="token class-name">Assert</span><span class="token punctuation">.</span><span class="token function">assertEquals</span><span class="token punctuation">(</span><span class="token number">0L</span><span class="token punctuation">,</span> index<span class="token punctuation">)</span><span class="token punctuation">;</span>
<span class="token punctuation">}</span>
</code></pre><div class="line-numbers" aria-hidden="true"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><p>在接下来的几节中，我们将回顾为什么会发生这种情况，以及如何解决它。</p><h2 id="_4-手动事务控制" tabindex="-1"><a class="header-anchor" href="#_4-手动事务控制"><span>4. 手动事务控制</span></a></h2><p>在对象创建后，我们的_User_实体处于<strong>新</strong>状态。在_saveUser_方法中调用<strong>persist</strong>方法后，实体状态变为<strong>托管</strong>。我们从回顾部分记得<strong>托管对象在事务提交后获得ID</strong>。由于_saveUser_方法仍在运行，由_@Transactional_注释创建的事务尚未提交。我们的托管实体在_saveUser_完成执行时获得ID。</p><p>一个可能的解决方案是<strong>手动调用_EntityManager_上的_flush_方法</strong>。另一方面，我们可以<strong>手动控制事务</strong>并确保我们的方法正确返回ID。我们可以使用_EntityManager_做到这一点：</p><div class="language-java line-numbers-mode" data-ext="java" data-title="java"><pre class="language-java"><code><span class="token annotation punctuation">@Test</span>
<span class="token keyword">public</span> <span class="token keyword">void</span> <span class="token function">whenTransactionIsControlled_thenEntityHasId</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>
    <span class="token class-name">User</span> user <span class="token operator">=</span> <span class="token keyword">new</span> <span class="token class-name">User</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
    user<span class="token punctuation">.</span><span class="token function">setUsername</span><span class="token punctuation">(</span><span class="token string">&quot;test&quot;</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
    user<span class="token punctuation">.</span><span class="token function">setPassword</span><span class="token punctuation">(</span><span class="token constant">UUID</span><span class="token punctuation">.</span><span class="token function">randomUUID</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">.</span><span class="token function">toString</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">;</span>

    entityManager<span class="token punctuation">.</span><span class="token function">getTransaction</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">.</span><span class="token function">begin</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
    <span class="token keyword">long</span> index <span class="token operator">=</span> service<span class="token punctuation">.</span><span class="token function">saveUser</span><span class="token punctuation">(</span>user<span class="token punctuation">)</span><span class="token punctuation">;</span>
    entityManager<span class="token punctuation">.</span><span class="token function">getTransaction</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">.</span><span class="token function">commit</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>

    <span class="token class-name">Assert</span><span class="token punctuation">.</span><span class="token function">assertEquals</span><span class="token punctuation">(</span><span class="token number">2L</span><span class="token punctuation">,</span> index<span class="token punctuation">)</span><span class="token punctuation">;</span>
<span class="token punctuation">}</span>
</code></pre><div class="line-numbers" aria-hidden="true"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><h2 id="_5-使用id生成策略" tabindex="-1"><a class="header-anchor" href="#_5-使用id生成策略"><span>5. 使用ID生成策略</span></a></h2><p>到目前为止，我们使用了第二类策略，其中ID分配发生在事务<strong>提交</strong>之后。<strong>预分配策略可以在事务提交之前为我们提供ID，因为它们在内存中保留一些ID</strong>。这种选项并不总是可能实现，因为并非所有数据库引擎都支持所有生成策略。将策略更改为_GenerationType.SEQUENCE_可以解决我们的问题。这种策略使用数据库序列而不是_GenerationType.IDENTITY_中的自增列。</p><p>要更改策略，我们将编辑我们的领域实体类：</p><div class="language-java line-numbers-mode" data-ext="java" data-title="java"><pre class="language-java"><code><span class="token annotation punctuation">@Entity</span>
<span class="token keyword">public</span> <span class="token keyword">class</span> <span class="token class-name">User</span> <span class="token punctuation">{</span>
    <span class="token annotation punctuation">@Id</span>
    <span class="token annotation punctuation">@GeneratedValue</span><span class="token punctuation">(</span>strategy <span class="token operator">=</span> <span class="token class-name">GenerationType</span><span class="token punctuation">.</span><span class="token constant">SEQUENCE</span><span class="token punctuation">)</span>
    <span class="token keyword">private</span> <span class="token keyword">long</span> id<span class="token punctuation">;</span>

    <span class="token comment">//...</span>
<span class="token punctuation">}</span>
</code></pre><div class="line-numbers" aria-hidden="true"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><h2 id="_6-结论" tabindex="-1"><a class="header-anchor" href="#_6-结论"><span>6. 结论</span></a></h2><p>在本文中，我们涵盖了JPA中的ID生成技术。首先，我们回顾了ID生成的最重要的关键方面。然后我们涵盖了JPA中使用的常见配置，以及它们的优点和缺点。本文中引用的所有代码都可以在GitHub上找到。头文件中的&quot;Last updated&quot;日期为2022-04-01，因此翻译的日期应为2022-04-01。根据您提供的链接和要求，翻译内容如下：</p><hr><p>date: 2022-04-01 category:</p><ul><li>JPA</li><li>Hibernate tag:</li><li>JPA</li><li>ID生成</li><li>Hibernate</li><li>数据库 head:</li><li><ul><li>meta</li><li>name: keywords content: JPA, Hibernate, ID生成, 数据库</li></ul></li></ul><hr><h1 id="使用jpa返回自动生成的id-1" tabindex="-1"><a class="header-anchor" href="#使用jpa返回自动生成的id-1"><span>使用JPA返回自动生成的ID</span></a></h1><h2 id="_1-引言-1" tabindex="-1"><a class="header-anchor" href="#_1-引言-1"><span>1. 引言</span></a></h2><p>在本教程中，我们将讨论<strong>如何处理JPA中的自动生成ID</strong>。在我们看一个实际的例子之前，必须理解两个关键概念，即生命周期和ID生成策略。</p><h2 id="_2-实体生命周期和id生成-1" tabindex="-1"><a class="header-anchor" href="#_2-实体生命周期和id生成-1"><span>2. 实体生命周期和ID生成</span></a></h2><p>每个实体在其生命周期中有四种可能的状态。这些状态是<strong>新</strong>、<strong>托管</strong>、<strong>分离</strong>和<strong>删除</strong>。我们的重点将放在<strong>新</strong>和<strong>托管</strong>状态。<strong>在对象创建期间，实体处于新状态</strong>。因此，<strong>EntityManager</strong>不知道这个对象。调用<strong>EntityManager</strong>上的<strong>persist</strong>方法，对象从<strong>新</strong>转变为<strong>托管</strong>状态。此方法需要一个活动的事务。</p><p>JPA定义了四种ID生成策略。我们可以将这四种策略分为两类：</p><ul><li>ID在<strong>提交</strong>之前预先分配并可用于<strong>EntityManager</strong></li><li>ID在事务<strong>提交</strong>后分配</li></ul><p>有关每种ID生成策略的更多详细信息，请参阅我们的文章《JPA何时设置主键》。</p><h2 id="_3-问题陈述-1" tabindex="-1"><a class="header-anchor" href="#_3-问题陈述-1"><span>3. 问题陈述</span></a></h2><p>返回对象的ID可能成为一个繁琐的任务。我们需要理解上一节中提到的原则以避免问题。<strong>根据JPA配置，服务可能会返回ID等于零（或null）的对象</strong>。重点将放在服务类实现以及不同的修改如何为我们提供解决方案。</p><p>我们将创建一个带有JPA规范和Hibernate作为其实现的Maven模块。为了简单起见，我们将使用H2内存数据库。</p><p>让我们从创建一个领域实体并将其映射到数据库表开始。在这个例子中，我们将创建一个带有一些基本属性的_User_实体：</p><div class="language-java line-numbers-mode" data-ext="java" data-title="java"><pre class="language-java"><code><span class="token annotation punctuation">@Entity</span>
<span class="token keyword">public</span> <span class="token keyword">class</span> <span class="token class-name">User</span> <span class="token punctuation">{</span>
    <span class="token annotation punctuation">@Id</span>
    <span class="token annotation punctuation">@GeneratedValue</span><span class="token punctuation">(</span>strategy <span class="token operator">=</span> <span class="token class-name">GenerationType</span><span class="token punctuation">.</span><span class="token constant">IDENTITY</span><span class="token punctuation">)</span>
    <span class="token keyword">private</span> <span class="token keyword">long</span> id<span class="token punctuation">;</span>
    <span class="token keyword">private</span> <span class="token class-name">String</span> username<span class="token punctuation">;</span>
    <span class="token keyword">private</span> <span class="token class-name">String</span> password<span class="token punctuation">;</span>

    <span class="token comment">//...</span>
<span class="token punctuation">}</span>
</code></pre><div class="line-numbers" aria-hidden="true"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><p>在领域类之后，我们将创建一个_UserService_类。这个简单的服务将有一个对_EntityManager_的引用和一个将_User_对象保存到数据库的方法：</p><div class="language-java line-numbers-mode" data-ext="java" data-title="java"><pre class="language-java"><code><span class="token keyword">public</span> <span class="token keyword">class</span> <span class="token class-name">UserService</span> <span class="token punctuation">{</span>
    <span class="token class-name">EntityManager</span> entityManager<span class="token punctuation">;</span>

    <span class="token keyword">public</span> <span class="token class-name">UserService</span><span class="token punctuation">(</span><span class="token class-name">EntityManager</span> entityManager<span class="token punctuation">)</span> <span class="token punctuation">{</span>
        <span class="token keyword">this</span><span class="token punctuation">.</span>entityManager <span class="token operator">=</span> entityManager<span class="token punctuation">;</span>
    <span class="token punctuation">}</span>

    <span class="token annotation punctuation">@Transactional</span>
    <span class="token keyword">public</span> <span class="token keyword">long</span> <span class="token function">saveUser</span><span class="token punctuation">(</span><span class="token class-name">User</span> user<span class="token punctuation">)</span><span class="token punctuation">{</span>
        entityManager<span class="token punctuation">.</span><span class="token function">persist</span><span class="token punctuation">(</span>user<span class="token punctuation">)</span><span class="token punctuation">;</span>
        <span class="token keyword">return</span> user<span class="token punctuation">.</span><span class="token function">getId</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
    <span class="token punctuation">}</span>
<span class="token punctuation">}</span>
</code></pre><div class="line-numbers" aria-hidden="true"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><p>这种设置是我们之前提到的常见陷阱。我们可以通过测试证明_saveUser_方法的返回值为零：</p><div class="language-java line-numbers-mode" data-ext="java" data-title="java"><pre class="language-java"><code><span class="token annotation punctuation">@Test</span>
<span class="token keyword">public</span> <span class="token keyword">void</span> <span class="token function">whenNewUserIsPersisted_thenEntityHasNoId</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>
    <span class="token class-name">User</span> user <span class="token operator">=</span> <span class="token keyword">new</span> <span class="token class-name">User</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
    user<span class="token punctuation">.</span><span class="token function">setUsername</span><span class="token punctuation">(</span><span class="token string">&quot;test&quot;</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
    user<span class="token punctuation">.</span><span class="token function">setPassword</span><span class="token punctuation">(</span><span class="token constant">UUID</span><span class="token punctuation">.</span><span class="token function">randomUUID</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">.</span><span class="token function">toString</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">;</span>

    <span class="token keyword">long</span> index <span class="token operator">=</span> service<span class="token punctuation">.</span><span class="token function">saveUser</span><span class="token punctuation">(</span>user<span class="token punctuation">)</span><span class="token punctuation">;</span>

    <span class="token class-name">Assert</span><span class="token punctuation">.</span><span class="token function">assertEquals</span><span class="token punctuation">(</span><span class="token number">0L</span><span class="token punctuation">,</span> index<span class="token punctuation">)</span><span class="token punctuation">;</span>
<span class="token punctuation">}</span>
</code></pre><div class="line-numbers" aria-hidden="true"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><p>在接下来的几节中，我们将回顾为什么会发生这种情况，以及如何解决它。</p><h2 id="_4-手动事务控制-1" tabindex="-1"><a class="header-anchor" href="#_4-手动事务控制-1"><span>4. 手动事务控制</span></a></h2><p>在对象创建后，我们的_User_实体处于<strong>新</strong>状态。在_saveUser_方法中调用<strong>persist</strong>方法后，实体状态变为<strong>托管</strong>。我们从回顾部分记得<strong>托管对象在事务提交后获得ID</strong>。由于_saveUser_方法仍在运行，由_@Transactional_注释创建的事务尚未提交。我们的托管实体在_saveUser_完成执行时获得ID。</p><p>一个可能的解决方案是<strong>手动调用_EntityManager_上的_flush_方法</strong>。另一方面，我们可以<strong>手动控制事务</strong>并确保我们的方法正确返回ID。我们可以使用_EntityManager_做到这一点：</p><div class="language-java line-numbers-mode" data-ext="java" data-title="java"><pre class="language-java"><code><span class="token annotation punctuation">@Test</span>
<span class="token keyword">public</span> <span class="token keyword">void</span> <span class="token function">whenTransactionIsControlled_thenEntityHasId</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>
    <span class="token class-name">User</span> user <span class="token operator">=</span> <span class="token keyword">new</span> <span class="token class-name">User</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
    user<span class="token punctuation">.</span><span class="token function">setUsername</span><span class="token punctuation">(</span><span class="token string">&quot;test&quot;</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
    user<span class="token punctuation">.</span><span class="token function">setPassword</span><span class="token punctuation">(</span><span class="token constant">UUID</span><span class="token punctuation">.</span><span class="token function">randomUUID</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">.</span><span class="token function">toString</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">;</span>

    entityManager<span class="token punctuation">.</span><span class="token function">getTransaction</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">.</span><span class="token function">begin</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
    <span class="token keyword">long</span> index <span class="token operator">=</span> service<span class="token punctuation">.</span><span class="token function">saveUser</span><span class="token punctuation">(</span>user<span class="token punctuation">)</span><span class="token punctuation">;</span>
    entityManager<span class="token punctuation">.</span><span class="token function">getTransaction</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">.</span><span class="token function">commit</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>

    <span class="token class-name">Assert</span><span class="token punctuation">.</span><span class="token function">assertEquals</span><span class="token punctuation">(</span><span class="token number">2L</span><span class="token punctuation">,</span> index<span class="token punctuation">)</span><span class="token punctuation">;</span>
<span class="token punctuation">}</span>
</code></pre><div class="line-numbers" aria-hidden="true"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><h2 id="_5-使用id生成策略-1" tabindex="-1"><a class="header-anchor" href="#_5-使用id生成策略-1"><span>5. 使用ID生成策略</span></a></h2><p>到目前为止，我们使用了第二类策略，其中ID分配发生在事务<strong>提交</strong>之后。<strong>预分配策略可以在事务提交之前为我们提供ID，因为它们在内存中保留一些ID</strong>。这种选项并不总是可能实现，因为并非所有数据库引擎都支持所有生成策略。将策略更改为_GenerationType.SEQUENCE_可以解决我们的问题。这种策略使用数据库序列而不是_GenerationType.IDENTITY_中的自增列。</p><p>要更改策略，我们将编辑我们的领域实体类：</p><div class="language-java line-numbers-mode" data-ext="java" data-title="java"><pre class="language-java"><code><span class="token annotation punctuation">@Entity</span>
<span class="token keyword">public</span> <span class="token keyword">class</span> <span class="token class-name">User</span> <span class="token punctuation">{</span>
    <span class="token annotation punctuation">@Id</span>
    <span class="token annotation punctuation">@GeneratedValue</span><span class="token punctuation">(</span>strategy <span class="token operator">=</span> <span class="token class-name">GenerationType</span><span class="token punctuation">.</span><span class="token constant">SEQUENCE</span><span class="token punctuation">)</span>
    <span class="token keyword">private</span> <span class="token keyword">long</span> id<span class="token punctuation">;</span>

    <span class="token comment">//...</span>
<span class="token punctuation">}</span>
</code></pre><div class="line-numbers" aria-hidden="true"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><h2 id="_6-结论-1" tabindex="-1"><a class="header-anchor" href="#_6-结论-1"><span>6. 结论</span></a></h2><p>在本文中，我们涵盖了JPA中的ID生成技术。首先，我们回顾了ID生成的最重要的关键方面。然后我们涵盖了JPA中使用的常见配置，以及它们的优点和缺点。本文中引用的所有代码都可以在GitHub上找到。</p><p>OK</p>`,62),o=[p];function i(c,l){return a(),s("div",null,o)}const d=n(e,[["render",i],["__file","2024-07-30-Returning an Auto Generated Id with JPA.html.vue"]]),k=JSON.parse('{"path":"/posts/baeldung/2024-07-30/2024-07-30-Returning%20an%20Auto%20Generated%20Id%20with%20JPA.html","title":"使用JPA返回自动生成的ID","lang":"zh-CN","frontmatter":{"date":"2022-04-01T00:00:00.000Z","category":["JPA","Hibernate"],"tag":["JPA","ID生成","Hibernate","数据库"],"head":[["meta",{"name":"keywords","content":"JPA, Hibernate, ID生成, 数据库"}],["meta",{"property":"og:url","content":"https://www.kahen.xyz/posts/baeldung/2024-07-30/2024-07-30-Returning%20an%20Auto%20Generated%20Id%20with%20JPA.html"}],["meta",{"property":"og:site_name","content":"Baeldung 中文网"}],["meta",{"property":"og:title","content":"使用JPA返回自动生成的ID"}],["meta",{"property":"og:description","content":"使用JPA返回自动生成的ID 1. 引言 在本教程中，我们将讨论如何处理JPA中的自动生成ID。在我们看一个实际的例子之前，必须理解两个关键概念，即生命周期和ID生成策略。 2. 实体生命周期和ID生成 每个实体在其生命周期中有四种可能的状态。这些状态是新、托管、分离和删除。我们的重点将放在新和托管状态。在对象创建期间，实体处于新状态。因此，Entit..."}],["meta",{"property":"og:type","content":"article"}],["meta",{"property":"og:locale","content":"zh-CN"}],["meta",{"property":"og:updated_time","content":"2024-07-30T01:09:08.000Z"}],["meta",{"property":"article:author","content":"Kahen"}],["meta",{"property":"article:tag","content":"JPA"}],["meta",{"property":"article:tag","content":"ID生成"}],["meta",{"property":"article:tag","content":"Hibernate"}],["meta",{"property":"article:tag","content":"数据库"}],["meta",{"property":"article:published_time","content":"2022-04-01T00:00:00.000Z"}],["meta",{"property":"article:modified_time","content":"2024-07-30T01:09:08.000Z"}],["script",{"type":"application/ld+json"},"{\\"@context\\":\\"https://schema.org\\",\\"@type\\":\\"Article\\",\\"headline\\":\\"使用JPA返回自动生成的ID\\",\\"image\\":[\\"\\"],\\"datePublished\\":\\"2022-04-01T00:00:00.000Z\\",\\"dateModified\\":\\"2024-07-30T01:09:08.000Z\\",\\"author\\":[{\\"@type\\":\\"Person\\",\\"name\\":\\"Kahen\\",\\"url\\":\\"https://www.kahen.xyz\\"}]}"]],"description":"使用JPA返回自动生成的ID 1. 引言 在本教程中，我们将讨论如何处理JPA中的自动生成ID。在我们看一个实际的例子之前，必须理解两个关键概念，即生命周期和ID生成策略。 2. 实体生命周期和ID生成 每个实体在其生命周期中有四种可能的状态。这些状态是新、托管、分离和删除。我们的重点将放在新和托管状态。在对象创建期间，实体处于新状态。因此，Entit..."},"headers":[{"level":2,"title":"1. 引言","slug":"_1-引言","link":"#_1-引言","children":[]},{"level":2,"title":"2. 实体生命周期和ID生成","slug":"_2-实体生命周期和id生成","link":"#_2-实体生命周期和id生成","children":[]},{"level":2,"title":"3. 问题陈述","slug":"_3-问题陈述","link":"#_3-问题陈述","children":[]},{"level":2,"title":"4. 手动事务控制","slug":"_4-手动事务控制","link":"#_4-手动事务控制","children":[]},{"level":2,"title":"5. 使用ID生成策略","slug":"_5-使用id生成策略","link":"#_5-使用id生成策略","children":[]},{"level":2,"title":"6. 结论","slug":"_6-结论","link":"#_6-结论","children":[]},{"level":2,"title":"1. 引言","slug":"_1-引言-1","link":"#_1-引言-1","children":[]},{"level":2,"title":"2. 实体生命周期和ID生成","slug":"_2-实体生命周期和id生成-1","link":"#_2-实体生命周期和id生成-1","children":[]},{"level":2,"title":"3. 问题陈述","slug":"_3-问题陈述-1","link":"#_3-问题陈述-1","children":[]},{"level":2,"title":"4. 手动事务控制","slug":"_4-手动事务控制-1","link":"#_4-手动事务控制-1","children":[]},{"level":2,"title":"5. 使用ID生成策略","slug":"_5-使用id生成策略-1","link":"#_5-使用id生成策略-1","children":[]},{"level":2,"title":"6. 结论","slug":"_6-结论-1","link":"#_6-结论-1","children":[]}],"git":{"createdTime":1722301748000,"updatedTime":1722301748000,"contributors":[{"name":"Kahen","email":"Kahen@users.noreply.github.com","commits":1}]},"readingTime":{"minutes":7.38,"words":2213},"filePathRelative":"posts/baeldung/2024-07-30/2024-07-30-Returning an Auto Generated Id with JPA.md","localizedDate":"2022年4月1日","excerpt":"<hr>\\n<h1>使用JPA返回自动生成的ID</h1>\\n<h2>1. 引言</h2>\\n<p>在本教程中，我们将讨论<strong>如何处理JPA中的自动生成ID</strong>。在我们看一个实际的例子之前，必须理解两个关键概念，即生命周期和ID生成策略。</p>\\n<h2>2. 实体生命周期和ID生成</h2>\\n<p>每个实体在其生命周期中有四种可能的状态。这些状态是<strong>新</strong>、<strong>托管</strong>、<strong>分离</strong>和<strong>删除</strong>。我们的重点将放在<strong>新</strong>和<strong>托管</strong>状态。<strong>在对象创建期间，实体处于新状态</strong>。因此，<strong>EntityManager</strong>不知道这个对象。调用<strong>EntityManager</strong>上的<strong>persist</strong>方法，对象从<strong>新</strong>转变为<strong>托管</strong>状态。此方法需要一个活动的事务。</p>","autoDesc":true}');export{d as comp,k as data};
