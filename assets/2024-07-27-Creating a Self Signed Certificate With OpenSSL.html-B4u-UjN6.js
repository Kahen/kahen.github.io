import{_ as a}from"./plugin-vue_export-helper-DlAUqK2U.js";import{c as e,o as n,a as s}from"./app-DpDzgwdT.js";const t={},p=s(`<h1 id="使用openssl创建自签名证书" tabindex="-1"><a class="header-anchor" href="#使用openssl创建自签名证书"><span>使用OpenSSL创建自签名证书</span></a></h1><h2 id="_1-概述" tabindex="-1"><a class="header-anchor" href="#_1-概述"><span>1. 概述</span></a></h2><p>OpenSSL是一个开源的命令行工具，允许用户执行各种与SSL相关的任务。</p><p>在本教程中，我们将学习<strong>如何使用OpenSSL创建自签名证书</strong>。</p><h2 id="_2-创建私钥" tabindex="-1"><a class="header-anchor" href="#_2-创建私钥"><span>2. 创建私钥</span></a></h2><p>首先，我们将创建一个私钥。私钥有助于实现加密，是我们证书中最重要的组成部分。</p><p>让我们使用<code>openssl</code>命令创建一个带密码保护的、2048位的RSA私钥（<em>domain.key</em>）：</p><div class="language-bash line-numbers-mode" data-ext="sh" data-title="sh"><pre class="language-bash"><code>openssl genrsa <span class="token parameter variable">-des3</span> <span class="token parameter variable">-out</span> domain.key <span class="token number">2048</span>
</code></pre><div class="line-numbers" aria-hidden="true"><div class="line-number"></div></div></div><p>当提示时，我们将输入一个密码。输出将看起来像：</p><div class="language-bash line-numbers-mode" data-ext="sh" data-title="sh"><pre class="language-bash"><code>Generating RSA private key, <span class="token number">2048</span> bit long modulus <span class="token punctuation">(</span><span class="token number">2</span> primes<span class="token punctuation">)</span>
<span class="token punctuation">..</span><span class="token punctuation">..</span><span class="token punctuation">..</span><span class="token punctuation">..</span><span class="token punctuation">..</span><span class="token punctuation">..</span><span class="token punctuation">..</span><span class="token punctuation">..</span><span class="token punctuation">..</span><span class="token punctuation">..</span>.+++++
<span class="token punctuation">..</span><span class="token punctuation">..</span><span class="token punctuation">..</span><span class="token punctuation">..</span>.+++++e is <span class="token number">65537</span> <span class="token punctuation">(</span>0x010001<span class="token punctuation">)</span>
Enter pass phrase <span class="token keyword">for</span> domain.key:
Verifying - Enter pass phrase <span class="token keyword">for</span> domain.key:
</code></pre><div class="line-numbers" aria-hidden="true"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><p>如果我们想要我们的私钥不被加密，我们可以简单地从命令中移除<code>-des3</code>选项。</p><h2 id="_3-创建证书签名请求" tabindex="-1"><a class="header-anchor" href="#_3-创建证书签名请求"><span>3. 创建证书签名请求</span></a></h2><p><strong>如果我们想要我们的证书被签名，我们需要一个证书签名请求（CSR）</strong>。CSR包括公钥和一些额外信息（例如组织和国家）。</p><p>让我们从我们现有的私钥创建一个CSR（<em>domain.csr</em>）：</p><div class="language-bash line-numbers-mode" data-ext="sh" data-title="sh"><pre class="language-bash"><code>openssl req <span class="token parameter variable">-key</span> domain.key <span class="token parameter variable">-new</span> <span class="token parameter variable">-out</span> domain.csr
</code></pre><div class="line-numbers" aria-hidden="true"><div class="line-number"></div></div></div><p>我们将输入我们的私钥密码和一些CSR信息以完成这个过程。输出将看起来像：</p><div class="language-bash line-numbers-mode" data-ext="sh" data-title="sh"><pre class="language-bash"><code>Enter pass phrase <span class="token keyword">for</span> domain.key:
You are about to be asked to enter information that will be incorporated
into your certificate request.
What you are about to enter is what is called a Distinguished Name or a DN.
There are quite a few fields but you can leave some blank
For some fields there will be a default value,
If you enter <span class="token string">&#39;.&#39;</span>, the field will be left blank.
-----
Country Name <span class="token punctuation">(</span><span class="token number">2</span> letter code<span class="token punctuation">)</span> <span class="token punctuation">[</span>AU<span class="token punctuation">]</span>:AU
State or Province Name <span class="token punctuation">(</span>full name<span class="token punctuation">)</span> <span class="token punctuation">[</span>Some-State<span class="token punctuation">]</span>:stateA
Locality Name <span class="token punctuation">(</span>eg, city<span class="token punctuation">)</span> <span class="token punctuation">[</span><span class="token punctuation">]</span>:cityA
Organization Name <span class="token punctuation">(</span>eg, company<span class="token punctuation">)</span> <span class="token punctuation">[</span>Internet Widgits Pty Ltd<span class="token punctuation">]</span>:companyA
Organizational Unit Name <span class="token punctuation">(</span>eg, section<span class="token punctuation">)</span> <span class="token punctuation">[</span><span class="token punctuation">]</span>:sectionA
Common Name <span class="token punctuation">(</span>e.g. server FQDN or YOUR name<span class="token punctuation">)</span> <span class="token punctuation">[</span><span class="token punctuation">]</span>:domain
Email Address <span class="token punctuation">[</span><span class="token punctuation">]</span>:email@email.com

Please enter the following <span class="token string">&#39;extra&#39;</span> attributes
to be sent with your certificate request
A challenge password <span class="token punctuation">[</span><span class="token punctuation">]</span>:
An optional company name <span class="token punctuation">[</span><span class="token punctuation">]</span>:
</code></pre><div class="line-numbers" aria-hidden="true"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><p>一个重要的字段是“<em>Common Name</em>”，它应该是我们域的确切完全限定域名（FQDN）。</p><p>“<em>一个挑战密码</em>”和“<em>一个可选的公司名称</em>”可以留空。</p><p><strong>我们也可以只用一个命令创建私钥和CSR</strong>：</p><div class="language-bash line-numbers-mode" data-ext="sh" data-title="sh"><pre class="language-bash"><code>openssl req <span class="token parameter variable">-newkey</span> rsa:2048 <span class="token parameter variable">-keyout</span> domain.key <span class="token parameter variable">-out</span> domain.csr
</code></pre><div class="line-numbers" aria-hidden="true"><div class="line-number"></div></div></div><p>如果我们想要我们的私钥不被加密，我们可以添加<code>-nodes</code>选项：</p><div class="language-bash line-numbers-mode" data-ext="sh" data-title="sh"><pre class="language-bash"><code>openssl req <span class="token parameter variable">-newkey</span> rsa:2048 <span class="token parameter variable">-noenc</span> <span class="token parameter variable">-keyout</span> domain.key <span class="token parameter variable">-out</span> domain.csr
</code></pre><div class="line-numbers" aria-hidden="true"><div class="line-number"></div></div></div><p>自签名证书是<strong>用它自己的私钥签名的证书</strong>。它可以像CA签名的证书一样用来加密数据，但是我们的用户将会看到一个警告，说证书不被信任。</p><p>让我们使用我们现有的私钥和CSR创建一个自签名证书（<em>domain.crt</em>）：</p><div class="language-bash line-numbers-mode" data-ext="sh" data-title="sh"><pre class="language-bash"><code>openssl x509 <span class="token parameter variable">-signkey</span> domain.key <span class="token parameter variable">-in</span> domain.csr <span class="token parameter variable">-req</span> <span class="token parameter variable">-days</span> <span class="token number">365</span> <span class="token parameter variable">-out</span> domain.crt
</code></pre><div class="line-numbers" aria-hidden="true"><div class="line-number"></div></div></div><p><code>-days</code>选项指定了证书有效期的天数。</p><p>我们可以用一个私钥只创建一个自签名证书：</p><div class="language-bash line-numbers-mode" data-ext="sh" data-title="sh"><pre class="language-bash"><code>openssl req <span class="token parameter variable">-key</span> domain.key <span class="token parameter variable">-new</span> <span class="token parameter variable">-x509</span> <span class="token parameter variable">-days</span> <span class="token number">365</span> <span class="token parameter variable">-out</span> domain.crt
</code></pre><div class="line-numbers" aria-hidden="true"><div class="line-number"></div></div></div><p><strong>这个命令将创建一个临时CSR</strong>。我们当然还是有CSR信息提示。</p><p>我们甚至可以用一个命令创建一个私钥和一个自签名证书：</p><div class="language-bash line-numbers-mode" data-ext="sh" data-title="sh"><pre class="language-bash"><code>openssl req <span class="token parameter variable">-newkey</span> rsa:2048 <span class="token parameter variable">-keyout</span> domain.key <span class="token parameter variable">-x509</span> <span class="token parameter variable">-days</span> <span class="token number">365</span> <span class="token parameter variable">-out</span> domain.crt
</code></pre><div class="line-numbers" aria-hidden="true"><div class="line-number"></div></div></div><h2 id="_5-使用我们自己的ca创建ca签名证书" tabindex="-1"><a class="header-anchor" href="#_5-使用我们自己的ca创建ca签名证书"><span>5. 使用我们自己的CA创建CA签名证书</span></a></h2><p>我们可以成为我们自己的证书颁发机构（CA），通过创建一个自签名的根CA证书，然后将其安装为本地浏览器中的信任证书。</p><h3 id="_5-1-创建自签名根ca" tabindex="-1"><a class="header-anchor" href="#_5-1-创建自签名根ca"><span>5.1. 创建自签名根CA</span></a></h3><p>让我们从命令行创建一个私钥（<em>rootCA.key</em>）和一个自签名根CA证书（<em>rootCA.crt</em>）：</p><div class="language-bash line-numbers-mode" data-ext="sh" data-title="sh"><pre class="language-bash"><code>openssl req <span class="token parameter variable">-x509</span> <span class="token parameter variable">-sha256</span> <span class="token parameter variable">-days</span> <span class="token number">1825</span> <span class="token parameter variable">-newkey</span> rsa:2048 <span class="token parameter variable">-keyout</span> rootCA.key <span class="token parameter variable">-out</span> rootCA.crt
</code></pre><div class="line-numbers" aria-hidden="true"><div class="line-number"></div></div></div><h3 id="_5-2-使用根ca签名我们的csr" tabindex="-1"><a class="header-anchor" href="#_5-2-使用根ca签名我们的csr"><span>5.2. 使用根CA签名我们的CSR</span></a></h3><p>我们可以使用根CA证书及其私钥来签名我们的CSR（<em>domain.csr</em>）：</p><div class="language-bash line-numbers-mode" data-ext="sh" data-title="sh"><pre class="language-bash"><code>openssl x509 <span class="token parameter variable">-req</span> <span class="token parameter variable">-CA</span> rootCA.crt <span class="token parameter variable">-CAkey</span> rootCA.key <span class="token parameter variable">-in</span> domain.csr <span class="token parameter variable">-out</span> domain.crt <span class="token parameter variable">-days</span> <span class="token number">365</span> <span class="token parameter variable">-CAcreateserial</span>
</code></pre><div class="line-numbers" aria-hidden="true"><div class="line-number"></div></div></div><p>结果，CA签名的证书将在_domain.crt_文件中。这将产生一个有效的证书，但浏览器仍然会标记它们。这是因为X.509证书和SAN扩展的更改。</p><h3 id="_5-3-san扩展" tabindex="-1"><a class="header-anchor" href="#_5-3-san扩展"><span>5.3. SAN扩展</span></a></h3><p>X.509证书需要有关为此特定证书发行的域的信息。例如，证书可能是有效的，但用于与发行时不同的域。</p><p><strong>如果我们创建一个没有正确配置_subjectAltName_的证书，我们仍然可以使用它。但是，浏览器会将其标记为不安全</strong>。这种方法可能适用于开发。然而，在组织级别使用这种方法可能会使员工对安全通知不敏感。</p><p>为了符合SAN扩展标准，我们需要创建一个配置文本文件（<em>domain.ext</em>），内容如下：</p><div class="language-bash line-numbers-mode" data-ext="sh" data-title="sh"><pre class="language-bash"><code><span class="token assign-left variable">authorityKeyIdentifier</span><span class="token operator">=</span>keyid,issuer
<span class="token assign-left variable">basicConstraints</span><span class="token operator">=</span>CA:FALSE
subjectAltName <span class="token operator">=</span> @alt_names
<span class="token punctuation">[</span>alt_names<span class="token punctuation">]</span>
DNS.1 <span class="token operator">=</span> domain
</code></pre><div class="line-numbers" aria-hidden="true"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><p>“<em>DNS.1</em>”字段应该是我们网站的域。</p><p>然后，我们可以稍微修改我们之前的命令，并添加有关扩展文件的信息：</p><div class="language-bash line-numbers-mode" data-ext="sh" data-title="sh"><pre class="language-bash"><code>openssl x509 <span class="token parameter variable">-req</span> <span class="token parameter variable">-CA</span> rootCA.crt <span class="token parameter variable">-CAkey</span> rootCA.key <span class="token parameter variable">-in</span> domain.csr <span class="token parameter variable">-out</span> domain.crt <span class="token parameter variable">-days</span> <span class="token number">365</span> <span class="token parameter variable">-CAcreateserial</span> <span class="token parameter variable">-extfile</span> domain.ext
</code></pre><div class="line-numbers" aria-hidden="true"><div class="line-number"></div></div></div><p>现在，我们的证书符合所有SAN要求并且可以正确工作。这个过程需要一个额外的步骤，并且_openssl_不提供此信息的提示，所以我们必须创建一个单独的扩展文件。<strong>然而，SAN使证书更安全</strong>。此外，它允许定义多个域或IP地址，我们可以使用单个证书跨多个域。</p><h2 id="_6-查看证书" tabindex="-1"><a class="header-anchor" href="#_6-查看证书"><span>6. 查看证书</span></a></h2><p>我们可以使用_openssl_命令以纯文本形式查看我们证书的内容：</p><div class="language-bash line-numbers-mode" data-ext="sh" data-title="sh"><pre class="language-bash"><code>openssl x509 <span class="token parameter variable">-text</span> <span class="token parameter variable">-noout</span> <span class="token parameter variable">-in</span> domain.crt
</code></pre><div class="line-numbers" aria-hidden="true"><div class="line-number"></div></div></div><p>输出将看起来像：</p><div class="language-bash line-numbers-mode" data-ext="sh" data-title="sh"><pre class="language-bash"><code>Certificate:
    Data:
        Version: <span class="token number">1</span> <span class="token punctuation">(</span>0x0<span class="token punctuation">)</span>
        Serial Number:
            <span class="token number">64</span>:1a:ad:0f:83:0f:21:33:ff:ac:9e:e6:a5:ec:28:95:b6:e8:8a:f4
        Signature Algorithm: sha256WithRSAEncryption
        Issuer: C <span class="token operator">=</span> AU, ST <span class="token operator">=</span> stateA, L <span class="token operator">=</span> cityA, O <span class="token operator">=</span> companyA, OU <span class="token operator">=</span> sectionA, CN <span class="token operator">=</span> domain, emailAddress <span class="token operator">=</span> email@email.com
        Validity
            Not Before: Jul <span class="token number">12</span> 07:18:18 <span class="token number">2021</span> GMT
            Not After <span class="token builtin class-name">:</span> Jul <span class="token number">12</span> 07:18:18 <span class="token number">2022</span> GMT
        Subject: C <span class="token operator">=</span> AU, ST <span class="token operator">=</span> stateA, L <span class="token operator">=</span> cityA, O <span class="token operator">=</span> companyA, OU <span class="token operator">=</span> sectionA, CN <span class="token operator">=</span> domain, emailAddress <span class="token operator">=</span> email@email.com
        Subject Public Key Info:
            Public Key Algorithm: rsaEncryption
                RSA Public-Key: <span class="token punctuation">(</span><span class="token number">2048</span> bit<span class="token punctuation">)</span>
                Modulus: <span class="token punctuation">[</span><span class="token punctuation">..</span>.<span class="token punctuation">]</span>
                Exponent: <span class="token number">65537</span> <span class="token punctuation">(</span>0x10001<span class="token punctuation">)</span>
    Signature Algorithm: sha256WithRSAEncryption <span class="token punctuation">[</span><span class="token punctuation">..</span>.<span class="token punctuation">]</span>
</code></pre><div class="line-numbers" aria-hidden="true"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><h2 id="_7-转换证书格式" tabindex="-1"><a class="header-anchor" href="#_7-转换证书格式"><span>7. 转换证书格式</span></a></h2><p>我们的证书（<em>domain.crt</em>）是<strong>一个ASCII PEM编码的X.509证书</strong>。我们可以使用OpenSSL将其转换为其他格式以供多用途使用。</p><h3 id="_7-1-将pem转换为der" tabindex="-1"><a class="header-anchor" href="#_7-1-将pem转换为der"><span>7.1. 将PEM转换为DER</span></a></h3><p>DER格式通常与Java一起使用。让我们将我们的PEM编码证书转换为DER编码证书：</p><div class="language-bash line-numbers-mode" data-ext="sh" data-title="sh"><pre class="language-bash"><code>openssl x509 <span class="token parameter variable">-in</span> domain.crt <span class="token parameter variable">-outform</span> der <span class="token parameter variable">-out</span> domain.der
</code></pre><div class="line-numbers" aria-hidden="true"><div class="line-number"></div></div></div><h3 id="_7-2-将pem转换为pkcs12" tabindex="-1"><a class="header-anchor" href="#_7-2-将pem转换为pkcs12"><span>7.2. 将PEM转换为PKCS12</span></a></h3><p>PKCS12文件，也称为PFX文件，通常用于在Microsoft IIS中导入和导出证书链。</p><p>我们将使用以下命令获取我们的私钥和证书，然后将它们组合成一个PKCS12文件：</p><div class="language-bash line-numbers-mode" data-ext="sh" data-title="sh"><pre class="language-bash"><code>openssl pkcs12 <span class="token parameter variable">-inkey</span> domain.key <span class="token parameter variable">-in</span> domain.crt <span class="token parameter variable">-export</span> <span class="token parameter variable">-out</span> domain.pfx
</code></pre><div class="line-numbers" aria-hidden="true"><div class="line-number"></div></div></div><h2 id="_8-结论" tabindex="-1"><a class="header-anchor" href="#_8-结论"><span>8. 结论</span></a></h2><p>在本文中，我们学习了如何从头开始<strong>使用OpenSSL创建自签名证书</strong>，<strong>查看此证书，并将其转换为其他格式</strong>。我们希望这些内容能帮助到你的工作。</p>`,66),i=[p];function l(r,o){return n(),e("div",null,i)}const u=a(t,[["render",l],["__file","2024-07-27-Creating a Self Signed Certificate With OpenSSL.html.vue"]]),m=JSON.parse('{"path":"/posts/baeldung/2024-07-27/2024-07-27-Creating%20a%20Self%20Signed%20Certificate%20With%20OpenSSL.html","title":"使用OpenSSL创建自签名证书","lang":"zh-CN","frontmatter":{"date":"2022-04-01T00:00:00.000Z","category":["Open Source","SSL"],"tag":["OpenSSL","Self-Signed Certificate"],"head":[["meta",{"name":"keywords","content":"SSL, Open Source, Security, Certificate"}],["meta",{"property":"og:url","content":"https://www.kahen.xyz/posts/baeldung/2024-07-27/2024-07-27-Creating%20a%20Self%20Signed%20Certificate%20With%20OpenSSL.html"}],["meta",{"property":"og:site_name","content":"Baeldung 中文网"}],["meta",{"property":"og:title","content":"使用OpenSSL创建自签名证书"}],["meta",{"property":"og:description","content":"使用OpenSSL创建自签名证书 1. 概述 OpenSSL是一个开源的命令行工具，允许用户执行各种与SSL相关的任务。 在本教程中，我们将学习如何使用OpenSSL创建自签名证书。 2. 创建私钥 首先，我们将创建一个私钥。私钥有助于实现加密，是我们证书中最重要的组成部分。 让我们使用openssl命令创建一个带密码保护的、2048位的RSA私钥（d..."}],["meta",{"property":"og:type","content":"article"}],["meta",{"property":"og:locale","content":"zh-CN"}],["meta",{"property":"og:updated_time","content":"2024-07-27T20:00:38.000Z"}],["meta",{"property":"article:author","content":"Kahen"}],["meta",{"property":"article:tag","content":"OpenSSL"}],["meta",{"property":"article:tag","content":"Self-Signed Certificate"}],["meta",{"property":"article:published_time","content":"2022-04-01T00:00:00.000Z"}],["meta",{"property":"article:modified_time","content":"2024-07-27T20:00:38.000Z"}],["script",{"type":"application/ld+json"},"{\\"@context\\":\\"https://schema.org\\",\\"@type\\":\\"Article\\",\\"headline\\":\\"使用OpenSSL创建自签名证书\\",\\"image\\":[\\"\\"],\\"datePublished\\":\\"2022-04-01T00:00:00.000Z\\",\\"dateModified\\":\\"2024-07-27T20:00:38.000Z\\",\\"author\\":[{\\"@type\\":\\"Person\\",\\"name\\":\\"Kahen\\",\\"url\\":\\"https://www.kahen.xyz\\"}]}"]],"description":"使用OpenSSL创建自签名证书 1. 概述 OpenSSL是一个开源的命令行工具，允许用户执行各种与SSL相关的任务。 在本教程中，我们将学习如何使用OpenSSL创建自签名证书。 2. 创建私钥 首先，我们将创建一个私钥。私钥有助于实现加密，是我们证书中最重要的组成部分。 让我们使用openssl命令创建一个带密码保护的、2048位的RSA私钥（d..."},"headers":[{"level":2,"title":"1. 概述","slug":"_1-概述","link":"#_1-概述","children":[]},{"level":2,"title":"2. 创建私钥","slug":"_2-创建私钥","link":"#_2-创建私钥","children":[]},{"level":2,"title":"3. 创建证书签名请求","slug":"_3-创建证书签名请求","link":"#_3-创建证书签名请求","children":[]},{"level":2,"title":"5. 使用我们自己的CA创建CA签名证书","slug":"_5-使用我们自己的ca创建ca签名证书","link":"#_5-使用我们自己的ca创建ca签名证书","children":[{"level":3,"title":"5.1. 创建自签名根CA","slug":"_5-1-创建自签名根ca","link":"#_5-1-创建自签名根ca","children":[]},{"level":3,"title":"5.2. 使用根CA签名我们的CSR","slug":"_5-2-使用根ca签名我们的csr","link":"#_5-2-使用根ca签名我们的csr","children":[]},{"level":3,"title":"5.3. SAN扩展","slug":"_5-3-san扩展","link":"#_5-3-san扩展","children":[]}]},{"level":2,"title":"6. 查看证书","slug":"_6-查看证书","link":"#_6-查看证书","children":[]},{"level":2,"title":"7. 转换证书格式","slug":"_7-转换证书格式","link":"#_7-转换证书格式","children":[{"level":3,"title":"7.1. 将PEM转换为DER","slug":"_7-1-将pem转换为der","link":"#_7-1-将pem转换为der","children":[]},{"level":3,"title":"7.2. 将PEM转换为PKCS12","slug":"_7-2-将pem转换为pkcs12","link":"#_7-2-将pem转换为pkcs12","children":[]}]},{"level":2,"title":"8. 结论","slug":"_8-结论","link":"#_8-结论","children":[]}],"git":{"createdTime":1722110438000,"updatedTime":1722110438000,"contributors":[{"name":"Kahen","email":"Kahen@users.noreply.github.com","commits":1}]},"readingTime":{"minutes":5.68,"words":1704},"filePathRelative":"posts/baeldung/2024-07-27/2024-07-27-Creating a Self Signed Certificate With OpenSSL.md","localizedDate":"2022年4月1日","excerpt":"\\n<h2>1. 概述</h2>\\n<p>OpenSSL是一个开源的命令行工具，允许用户执行各种与SSL相关的任务。</p>\\n<p>在本教程中，我们将学习<strong>如何使用OpenSSL创建自签名证书</strong>。</p>\\n<h2>2. 创建私钥</h2>\\n<p>首先，我们将创建一个私钥。私钥有助于实现加密，是我们证书中最重要的组成部分。</p>\\n<p>让我们使用<code>openssl</code>命令创建一个带密码保护的、2048位的RSA私钥（<em>domain.key</em>）：</p>\\n<div class=\\"language-bash\\" data-ext=\\"sh\\" data-title=\\"sh\\"><pre class=\\"language-bash\\"><code>openssl genrsa <span class=\\"token parameter variable\\">-des3</span> <span class=\\"token parameter variable\\">-out</span> domain.key <span class=\\"token number\\">2048</span>\\n</code></pre></div>","autoDesc":true}');export{u as comp,m as data};
