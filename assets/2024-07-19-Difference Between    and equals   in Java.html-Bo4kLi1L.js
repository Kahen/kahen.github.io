import{_ as n}from"./plugin-vue_export-helper-DlAUqK2U.js";import{c as a,o as s,a as e}from"./app-C62MDKFf.js";const t={},p=e(`<h1 id="java-中的-equals-方法和-运算符的区别" tabindex="-1"><a class="header-anchor" href="#java-中的-equals-方法和-运算符的区别"><span>Java 中的 equals() 方法和 == 运算符的区别</span></a></h1><p>在本教程中，我们将描述 Java 中两种基本的等式检查——引用相等性和值相等性。我们将比较它们，展示示例，并强调它们之间的主要区别。</p><p>我们还将专注于空值检查，并理解为什么在处理对象时应使用引用相等性而不是值相等性。</p><h2 id="_1-引用相等性" tabindex="-1"><a class="header-anchor" href="#_1-引用相等性"><span>1. 引用相等性</span></a></h2><p>我们将从理解引用比较开始，这是由等式运算符（==）表示的。<strong>引用相等性发生在两个引用指向内存中的同一个对象时。</strong></p><h3 id="_1-1-原始类型与等式运算符" tabindex="-1"><a class="header-anchor" href="#_1-1-原始类型与等式运算符"><span>1.1 原始类型与等式运算符</span></a></h3><p>我们知道 Java 中的原始类型是简单的非类原始值。当我们使用等式运算符与原始类型时，我们只是在比较它们的值：</p><div class="language-java line-numbers-mode" data-ext="java" data-title="java"><pre class="language-java"><code><span class="token keyword">int</span> a <span class="token operator">=</span> <span class="token number">10</span><span class="token punctuation">;</span>
<span class="token keyword">int</span> b <span class="token operator">=</span> <span class="token number">15</span><span class="token punctuation">;</span>
<span class="token function">assertFalse</span><span class="token punctuation">(</span>a <span class="token operator">==</span> b<span class="token punctuation">)</span><span class="token punctuation">;</span>

<span class="token keyword">int</span> c <span class="token operator">=</span> <span class="token number">10</span><span class="token punctuation">;</span>
<span class="token function">assertTrue</span><span class="token punctuation">(</span>a <span class="token operator">==</span> c<span class="token punctuation">)</span><span class="token punctuation">;</span>

<span class="token keyword">int</span> d <span class="token operator">=</span> a<span class="token punctuation">;</span>
<span class="token function">assertTrue</span><span class="token punctuation">(</span>a <span class="token operator">==</span> d<span class="token punctuation">)</span><span class="token punctuation">;</span>
</code></pre><div class="line-numbers" aria-hidden="true"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><p>如上所示，<strong>对于原始类型，等式和引用检查的工作方式相同</strong>。当我们用相同的值初始化一个新的原始类型时，检查返回 true。此外，如果我们将原始值重新赋给新变量并进行比较，运算符返回相同的结果。</p><p>现在让我们执行空值检查：</p><div class="language-java line-numbers-mode" data-ext="java" data-title="java"><pre class="language-java"><code><span class="token keyword">int</span> e <span class="token operator">=</span> <span class="token keyword">null</span><span class="token punctuation">;</span> <span class="token comment">// 编译错误</span>
<span class="token function">assertFalse</span><span class="token punctuation">(</span>a <span class="token operator">==</span> <span class="token keyword">null</span><span class="token punctuation">)</span><span class="token punctuation">;</span> <span class="token comment">// 编译错误</span>
<span class="token function">assertFalse</span><span class="token punctuation">(</span><span class="token number">10</span> <span class="token operator">==</span> <span class="token keyword">null</span><span class="token punctuation">)</span><span class="token punctuation">;</span> <span class="token comment">// 编译错误</span>
</code></pre><div class="line-numbers" aria-hidden="true"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><p>Java 禁止将 null 分配给原始类型。通常，<strong>我们不能在原始变量或值上使用等式运算符进行任何空值检查</strong>。</p><h3 id="_1-2-对象类型与等式运算符" tabindex="-1"><a class="header-anchor" href="#_1-2-对象类型与等式运算符"><span>1.2 对象类型与等式运算符</span></a></h3><p>对于 Java 中的对象类型，<strong>等式运算符仅执行引用相等性比较，忽略对象值</strong>。在我们执行测试之前，让我们创建一个简单的自定义类：</p><div class="language-java line-numbers-mode" data-ext="java" data-title="java"><pre class="language-java"><code><span class="token keyword">public</span> <span class="token keyword">class</span> <span class="token class-name">Person</span> <span class="token punctuation">{</span>
    <span class="token keyword">private</span> <span class="token class-name">String</span> name<span class="token punctuation">;</span>
    <span class="token keyword">private</span> <span class="token keyword">int</span> age<span class="token punctuation">;</span>

    <span class="token comment">// 构造函数，getter，setter...</span>
<span class="token punctuation">}</span>
</code></pre><div class="line-numbers" aria-hidden="true"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><p>现在，让我们初始化一些类对象并检查等式运算符的结果：</p><div class="language-java line-numbers-mode" data-ext="java" data-title="java"><pre class="language-java"><code><span class="token class-name">Person</span> a <span class="token operator">=</span> <span class="token keyword">new</span> <span class="token class-name">Person</span><span class="token punctuation">(</span><span class="token string">&quot;Bob&quot;</span><span class="token punctuation">,</span> <span class="token number">20</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
<span class="token class-name">Person</span> b <span class="token operator">=</span> <span class="token keyword">new</span> <span class="token class-name">Person</span><span class="token punctuation">(</span><span class="token string">&quot;Mike&quot;</span><span class="token punctuation">,</span> <span class="token number">40</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
<span class="token function">assertFalse</span><span class="token punctuation">(</span>a <span class="token operator">==</span> b<span class="token punctuation">)</span><span class="token punctuation">;</span>

<span class="token class-name">Person</span> c <span class="token operator">=</span> <span class="token keyword">new</span> <span class="token class-name">Person</span><span class="token punctuation">(</span><span class="token string">&quot;Bob&quot;</span><span class="token punctuation">,</span> <span class="token number">20</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
<span class="token function">assertFalse</span><span class="token punctuation">(</span>a <span class="token operator">==</span> c<span class="token punctuation">)</span><span class="token punctuation">;</span>

<span class="token class-name">Person</span> d <span class="token operator">=</span> a<span class="token punctuation">;</span>
<span class="token function">assertTrue</span><span class="token punctuation">(</span>a <span class="token operator">==</span> d<span class="token punctuation">)</span><span class="token punctuation">;</span>
</code></pre><div class="line-numbers" aria-hidden="true"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><p>结果与之前大不相同。第二个检查返回 false，而我们之前对原始类型得到的是 true。正如我们前面提到的，等式运算符在比较时忽略了对象的内部值。它只<strong>检查两个变量是否引用相同的内存地址</strong>。</p><p>与原始类型不同，我们在使用对象时可以使用 null：</p><div class="language-java line-numbers-mode" data-ext="java" data-title="java"><pre class="language-java"><code><span class="token function">assertFalse</span><span class="token punctuation">(</span>a <span class="token operator">==</span> <span class="token keyword">null</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
<span class="token class-name">Person</span> e <span class="token operator">=</span> <span class="token keyword">null</span><span class="token punctuation">;</span>
<span class="token function">assertTrue</span><span class="token punctuation">(</span>e <span class="token operator">==</span> <span class="token keyword">null</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
</code></pre><div class="line-numbers" aria-hidden="true"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><p><strong>通过使用等式运算符并比较 null，我们检查分配给变量的对象是否已经初始化</strong>。</p><h2 id="_2-值相等性" tabindex="-1"><a class="header-anchor" href="#_2-值相等性"><span>2. 值相等性</span></a></h2><p>现在让我们关注值相等性测试。<strong>值相等性发生在两个独立的对象恰好具有相同的值或状态时</strong>。</p><p>这比较的是值，并且与对象的 equals() 方法密切相关。和之前一样，让我们比较它在原始类型和对象类型中的使用，看看主要的区别。</p><h3 id="_2-1-原始类型与-equals-方法" tabindex="-1"><a class="header-anchor" href="#_2-1-原始类型与-equals-方法"><span>2.1 原始类型与 equals() 方法</span></a></h3><p>正如我们知道的，原始类型是具有单个值的基本类型，并且不实现任何方法。因此，<strong>直接使用原始类型调用 equals() 方法是不可能的</strong>：</p><div class="language-java line-numbers-mode" data-ext="java" data-title="java"><pre class="language-java"><code><span class="token keyword">int</span> a <span class="token operator">=</span> <span class="token number">10</span><span class="token punctuation">;</span>
<span class="token function">assertTrue</span><span class="token punctuation">(</span>a<span class="token punctuation">.</span><span class="token function">equals</span><span class="token punctuation">(</span><span class="token number">10</span><span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">;</span> <span class="token comment">// 编译错误</span>
</code></pre><div class="line-numbers" aria-hidden="true"><div class="line-number"></div><div class="line-number"></div></div></div><p>然而，由于每个<strong>原始类型都有自己的包装类</strong>，我们可以使用<strong>装箱机制</strong>将其转换为其对象表示形式。然后，我们可以轻松地调用 equals() 方法，就好像我们在使用对象类型一样：</p><div class="language-java line-numbers-mode" data-ext="java" data-title="java"><pre class="language-java"><code><span class="token keyword">int</span> a <span class="token operator">=</span> <span class="token number">10</span><span class="token punctuation">;</span>
<span class="token class-name">Integer</span> b <span class="token operator">=</span> a<span class="token punctuation">;</span>

<span class="token function">assertTrue</span><span class="token punctuation">(</span>b<span class="token punctuation">.</span><span class="token function">equals</span><span class="token punctuation">(</span><span class="token number">10</span><span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
</code></pre><div class="line-numbers" aria-hidden="true"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><h3 id="_2-2-对象类型与-equals-方法" tabindex="-1"><a class="header-anchor" href="#_2-2-对象类型与-equals-方法"><span>2.2 对象类型与 equals() 方法</span></a></h3><p>让我们回到我们的 Person 类。为了使 equals() 方法正确工作，我们需要通过考虑类中包含的字段来重写自定义类中的方法：</p><div class="language-java line-numbers-mode" data-ext="java" data-title="java"><pre class="language-java"><code><span class="token keyword">public</span> <span class="token keyword">class</span> <span class="token class-name">Person</span> <span class="token punctuation">{</span>
    <span class="token comment">// 其他字段和方法省略</span>

    <span class="token annotation punctuation">@Override</span>
    <span class="token keyword">public</span> <span class="token keyword">boolean</span> <span class="token function">equals</span><span class="token punctuation">(</span><span class="token class-name">Object</span> o<span class="token punctuation">)</span> <span class="token punctuation">{</span>
        <span class="token keyword">if</span> <span class="token punctuation">(</span><span class="token keyword">this</span> <span class="token operator">==</span> o<span class="token punctuation">)</span>
            <span class="token keyword">return</span> <span class="token boolean">true</span><span class="token punctuation">;</span>
        <span class="token keyword">if</span> <span class="token punctuation">(</span>o <span class="token operator">==</span> <span class="token keyword">null</span> <span class="token operator">||</span> <span class="token function">getClass</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token operator">!=</span> o<span class="token punctuation">.</span><span class="token function">getClass</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">)</span>
            <span class="token keyword">return</span> <span class="token boolean">false</span><span class="token punctuation">;</span>
        <span class="token class-name">Person</span> person <span class="token operator">=</span> <span class="token punctuation">(</span><span class="token class-name">Person</span><span class="token punctuation">)</span> o<span class="token punctuation">;</span>
        <span class="token keyword">return</span> age <span class="token operator">==</span> person<span class="token punctuation">.</span>age <span class="token operator">&amp;&amp;</span> <span class="token class-name">Objects</span><span class="token punctuation">.</span><span class="token function">equals</span><span class="token punctuation">(</span>name<span class="token punctuation">,</span> person<span class="token punctuation">.</span>name<span class="token punctuation">)</span><span class="token punctuation">;</span>
    <span class="token punctuation">}</span>
<span class="token punctuation">}</span>
</code></pre><div class="line-numbers" aria-hidden="true"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><p>首先，equals() 方法返回 true 如果给定的值具有相同的引用，这是通过引用运算符检查的。如果不是，我们开始等式测试。</p><p>进一步，我们测试两个值的 Class 对象的等式。如果它们不同，我们返回 false。否则，我们继续检查等式。最后，我们返回分别比较每个属性的组合结果。</p><p>现在，让我们修改之前的测试并检查结果：</p><div class="language-java line-numbers-mode" data-ext="java" data-title="java"><pre class="language-java"><code><span class="token class-name">Person</span> a <span class="token operator">=</span> <span class="token keyword">new</span> <span class="token class-name">Person</span><span class="token punctuation">(</span><span class="token string">&quot;Bob&quot;</span><span class="token punctuation">,</span> <span class="token number">20</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
<span class="token class-name">Person</span> b <span class="token operator">=</span> <span class="token keyword">new</span> <span class="token class-name">Person</span><span class="token punctuation">(</span><span class="token string">&quot;Mike&quot;</span><span class="token punctuation">,</span> <span class="token number">40</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
<span class="token function">assertFalse</span><span class="token punctuation">(</span>a<span class="token punctuation">.</span><span class="token function">equals</span><span class="token punctuation">(</span>b<span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">;</span>

<span class="token class-name">Person</span> c <span class="token operator">=</span> <span class="token keyword">new</span> <span class="token class-name">Person</span><span class="token punctuation">(</span><span class="token string">&quot;Bob&quot;</span><span class="token punctuation">,</span> <span class="token number">20</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
<span class="token function">assertTrue</span><span class="token punctuation">(</span>a<span class="token punctuation">.</span><span class="token function">equals</span><span class="token punctuation">(</span>c<span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">;</span>

<span class="token class-name">Person</span> d <span class="token operator">=</span> a<span class="token punctuation">;</span>
<span class="token function">assertTrue</span><span class="token punctuation">(</span>a<span class="token punctuation">.</span><span class="token function">equals</span><span class="token punctuation">(</span>d<span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
</code></pre><div class="line-numbers" aria-hidden="true"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><p>正如我们所看到的，第二个检查返回 true，与引用等式不同。我们重写的 equals() 方法比较了对象的内部值。</p><p><strong>如果我们没有重写 equals() 方法，将使用父类 Object 的方法。由于 Object.equals() 方法只进行引用等式检查，当比较 Person 对象时，行为可能不是我们期望的。</strong></p><p>虽然我们上面没有展示 hashCode() 方法，但我们应该注意到，每当我们重写 equals() 方法时，重写它以确保这些方法之间的一致性是很重要的。</p><h2 id="_3-空值等式" tabindex="-1"><a class="header-anchor" href="#_3-空值等式"><span>3. 空值等式</span></a></h2><p>最后，让我们检查 equals() 方法如何处理 null 值：</p><div class="language-java line-numbers-mode" data-ext="java" data-title="java"><pre class="language-java"><code><span class="token class-name">Person</span> a <span class="token operator">=</span> <span class="token keyword">new</span> <span class="token class-name">Person</span><span class="token punctuation">(</span><span class="token string">&quot;Bob&quot;</span><span class="token punctuation">,</span> <span class="token number">20</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
<span class="token class-name">Person</span> e <span class="token operator">=</span> <span class="token keyword">null</span><span class="token punctuation">;</span>
<span class="token function">assertFalse</span><span class="token punctuation">(</span>a<span class="token punctuation">.</span><span class="token function">equals</span><span class="token punctuation">(</span>e<span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
<span class="token function">assertThrows</span><span class="token punctuation">(</span><span class="token class-name">NullPointerException</span><span class="token punctuation">.</span><span class="token keyword">class</span><span class="token punctuation">,</span> <span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token operator">-&gt;</span> e<span class="token punctuation">.</span><span class="token function">equals</span><span class="token punctuation">(</span>a<span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
</code></pre><div class="line-numbers" aria-hidden="true"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><p>当我们使用 equals() 方法对另一个对象进行检查时，根据这些变量的顺序，我们得到两种不同的结果。最后一个语句抛出异常，因为我们在 null 引用上调用了 equals() 方法。为了修复最后一个语句，我们应该首先调用等式运算符检查：</p><div class="language-java line-numbers-mode" data-ext="java" data-title="java"><pre class="language-java"><code><span class="token function">assertFalse</span><span class="token punctuation">(</span>e <span class="token operator">!=</span> <span class="token keyword">null</span> <span class="token operator">&amp;&amp;</span> e<span class="token punctuation">.</span><span class="token function">equals</span><span class="token punctuation">(</span>a<span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
</code></pre><div class="line-numbers" aria-hidden="true"><div class="line-number"></div></div></div><p>现在，条件的左侧返回 false，使整个语句等于 false，防止抛出 NullPointerException。因此，我们必须记住<strong>首先检查我们调用 equals() 方法的值是否为 null</strong>，否则，它可能导致烦人的错误。</p><p>此外，从 Java 7 开始，我们可以使用 null 安全的 Objects#equals() 静态方法来执行等式检查：</p><div class="language-java line-numbers-mode" data-ext="java" data-title="java"><pre class="language-java"><code><span class="token function">assertFalse</span><span class="token punctuation">(</span><span class="token class-name">Objects</span><span class="token punctuation">.</span><span class="token function">equals</span><span class="token punctuation">(</span>e<span class="token punctuation">,</span> a<span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
<span class="token function">assertTrue</span><span class="token punctuation">(</span><span class="token class-name">Objects</span><span class="token punctuation">.</span><span class="token function">equals</span><span class="token punctuation">(</span><span class="token keyword">null</span><span class="token punctuation">,</span> e<span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
</code></pre><div class="line-numbers" aria-hidden="true"><div class="line-number"></div><div class="line-number"></div></div></div><p>这个辅助方法执行额外的检查以防止抛出 NullPointerException，当两个参数都是 null 时返回 true。</p><h2 id="_4-结论" tabindex="-1"><a class="header-anchor" href="#_4-结论"><span>4. 结论</span></a></h2><p>在本文中，我们讨论了原始和对象值的引用等式和值等式检查。</p><p>要测试引用等式，我们使用 == 运算符。这个运算符对原始值和对象的工作方式略有不同。**当我们用原始值使用等式运算符时，它比较值。另一方面，当我们用它来比较对象时，它检查内存引用。**通过与 null 值进行比较，我们简单地检查对象是否在内存中初始化。</p><p><strong>在 Java 中执行值等式测试，我们使用从 Object 继承的 equals() 方法。原始类型是简单的非类值，因此没有包装就不能调用这个方法。</strong></p><p>我们还需要记住只在实例化的对象上调用 equals() 方法。否则，将抛出异常。为了防止这种情况，如果我们怀疑有 null 值，我们应该用 == 运算符检查该值。</p><p>如往常一样，示例的源代码可以在 GitHub 上找到。</p>`,54),o=[p];function l(c,u){return s(),a("div",null,o)}const k=n(t,[["render",l],["__file","2024-07-19-Difference Between    and equals   in Java.html.vue"]]),d=JSON.parse('{"path":"/posts/baeldung/2024-07-19/2024-07-19-Difference%20Between%20%20%20%20and%20equals%20%20%20in%20Java.html","title":"Java 中的 equals() 方法和 == 运算符的区别","lang":"zh-CN","frontmatter":{"date":"2022-04-01T00:00:00.000Z","category":["Java","equals() vs =="],"tag":["Java","equals()","=="],"head":[["meta",{"name":"keywords","content":"Java equals() 方法, Java == 运算符, 引用相等性, 值相等性"}],["meta",{"property":"og:url","content":"https://www.kahen.xyz/posts/baeldung/2024-07-19/2024-07-19-Difference%20Between%20%20%20%20and%20equals%20%20%20in%20Java.html"}],["meta",{"property":"og:site_name","content":"Baeldung 中文网"}],["meta",{"property":"og:title","content":"Java 中的 equals() 方法和 == 运算符的区别"}],["meta",{"property":"og:description","content":"Java 中的 equals() 方法和 == 运算符的区别 在本教程中，我们将描述 Java 中两种基本的等式检查——引用相等性和值相等性。我们将比较它们，展示示例，并强调它们之间的主要区别。 我们还将专注于空值检查，并理解为什么在处理对象时应使用引用相等性而不是值相等性。 1. 引用相等性 我们将从理解引用比较开始，这是由等式运算符（==）表示的。..."}],["meta",{"property":"og:type","content":"article"}],["meta",{"property":"og:locale","content":"zh-CN"}],["meta",{"property":"og:updated_time","content":"2024-07-19T05:33:58.000Z"}],["meta",{"property":"article:author","content":"Kahen"}],["meta",{"property":"article:tag","content":"Java"}],["meta",{"property":"article:tag","content":"equals()"}],["meta",{"property":"article:tag","content":"=="}],["meta",{"property":"article:published_time","content":"2022-04-01T00:00:00.000Z"}],["meta",{"property":"article:modified_time","content":"2024-07-19T05:33:58.000Z"}],["script",{"type":"application/ld+json"},"{\\"@context\\":\\"https://schema.org\\",\\"@type\\":\\"Article\\",\\"headline\\":\\"Java 中的 equals() 方法和 == 运算符的区别\\",\\"image\\":[\\"\\"],\\"datePublished\\":\\"2022-04-01T00:00:00.000Z\\",\\"dateModified\\":\\"2024-07-19T05:33:58.000Z\\",\\"author\\":[{\\"@type\\":\\"Person\\",\\"name\\":\\"Kahen\\",\\"url\\":\\"https://www.kahen.xyz\\"}]}"]],"description":"Java 中的 equals() 方法和 == 运算符的区别 在本教程中，我们将描述 Java 中两种基本的等式检查——引用相等性和值相等性。我们将比较它们，展示示例，并强调它们之间的主要区别。 我们还将专注于空值检查，并理解为什么在处理对象时应使用引用相等性而不是值相等性。 1. 引用相等性 我们将从理解引用比较开始，这是由等式运算符（==）表示的。..."},"headers":[{"level":2,"title":"1. 引用相等性","slug":"_1-引用相等性","link":"#_1-引用相等性","children":[{"level":3,"title":"1.1 原始类型与等式运算符","slug":"_1-1-原始类型与等式运算符","link":"#_1-1-原始类型与等式运算符","children":[]},{"level":3,"title":"1.2 对象类型与等式运算符","slug":"_1-2-对象类型与等式运算符","link":"#_1-2-对象类型与等式运算符","children":[]}]},{"level":2,"title":"2. 值相等性","slug":"_2-值相等性","link":"#_2-值相等性","children":[{"level":3,"title":"2.1 原始类型与 equals() 方法","slug":"_2-1-原始类型与-equals-方法","link":"#_2-1-原始类型与-equals-方法","children":[]},{"level":3,"title":"2.2 对象类型与 equals() 方法","slug":"_2-2-对象类型与-equals-方法","link":"#_2-2-对象类型与-equals-方法","children":[]}]},{"level":2,"title":"3. 空值等式","slug":"_3-空值等式","link":"#_3-空值等式","children":[]},{"level":2,"title":"4. 结论","slug":"_4-结论","link":"#_4-结论","children":[]}],"git":{"createdTime":1721367238000,"updatedTime":1721367238000,"contributors":[{"name":"Kahen","email":"Kahen@users.noreply.github.com","commits":1}]},"readingTime":{"minutes":6.19,"words":1858},"filePathRelative":"posts/baeldung/2024-07-19/2024-07-19-Difference Between    and equals   in Java.md","localizedDate":"2022年4月1日","excerpt":"\\n<p>在本教程中，我们将描述 Java 中两种基本的等式检查——引用相等性和值相等性。我们将比较它们，展示示例，并强调它们之间的主要区别。</p>\\n<p>我们还将专注于空值检查，并理解为什么在处理对象时应使用引用相等性而不是值相等性。</p>\\n<h2>1. 引用相等性</h2>\\n<p>我们将从理解引用比较开始，这是由等式运算符（==）表示的。<strong>引用相等性发生在两个引用指向内存中的同一个对象时。</strong></p>\\n<h3>1.1 原始类型与等式运算符</h3>\\n<p>我们知道 Java 中的原始类型是简单的非类原始值。当我们使用等式运算符与原始类型时，我们只是在比较它们的值：</p>","autoDesc":true}');export{k as comp,d as data};
