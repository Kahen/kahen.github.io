import{_ as a}from"./plugin-vue_export-helper-DlAUqK2U.js";import{c as s,o as n,a as e}from"./app-BTwZI-W8.js";const t={},p=e(`<h1 id="jvm实例使用的gc算法查找方法" tabindex="-1"><a class="header-anchor" href="#jvm实例使用的gc算法查找方法"><span>JVM实例使用的GC算法查找方法</span></a></h1><p>Java应用程序以其启动缓慢和预热时间长而闻名。OpenJDK的CRaC（协调恢复检查点）项目可以通过<strong>创建应用程序峰值性能的检查点</strong>并恢复JVM实例到该点来帮助改善这些问题。</p><p>为了充分利用这一特性，BellSoft提供了高度优化的Java应用程序容器。这些容器打包了Alpaquita Linux（一个为Java和云环境优化的全功能操作系统）和Liberica JDK（基于OpenJDK的开源Java运行时）。</p><p>这些现成的镜像使我们能够轻松地在Spring Boot应用程序中<strong>集成CRaC</strong>：</p><p><strong>通过CRaC支持提高Java应用程序性能</strong></p><h2 id="_1-概述" tabindex="-1"><a class="header-anchor" href="#_1-概述"><span>1. 概述</span></a></h2><p>除了编译器和运行时等典型开发工具外，每个JDK版本都附带了众多其他工具。其中一些工具可以帮助我们获得有关运行中应用程序的宝贵见解。</p><p>在本文中，我们将看到如何使用这些工具来更多地了解特定JVM实例使用的GC算法。</p><h2 id="_2-示例应用程序" tabindex="-1"><a class="header-anchor" href="#_2-示例应用程序"><span>2. 示例应用程序</span></a></h2><p>在本文中，我们将使用一个非常简单的应用程序：</p><div class="language-java line-numbers-mode" data-ext="java" data-title="java"><pre class="language-java"><code><span class="token keyword">public</span> <span class="token keyword">class</span> <span class="token class-name">App</span> <span class="token punctuation">{</span>
    <span class="token keyword">public</span> <span class="token keyword">static</span> <span class="token keyword">void</span> <span class="token function">main</span><span class="token punctuation">(</span><span class="token class-name">String</span><span class="token punctuation">[</span><span class="token punctuation">]</span> args<span class="token punctuation">)</span> <span class="token keyword">throws</span> <span class="token class-name">IOException</span> <span class="token punctuation">{</span>
        <span class="token class-name">System</span><span class="token punctuation">.</span>out<span class="token punctuation">.</span><span class="token function">println</span><span class="token punctuation">(</span><span class="token string">&quot;Waiting for stdin&quot;</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
        <span class="token keyword">int</span> read <span class="token operator">=</span> <span class="token class-name">System</span><span class="token punctuation">.</span>in<span class="token punctuation">.</span><span class="token function">read</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
        <span class="token class-name">System</span><span class="token punctuation">.</span>out<span class="token punctuation">.</span><span class="token function">println</span><span class="token punctuation">(</span><span class="token string">&quot;I&#39;m done: &quot;</span> <span class="token operator">+</span> read<span class="token punctuation">)</span><span class="token punctuation">;</span>
    <span class="token punctuation">}</span>
<span class="token punctuation">}</span>
</code></pre><div class="line-numbers" aria-hidden="true"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><p>显然，这个应用程序等待并持续运行，直到它从标准输入接收到某些内容。这种挂起帮助我们模拟长时间运行的JVM应用程序的行为。</p><p>为了使用这个应用程序，我们必须使用<code>javac</code>编译<code>App.java</code>文件，然后使用<code>java</code>工具运行它。</p><h2 id="_3-查找jvm进程" tabindex="-1"><a class="header-anchor" href="#_3-查找jvm进程"><span>3. 查找JVM进程</span></a></h2><p>**要查找JVM进程使用的GC，首先，我们应该确定该特定JVM实例的进程ID。**假设我们使用以下命令运行了我们的应用程序：</p><div class="language-bash line-numbers-mode" data-ext="sh" data-title="sh"><pre class="language-bash"><code><span class="token operator">&gt;&gt;</span> <span class="token function">java</span> App
Waiting <span class="token keyword">for</span> stdin
</code></pre><div class="line-numbers" aria-hidden="true"><div class="line-number"></div><div class="line-number"></div></div></div><p>如果我们安装了JDK，找到JVM实例进程ID的最佳方式是使用<code>jps</code>工具。例如：</p><div class="language-bash line-numbers-mode" data-ext="sh" data-title="sh"><pre class="language-bash"><code><span class="token operator">&gt;&gt;</span> jps <span class="token parameter variable">-l</span>
<span class="token number">69569</span>
<span class="token number">48347</span> App
<span class="token number">48351</span> jdk.jcmd/sun.tools.jps.Jps
</code></pre><div class="line-numbers" aria-hidden="true"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><p>如上所示，系统上运行着三个JVM实例。显然，第二个JVM实例的描述（&quot;App&quot;）与我们的应用程序名称匹配。因此，我们要找的进程ID是48347。</p><p>除了<code>jps</code>，我们也可以使用其他通用实用程序来过滤运行中的进程。例如，来自procps包的著名<code>ps</code>工具也可以工作：</p><div class="language-bash line-numbers-mode" data-ext="sh" data-title="sh"><pre class="language-bash"><code><span class="token operator">&gt;&gt;</span> <span class="token function">ps</span> <span class="token parameter variable">-ef</span> <span class="token operator">|</span> <span class="token function">grep</span> <span class="token function">java</span>
<span class="token number">502</span> <span class="token number">48347</span> <span class="token number">36213</span>   <span class="token number">0</span>  <span class="token number">1</span>:28AM ttys037    <span class="token number">0</span>:00.28 <span class="token function">java</span> App
</code></pre><div class="line-numbers" aria-hidden="true"><div class="line-number"></div><div class="line-number"></div></div></div><p>然而，<code>jps</code>更易于使用，需要的过滤更少。</p><p>现在我们知道了如何找到进程ID，让我们找到已经运行的JVM应用程序使用的GC算法。</p><h3 id="_4-1-java-8及更早版本" tabindex="-1"><a class="header-anchor" href="#_4-1-java-8及更早版本"><span>4.1. Java 8及更早版本</span></a></h3><p><strong>如果我们使用的是Java 8，我们可以使用<code>jmap</code>工具来打印堆摘要、堆直方图，甚至生成堆转储</strong>。为了找到GC算法，我们可以使用<code>-heap</code>选项如下：</p><div class="language-bash line-numbers-mode" data-ext="sh" data-title="sh"><pre class="language-bash"><code><span class="token operator">&gt;&gt;</span> jmap <span class="token parameter variable">-heap</span> \`\`<span class="token variable"><span class="token variable">\`</span><span class="token operator">&lt;</span>pid<span class="token operator">&gt;</span><span class="token variable">\`</span></span>\`\`
</code></pre><div class="line-numbers" aria-hidden="true"><div class="line-number"></div></div></div><p>所以在我们的特定案例中，我们使用的是CMS GC：</p><div class="language-bash line-numbers-mode" data-ext="sh" data-title="sh"><pre class="language-bash"><code><span class="token operator">&gt;&gt;</span> jmap <span class="token parameter variable">-heap</span> <span class="token number">48347</span> <span class="token operator">|</span> <span class="token function">grep</span> GC
Concurrent Mark-Sweep GC
</code></pre><div class="line-numbers" aria-hidden="true"><div class="line-number"></div><div class="line-number"></div></div></div><p>对于其他GC算法，输出几乎相同：</p><div class="language-bash line-numbers-mode" data-ext="sh" data-title="sh"><pre class="language-bash"><code><span class="token operator">&gt;&gt;</span> jmap <span class="token parameter variable">-heap</span> <span class="token number">48347</span> <span class="token operator">|</span> <span class="token function">grep</span> GC
Parallel GC with <span class="token number">8</span> thread<span class="token punctuation">(</span>s<span class="token punctuation">)</span>
</code></pre><div class="line-numbers" aria-hidden="true"><div class="line-number"></div><div class="line-number"></div></div></div><h3 id="_4-2-java-9-jhsdb-jmap" tabindex="-1"><a class="header-anchor" href="#_4-2-java-9-jhsdb-jmap"><span>4.2. Java 9+: <code>jhsdb jmap</code></span></a></h3><p>**从Java 9开始，我们可以使用<code>jhsdb jmap</code>组合来打印有关JVM堆的一些信息。**更具体地说，这个特定命令将等同于前一个命令：</p><div class="language-bash line-numbers-mode" data-ext="sh" data-title="sh"><pre class="language-bash"><code><span class="token operator">&gt;&gt;</span> jhsdb jmap <span class="token parameter variable">--heap</span> <span class="token parameter variable">--pid</span> \`\`<span class="token variable"><span class="token variable">\`</span><span class="token operator">&lt;</span>pid<span class="token operator">&gt;</span><span class="token variable">\`</span></span>\`\`
</code></pre><div class="line-numbers" aria-hidden="true"><div class="line-number"></div></div></div><p>例如，现在我们的应用程序运行的是G1GC：</p><div class="language-bash line-numbers-mode" data-ext="sh" data-title="sh"><pre class="language-bash"><code><span class="token operator">&gt;&gt;</span> jhsdb jmap <span class="token parameter variable">--heap</span> <span class="token parameter variable">--pid</span> <span class="token number">48347</span> <span class="token operator">|</span> <span class="token function">grep</span> GC
Garbage-First <span class="token punctuation">(</span>G1<span class="token punctuation">)</span> GC with <span class="token number">8</span> thread<span class="token punctuation">(</span>s<span class="token punctuation">)</span>
</code></pre><div class="line-numbers" aria-hidden="true"><div class="line-number"></div><div class="line-number"></div></div></div><h3 id="_4-3-java-9-jcmd" tabindex="-1"><a class="header-anchor" href="#_4-3-java-9-jcmd"><span>4.3. Java 9+: <code>jcmd</code></span></a></h3><p>在现代JVM中，<code>jcmd</code>命令非常多功能。例如，<strong>我们可以使用它来获取有关堆的一些通用信息</strong>：</p><div class="language-bash line-numbers-mode" data-ext="sh" data-title="sh"><pre class="language-bash"><code><span class="token operator">&gt;&gt;</span> jcmd \`\`<span class="token variable"><span class="token variable">\`</span><span class="token operator">&lt;</span>pid<span class="token operator">&gt;</span><span class="token variable">\`</span></span>\`\` VM.info
</code></pre><div class="line-numbers" aria-hidden="true"><div class="line-number"></div></div></div><p>所以如果我们传递应用程序的进程ID，我们可以看到这个JVM实例正在使用Serial GC：</p><div class="language-bash line-numbers-mode" data-ext="sh" data-title="sh"><pre class="language-bash"><code><span class="token operator">&gt;&gt;</span> jcmd <span class="token number">48347</span> VM.info <span class="token operator">|</span> <span class="token function">grep</span> gc
<span class="token comment"># Java VM: OpenJDK 64-Bit Server VM (15+36-1562, mixed mode, sharing, tiered, compressed oops, serial gc, bsd-amd64)</span>
// omitted
</code></pre><div class="line-numbers" aria-hidden="true"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><p>对于G1或ZGC，输出类似：</p><div class="language-bash line-numbers-mode" data-ext="sh" data-title="sh"><pre class="language-bash"><code>// ZGC
<span class="token comment"># Java VM: OpenJDK 64-Bit Server VM (15+36-1562, mixed mode, sharing, tiered, z gc, bsd-amd64)</span>
// G1GC
<span class="token comment"># Java VM: OpenJDK 64-Bit Server VM (15+36-1562, mixed mode, sharing, tiered, compressed oops, g1 gc, bsd-amd64)</span>
</code></pre><div class="line-numbers" aria-hidden="true"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><p>通过一点<code>grep</code>技巧，我们也可以去除所有这些噪音，只获取GC名称：</p><div class="language-bash line-numbers-mode" data-ext="sh" data-title="sh"><pre class="language-bash"><code><span class="token operator">&gt;&gt;</span> jcmd <span class="token number">48347</span> VM.info <span class="token operator">|</span> <span class="token function">grep</span> <span class="token parameter variable">-ohE</span> <span class="token string">&quot;[^\\s^,]+<span class="token entity" title="\\\\">\\\\</span>sgc&quot;</span>
g1 gc
</code></pre><div class="line-numbers" aria-hidden="true"><div class="line-number"></div><div class="line-number"></div></div></div><h3 id="_4-4-命令行参数" tabindex="-1"><a class="header-anchor" href="#_4-4-命令行参数"><span>4.4. 命令行参数</span></a></h3><p>有时，我们（或别人）在启动JVM应用程序时明确指定GC算法。例如，我们在这里选择使用ZGC：</p><div class="language-bash line-numbers-mode" data-ext="sh" data-title="sh"><pre class="language-bash"><code><span class="token operator">&gt;&gt;</span> <span class="token function">java</span> <span class="token parameter variable">-XX:+UseZGC</span> App
</code></pre><div class="line-numbers" aria-hidden="true"><div class="line-number"></div></div></div><p>在这种情况下，有更简单的方法来找到使用的GC。基本上，<strong>我们所要做的就是找到应用程序执行的命令</strong>。</p><p>例如，在基于UNIX的平台上，我们可以再次使用<code>ps</code>命令：</p><div class="language-bash line-numbers-mode" data-ext="sh" data-title="sh"><pre class="language-bash"><code><span class="token operator">&gt;&gt;</span> <span class="token function">ps</span> <span class="token parameter variable">-p</span> <span class="token number">48347</span> <span class="token parameter variable">-o</span> <span class="token assign-left variable">command</span><span class="token operator">=</span>
<span class="token function">java</span> <span class="token parameter variable">-XX:+UseZGC</span> App
</code></pre><div class="line-numbers" aria-hidden="true"><div class="line-number"></div><div class="line-number"></div></div></div><p>从上述输出中，很明显JVM正在使用ZGC。同样，<strong><code>jcmd</code>命令也可以打印命令行参数</strong>：</p><div class="language-bash line-numbers-mode" data-ext="sh" data-title="sh"><pre class="language-bash"><code><span class="token operator">&gt;&gt;</span> jcmd <span class="token number">48347</span> VM.flags
<span class="token number">84020</span>:
<span class="token parameter variable">-XX:CICompilerCount</span><span class="token operator">=</span><span class="token number">4</span> <span class="token parameter variable">-XX:-UseCompressedOops</span> <span class="token parameter variable">-XX:-UseNUMA</span> <span class="token parameter variable">-XX:-UseNUMAInterleaving</span> <span class="token parameter variable">-XX:+UseZGC</span> // omitted
</code></pre><div class="line-numbers" aria-hidden="true"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><p><strong>令人惊讶的是，如上所示，这个命令将打印隐式和显式的参数和可调项</strong>。所以即使我们没有明确指定GC算法，它也会显示所选的和默认的：</p><div class="language-bash line-numbers-mode" data-ext="sh" data-title="sh"><pre class="language-bash"><code><span class="token operator">&gt;&gt;</span> jcmd <span class="token number">48347</span> VM.flags <span class="token operator">|</span> <span class="token function">grep</span> <span class="token parameter variable">-ohE</span> <span class="token string">&#39;\\S*GC\\s&#39;</span>
<span class="token parameter variable">-XX:+UseG1GC</span>
</code></pre><div class="line-numbers" aria-hidden="true"><div class="line-number"></div><div class="line-number"></div></div></div><p>甚至更令人惊讶的是，这也适用于Java 8：</p><div class="language-bash line-numbers-mode" data-ext="sh" data-title="sh"><pre class="language-bash"><code><span class="token operator">&gt;&gt;</span> jcmd <span class="token number">48347</span> VM.flags <span class="token operator">|</span> <span class="token function">grep</span> <span class="token parameter variable">-ohE</span> <span class="token string">&#39;\\S*GC\\s&#39;</span>
<span class="token parameter variable">-XX:+UseParallelGC</span>
</code></pre><div class="line-numbers" aria-hidden="true"><div class="line-number"></div><div class="line-number"></div></div></div><h2 id="_5-结论" tabindex="-1"><a class="header-anchor" href="#_5-结论"><span>5. 结论</span></a></h2><p>在本文中，我们看到了不同的方式来查找特定JVM实例使用的GC算法。一些提到的方法与特定Java版本相关，一些是可移植的。</p><p>此外，我们还看到了几种查找进程ID的方法，这总是必需的。</p>`,59),l=[p];function i(o,r){return n(),s("div",null,l)}const u=a(t,[["render",i],["__file","2024-07-28-Find the GC Algorithm Used by a JVM Instance.html.vue"]]),v=JSON.parse('{"path":"/posts/baeldung/2024-07-28/2024-07-28-Find%20the%20GC%20Algorithm%20Used%20by%20a%20JVM%20Instance.html","title":"JVM实例使用的GC算法查找方法","lang":"zh-CN","frontmatter":{"date":"2022-04-01T00:00:00.000Z","category":["Java","JVM"],"tag":["GC算法","JVM实例"],"head":[["meta",{"name":"keywords","content":"JVM, GC算法, Java性能, CRaC项目"}],["meta",{"property":"og:url","content":"https://www.kahen.xyz/posts/baeldung/2024-07-28/2024-07-28-Find%20the%20GC%20Algorithm%20Used%20by%20a%20JVM%20Instance.html"}],["meta",{"property":"og:site_name","content":"Baeldung 中文网"}],["meta",{"property":"og:title","content":"JVM实例使用的GC算法查找方法"}],["meta",{"property":"og:description","content":"JVM实例使用的GC算法查找方法 Java应用程序以其启动缓慢和预热时间长而闻名。OpenJDK的CRaC（协调恢复检查点）项目可以通过创建应用程序峰值性能的检查点并恢复JVM实例到该点来帮助改善这些问题。 为了充分利用这一特性，BellSoft提供了高度优化的Java应用程序容器。这些容器打包了Alpaquita Linux（一个为Java和云环境优..."}],["meta",{"property":"og:type","content":"article"}],["meta",{"property":"og:locale","content":"zh-CN"}],["meta",{"property":"og:updated_time","content":"2024-07-28T02:34:35.000Z"}],["meta",{"property":"article:author","content":"Kahen"}],["meta",{"property":"article:tag","content":"GC算法"}],["meta",{"property":"article:tag","content":"JVM实例"}],["meta",{"property":"article:published_time","content":"2022-04-01T00:00:00.000Z"}],["meta",{"property":"article:modified_time","content":"2024-07-28T02:34:35.000Z"}],["script",{"type":"application/ld+json"},"{\\"@context\\":\\"https://schema.org\\",\\"@type\\":\\"Article\\",\\"headline\\":\\"JVM实例使用的GC算法查找方法\\",\\"image\\":[\\"\\"],\\"datePublished\\":\\"2022-04-01T00:00:00.000Z\\",\\"dateModified\\":\\"2024-07-28T02:34:35.000Z\\",\\"author\\":[{\\"@type\\":\\"Person\\",\\"name\\":\\"Kahen\\",\\"url\\":\\"https://www.kahen.xyz\\"}]}"]],"description":"JVM实例使用的GC算法查找方法 Java应用程序以其启动缓慢和预热时间长而闻名。OpenJDK的CRaC（协调恢复检查点）项目可以通过创建应用程序峰值性能的检查点并恢复JVM实例到该点来帮助改善这些问题。 为了充分利用这一特性，BellSoft提供了高度优化的Java应用程序容器。这些容器打包了Alpaquita Linux（一个为Java和云环境优..."},"headers":[{"level":2,"title":"1. 概述","slug":"_1-概述","link":"#_1-概述","children":[]},{"level":2,"title":"2. 示例应用程序","slug":"_2-示例应用程序","link":"#_2-示例应用程序","children":[]},{"level":2,"title":"3. 查找JVM进程","slug":"_3-查找jvm进程","link":"#_3-查找jvm进程","children":[{"level":3,"title":"4.1. Java 8及更早版本","slug":"_4-1-java-8及更早版本","link":"#_4-1-java-8及更早版本","children":[]},{"level":3,"title":"4.2. Java 9+: jhsdb jmap","slug":"_4-2-java-9-jhsdb-jmap","link":"#_4-2-java-9-jhsdb-jmap","children":[]},{"level":3,"title":"4.3. Java 9+: jcmd","slug":"_4-3-java-9-jcmd","link":"#_4-3-java-9-jcmd","children":[]},{"level":3,"title":"4.4. 命令行参数","slug":"_4-4-命令行参数","link":"#_4-4-命令行参数","children":[]}]},{"level":2,"title":"5. 结论","slug":"_5-结论","link":"#_5-结论","children":[]}],"git":{"createdTime":1722134075000,"updatedTime":1722134075000,"contributors":[{"name":"Kahen","email":"Kahen@users.noreply.github.com","commits":1}]},"readingTime":{"minutes":4.83,"words":1448},"filePathRelative":"posts/baeldung/2024-07-28/2024-07-28-Find the GC Algorithm Used by a JVM Instance.md","localizedDate":"2022年4月1日","excerpt":"\\n<p>Java应用程序以其启动缓慢和预热时间长而闻名。OpenJDK的CRaC（协调恢复检查点）项目可以通过<strong>创建应用程序峰值性能的检查点</strong>并恢复JVM实例到该点来帮助改善这些问题。</p>\\n<p>为了充分利用这一特性，BellSoft提供了高度优化的Java应用程序容器。这些容器打包了Alpaquita Linux（一个为Java和云环境优化的全功能操作系统）和Liberica JDK（基于OpenJDK的开源Java运行时）。</p>\\n<p>这些现成的镜像使我们能够轻松地在Spring Boot应用程序中<strong>集成CRaC</strong>：</p>","autoDesc":true}');export{u as comp,v as data};
