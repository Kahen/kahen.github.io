import{_ as n}from"./plugin-vue_export-helper-DlAUqK2U.js";import{c as a,o as s,a as t}from"./app-BaCIpe-N.js";const e={},p=t(`<h1 id="java接口中的默认方法与抽象类对比" tabindex="-1"><a class="header-anchor" href="#java接口中的默认方法与抽象类对比"><span>Java接口中的默认方法与抽象类对比</span></a></h1><p>在Java接口引入了默认方法之后，似乎接口和抽象类之间不再有任何区别。但事实并非如此——它们之间存在一些根本性的差异。</p><p>在本教程中，我们将深入探讨接口和抽象类，看看它们是如何不同的。</p><h3 id="为什么使用默认方法" tabindex="-1"><a class="header-anchor" href="#为什么使用默认方法"><span>为什么使用默认方法？</span></a></h3><p>默认方法的<strong>目的是在不破坏现有实现的情况下提供外部功能</strong>。引入默认方法最初的动机是为集合框架提供与新lambda函数向后兼容的功能。</p><p>让我们看看主要的基本差异。</p><h3 id="_3-1-状态" tabindex="-1"><a class="header-anchor" href="#_3-1-状态"><span>3.1. 状态</span></a></h3><p>抽象类可以有状态，其方法可以访问实现的状态。尽管接口中允许使用默认方法，但它们不能访问实现的状态。</p><p>我们在默认方法中编写的任何<strong>逻辑应该与接口的其他方法相关——这些方法将独立于对象的状态</strong>。</p><p>假设我们创建了一个抽象类_CircleClass_，它包含一个_String_类型的_color_，用来表示_CircleClass_对象的状态：</p><div class="language-java line-numbers-mode" data-ext="java" data-title="java"><pre class="language-java"><code><span class="token keyword">public</span> <span class="token keyword">abstract</span> <span class="token keyword">class</span> <span class="token class-name">CircleClass</span> <span class="token punctuation">{</span>
    <span class="token keyword">private</span> <span class="token class-name">String</span> color<span class="token punctuation">;</span>
    <span class="token keyword">private</span> <span class="token class-name">List</span>\`\`<span class="token generics"><span class="token punctuation">&lt;</span><span class="token class-name">String</span><span class="token punctuation">&gt;</span></span>\`\` allowedColors <span class="token operator">=</span> <span class="token class-name">Arrays</span><span class="token punctuation">.</span><span class="token function">asList</span><span class="token punctuation">(</span><span class="token string">&quot;RED&quot;</span><span class="token punctuation">,</span> <span class="token string">&quot;GREEN&quot;</span><span class="token punctuation">,</span> <span class="token string">&quot;BLUE&quot;</span><span class="token punctuation">)</span><span class="token punctuation">;</span>

    <span class="token keyword">public</span> <span class="token keyword">boolean</span> <span class="token function">isValid</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>
        <span class="token keyword">if</span> <span class="token punctuation">(</span>allowedColors<span class="token punctuation">.</span><span class="token function">contains</span><span class="token punctuation">(</span><span class="token function">getColor</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>
            <span class="token keyword">return</span> <span class="token boolean">true</span><span class="token punctuation">;</span>
        <span class="token punctuation">}</span> <span class="token keyword">else</span> <span class="token punctuation">{</span>
            <span class="token keyword">return</span> <span class="token boolean">false</span><span class="token punctuation">;</span>
        <span class="token punctuation">}</span>
    <span class="token punctuation">}</span>

    <span class="token comment">// 标准的getter和setter</span>
<span class="token punctuation">}</span>
</code></pre><div class="line-numbers" aria-hidden="true"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><p>在上述抽象类中，我们有一个非抽象方法_isValid()_，根据其状态验证_CircleClass_对象。_isValid()_方法可以访问_CircleClass_对象的状态，并根据允许的颜色验证_CircleClass_的实例。由于这种行为，我们可以在抽象类方法中编写任何基于对象状态的逻辑。</p><p>让我们创建一个_CircleClass_的简单实现类：</p><div class="language-java line-numbers-mode" data-ext="java" data-title="java"><pre class="language-java"><code><span class="token keyword">public</span> <span class="token keyword">class</span> <span class="token class-name">ChildCircleClass</span> <span class="token keyword">extends</span> <span class="token class-name">CircleClass</span> <span class="token punctuation">{</span>
<span class="token punctuation">}</span>
</code></pre><div class="line-numbers" aria-hidden="true"><div class="line-number"></div><div class="line-number"></div></div></div><p>现在，让我们创建一个实例并验证颜色：</p><div class="language-java line-numbers-mode" data-ext="java" data-title="java"><pre class="language-java"><code><span class="token class-name">CircleClass</span> redCircle <span class="token operator">=</span> <span class="token keyword">new</span> <span class="token class-name">ChildCircleClass</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
redCircle<span class="token punctuation">.</span><span class="token function">setColor</span><span class="token punctuation">(</span><span class="token string">&quot;RED&quot;</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
<span class="token function">assertTrue</span><span class="token punctuation">(</span>redCircle<span class="token punctuation">.</span><span class="token function">isValid</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
</code></pre><div class="line-numbers" aria-hidden="true"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><p>在这里，我们可以看到，当我们在_CircleClass_对象中放入一个有效颜色并调用_isValid()_方法时，内部的_isValid()_方法可以访问_CircleClass_对象的状态，并检查实例是否包含有效颜色。</p><p>让我们尝试使用带有默认方法的接口来做类似的事情：</p><div class="language-java line-numbers-mode" data-ext="java" data-title="java"><pre class="language-java"><code><span class="token keyword">public</span> <span class="token keyword">interface</span> <span class="token class-name">CircleInterface</span> <span class="token punctuation">{</span>
    <span class="token class-name">List</span>\`\`<span class="token generics"><span class="token punctuation">&lt;</span><span class="token class-name">String</span><span class="token punctuation">&gt;</span></span>\`\` allowedColors <span class="token operator">=</span> <span class="token class-name">Arrays</span><span class="token punctuation">.</span><span class="token function">asList</span><span class="token punctuation">(</span><span class="token string">&quot;RED&quot;</span><span class="token punctuation">,</span> <span class="token string">&quot;GREEN&quot;</span><span class="token punctuation">,</span> <span class="token string">&quot;BLUE&quot;</span><span class="token punctuation">)</span><span class="token punctuation">;</span>

    <span class="token class-name">String</span> <span class="token function">getColor</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>

    <span class="token keyword">public</span> <span class="token keyword">default</span> <span class="token keyword">boolean</span> <span class="token function">isValid</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>
        <span class="token keyword">if</span> <span class="token punctuation">(</span>allowedColors<span class="token punctuation">.</span><span class="token function">contains</span><span class="token punctuation">(</span><span class="token function">getColor</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>
            <span class="token keyword">return</span> <span class="token boolean">true</span><span class="token punctuation">;</span>
        <span class="token punctuation">}</span> <span class="token keyword">else</span> <span class="token punctuation">{</span>
            <span class="token keyword">return</span> <span class="token boolean">false</span><span class="token punctuation">;</span>
        <span class="token punctuation">}</span>
    <span class="token punctuation">}</span>
<span class="token punctuation">}</span>
</code></pre><div class="line-numbers" aria-hidden="true"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><p>我们知道，接口不能有状态，因此默认方法不能访问状态。</p><p>在这里，我们定义了_getColor()_方法来提供状态信息。子类将重写_getColor()_方法，以在运行时提供实例的状态：</p><div class="language-java line-numbers-mode" data-ext="java" data-title="java"><pre class="language-java"><code><span class="token keyword">public</span> <span class="token keyword">class</span> <span class="token class-name">ChidlCircleInterfaceImpl</span> <span class="token keyword">implements</span> <span class="token class-name">CircleInterface</span> <span class="token punctuation">{</span>
    <span class="token keyword">private</span> <span class="token class-name">String</span> color<span class="token punctuation">;</span>

    <span class="token annotation punctuation">@Override</span>
    <span class="token keyword">public</span> <span class="token class-name">String</span> <span class="token function">getColor</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>
        <span class="token keyword">return</span> color<span class="token punctuation">;</span>
    <span class="token punctuation">}</span>

    <span class="token keyword">public</span> <span class="token keyword">void</span> <span class="token function">setColor</span><span class="token punctuation">(</span><span class="token class-name">String</span> color<span class="token punctuation">)</span> <span class="token punctuation">{</span>
        <span class="token keyword">this</span><span class="token punctuation">.</span>color <span class="token operator">=</span> color<span class="token punctuation">;</span>
    <span class="token punctuation">}</span>
<span class="token punctuation">}</span>
</code></pre><div class="line-numbers" aria-hidden="true"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><p>让我们创建一个实例并验证颜色：</p><div class="language-java line-numbers-mode" data-ext="java" data-title="java"><pre class="language-java"><code><span class="token class-name">ChidlCircleInterfaceImpl</span> redCircleWithoutState <span class="token operator">=</span> <span class="token keyword">new</span> <span class="token class-name">ChidlCircleInterfaceImpl</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
redCircleWithoutState<span class="token punctuation">.</span><span class="token function">setColor</span><span class="token punctuation">(</span><span class="token string">&quot;RED&quot;</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
<span class="token function">assertTrue</span><span class="token punctuation">(</span>redCircleWithoutState<span class="token punctuation">.</span><span class="token function">isValid</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
</code></pre><div class="line-numbers" aria-hidden="true"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><p>正如我们在这里看到的，我们在子类中重写了_getColor()_方法，以便默认方法在运行时验证状态。</p><h3 id="_3-2-构造函数" tabindex="-1"><a class="header-anchor" href="#_3-2-构造函数"><span>3.2. 构造函数</span></a></h3><p>抽象类可以有构造函数，允许我们在创建时初始化状态。接口当然没有构造函数。</p><h3 id="_3-3-语法差异" tabindex="-1"><a class="header-anchor" href="#_3-3-语法差异"><span>3.3. 语法差异</span></a></h3><p>此外，还有一些关于语法的差异。一个抽象类可以覆盖_Object_类的方法，但接口不能。</p><p>一个抽象类可以声明实例变量，具有所有可能的访问修饰符，并且它们可以在子类中被访问。接口只能有公共的、静态的和最终的变量，并且不能有任何实例变量。</p><p>此外，抽象类可以声明实例和静态块，而接口不能有这两种块。</p><p>最后，一个抽象类不能引用lambda表达式，而接口可以有一个单一的抽象方法，可以引用lambda表达式。</p><h2 id="_4-结论" tabindex="-1"><a class="header-anchor" href="#_4-结论"><span>4. 结论</span></a></h2><p>本文展示了带有默认方法的抽象类和接口之间的差异。我们还看到了根据我们的场景选择哪一个最合适。</p><p>只要可能，我们<strong>总是选择带有默认方法的接口，因为它允许我们扩展一个类并</strong> <strong>同时实现一个接口</strong>。</p><p>像往常一样，本文中展示的所有代码示例都可以在GitHub上找到。</p>`,36),o=[p];function l(c,i){return s(),a("div",null,o)}const d=n(e,[["render",l],["__file","2024-07-28-Interface With Default Methods vs Abstract Class.html.vue"]]),k=JSON.parse('{"path":"/posts/baeldung/2024-07-28/2024-07-28-Interface%20With%20Default%20Methods%20vs%20Abstract%20Class.html","title":"Java接口中的默认方法与抽象类对比","lang":"zh-CN","frontmatter":{"date":"2024-07-29T00:00:00.000Z","category":["Java","编程"],"tag":["接口","默认方法","抽象类"],"head":[["meta",{"name":"keywords","content":"Java接口, 默认方法, 抽象类, Java编程"}],["meta",{"property":"og:url","content":"https://www.kahen.xyz/posts/baeldung/2024-07-28/2024-07-28-Interface%20With%20Default%20Methods%20vs%20Abstract%20Class.html"}],["meta",{"property":"og:site_name","content":"Baeldung 中文网"}],["meta",{"property":"og:title","content":"Java接口中的默认方法与抽象类对比"}],["meta",{"property":"og:description","content":"Java接口中的默认方法与抽象类对比 在Java接口引入了默认方法之后，似乎接口和抽象类之间不再有任何区别。但事实并非如此——它们之间存在一些根本性的差异。 在本教程中，我们将深入探讨接口和抽象类，看看它们是如何不同的。 为什么使用默认方法？ 默认方法的目的是在不破坏现有实现的情况下提供外部功能。引入默认方法最初的动机是为集合框架提供与新lambda函..."}],["meta",{"property":"og:type","content":"article"}],["meta",{"property":"og:locale","content":"zh-CN"}],["meta",{"property":"og:updated_time","content":"2024-07-28T23:09:42.000Z"}],["meta",{"property":"article:author","content":"Kahen"}],["meta",{"property":"article:tag","content":"接口"}],["meta",{"property":"article:tag","content":"默认方法"}],["meta",{"property":"article:tag","content":"抽象类"}],["meta",{"property":"article:published_time","content":"2024-07-29T00:00:00.000Z"}],["meta",{"property":"article:modified_time","content":"2024-07-28T23:09:42.000Z"}],["script",{"type":"application/ld+json"},"{\\"@context\\":\\"https://schema.org\\",\\"@type\\":\\"Article\\",\\"headline\\":\\"Java接口中的默认方法与抽象类对比\\",\\"image\\":[\\"\\"],\\"datePublished\\":\\"2024-07-29T00:00:00.000Z\\",\\"dateModified\\":\\"2024-07-28T23:09:42.000Z\\",\\"author\\":[{\\"@type\\":\\"Person\\",\\"name\\":\\"Kahen\\",\\"url\\":\\"https://www.kahen.xyz\\"}]}"]],"description":"Java接口中的默认方法与抽象类对比 在Java接口引入了默认方法之后，似乎接口和抽象类之间不再有任何区别。但事实并非如此——它们之间存在一些根本性的差异。 在本教程中，我们将深入探讨接口和抽象类，看看它们是如何不同的。 为什么使用默认方法？ 默认方法的目的是在不破坏现有实现的情况下提供外部功能。引入默认方法最初的动机是为集合框架提供与新lambda函..."},"headers":[{"level":3,"title":"为什么使用默认方法？","slug":"为什么使用默认方法","link":"#为什么使用默认方法","children":[]},{"level":3,"title":"3.1. 状态","slug":"_3-1-状态","link":"#_3-1-状态","children":[]},{"level":3,"title":"3.2. 构造函数","slug":"_3-2-构造函数","link":"#_3-2-构造函数","children":[]},{"level":3,"title":"3.3. 语法差异","slug":"_3-3-语法差异","link":"#_3-3-语法差异","children":[]},{"level":2,"title":"4. 结论","slug":"_4-结论","link":"#_4-结论","children":[]}],"git":{"createdTime":1722208182000,"updatedTime":1722208182000,"contributors":[{"name":"Kahen","email":"Kahen@users.noreply.github.com","commits":1}]},"readingTime":{"minutes":3.56,"words":1067},"filePathRelative":"posts/baeldung/2024-07-28/2024-07-28-Interface With Default Methods vs Abstract Class.md","localizedDate":"2024年7月29日","excerpt":"\\n<p>在Java接口引入了默认方法之后，似乎接口和抽象类之间不再有任何区别。但事实并非如此——它们之间存在一些根本性的差异。</p>\\n<p>在本教程中，我们将深入探讨接口和抽象类，看看它们是如何不同的。</p>\\n<h3>为什么使用默认方法？</h3>\\n<p>默认方法的<strong>目的是在不破坏现有实现的情况下提供外部功能</strong>。引入默认方法最初的动机是为集合框架提供与新lambda函数向后兼容的功能。</p>\\n<p>让我们看看主要的基本差异。</p>\\n<h3>3.1. 状态</h3>\\n<p>抽象类可以有状态，其方法可以访问实现的状态。尽管接口中允许使用默认方法，但它们不能访问实现的状态。</p>","autoDesc":true}');export{d as comp,k as data};
