import{_ as n}from"./plugin-vue_export-helper-DlAUqK2U.js";import{c as a,o as s,a as t}from"./app-C5QtKXnb.js";const e={},p=t(`<hr><h1 id="使用webclient流式传输大型字节数组到文件" tabindex="-1"><a class="header-anchor" href="#使用webclient流式传输大型字节数组到文件"><span>使用WebClient流式传输大型字节数组到文件</span></a></h1><h2 id="_1-引言" tabindex="-1"><a class="header-anchor" href="#_1-引言"><span>1. 引言</span></a></h2><p>在本快速教程中，我们将使用_WebClient_从服务器流式传输一个大型文件。为了说明，我们将创建一个简单的控制器和两个客户端。<strong>最终，我们将学习如何以及何时使用Spring的_DataBuffer_和_DataBufferUtils_。</strong></p><h2 id="_2-我们的场景与简单服务器" tabindex="-1"><a class="header-anchor" href="#_2-我们的场景与简单服务器"><span>2. 我们的场景与简单服务器</span></a></h2><p><strong>我们将从一个简单的控制器开始，用于下载任意文件。</strong> 首先，我们将构建一个_FileSystemResource_，传递一个文件_Path_，然后将其作为响应实体(ResponseEntity)的主体包装起来：</p><div class="language-java line-numbers-mode" data-ext="java" data-title="java"><pre class="language-java"><code><span class="token annotation punctuation">@RestController</span>
<span class="token annotation punctuation">@RequestMapping</span><span class="token punctuation">(</span><span class="token string">&quot;/large-file&quot;</span><span class="token punctuation">)</span>
<span class="token keyword">public</span> <span class="token keyword">class</span> <span class="token class-name">LargeFileController</span> <span class="token punctuation">{</span>

    <span class="token annotation punctuation">@GetMapping</span>
    <span class="token class-name">ResponseEntity</span>\`<span class="token generics"><span class="token punctuation">&lt;</span><span class="token class-name">Resource</span><span class="token punctuation">&gt;</span></span>\` <span class="token function">get</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>
        <span class="token keyword">return</span> <span class="token class-name">ResponseEntity</span><span class="token punctuation">.</span><span class="token function">ok</span><span class="token punctuation">(</span><span class="token punctuation">)</span>
          <span class="token punctuation">.</span><span class="token function">body</span><span class="token punctuation">(</span><span class="token keyword">new</span> <span class="token class-name">FileSystemResource</span><span class="token punctuation">(</span><span class="token class-name">Paths</span><span class="token punctuation">.</span><span class="token function">get</span><span class="token punctuation">(</span><span class="token string">&quot;/tmp/large.dat&quot;</span><span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
    <span class="token punctuation">}</span>
<span class="token punctuation">}</span>
</code></pre><div class="line-numbers" aria-hidden="true"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><p>其次，我们需要生成我们引用的文件。<strong>由于内容对于理解本教程并不关键，我们将使用_fallocate_在磁盘上预留指定大小而不写入任何内容。</strong> 因此，让我们通过运行此命令来创建我们的大文件：</p><div class="language-bash line-numbers-mode" data-ext="sh" data-title="sh"><pre class="language-bash"><code>fallocate <span class="token parameter variable">-l</span> 128M /tmp/large.dat
</code></pre><div class="line-numbers" aria-hidden="true"><div class="line-number"></div></div></div><p>最后，我们有一个客户端可以下载的文件。所以我们准备开始编写我们的客户端。</p><h2 id="_3-使用-exchangestrategies-的-webclient-处理大型文件" tabindex="-1"><a class="header-anchor" href="#_3-使用-exchangestrategies-的-webclient-处理大型文件"><span>3. 使用_ExchangeStrategies_的_WebClient_处理大型文件</span></a></h2><p>我们将从一个简单但有限的_WebClient_开始下载我们的文件。<strong>我们将使用_ExchangeStrategies_来提高_exchange()_操作可用的内存限制。</strong> 这样，我们可以操作更多的字节，但我们仍然受限于JVM可用的最大内存。让我们使用_bodyToMono()<em>从服务器获取一个_Mono<code>&lt;byte[]&gt;</code></em>：</p><div class="language-java line-numbers-mode" data-ext="java" data-title="java"><pre class="language-java"><code><span class="token keyword">public</span> <span class="token keyword">class</span> <span class="token class-name">LimitedFileDownloadWebClient</span> <span class="token punctuation">{</span>

    <span class="token keyword">public</span> <span class="token keyword">static</span> <span class="token keyword">long</span> <span class="token function">fetch</span><span class="token punctuation">(</span><span class="token class-name">WebClient</span> client<span class="token punctuation">,</span> <span class="token class-name">String</span> destination<span class="token punctuation">)</span> <span class="token punctuation">{</span>
        <span class="token class-name">Mono</span>\`\`<span class="token operator">&lt;</span><span class="token keyword">byte</span><span class="token punctuation">[</span><span class="token punctuation">]</span><span class="token operator">&gt;</span>\`\` mono <span class="token operator">=</span> client<span class="token punctuation">.</span><span class="token function">get</span><span class="token punctuation">(</span><span class="token punctuation">)</span>
          <span class="token punctuation">.</span><span class="token function">retrieve</span><span class="token punctuation">(</span><span class="token punctuation">)</span>
          <span class="token punctuation">.</span><span class="token function">bodyToMono</span><span class="token punctuation">(</span><span class="token keyword">byte</span><span class="token punctuation">[</span><span class="token punctuation">]</span><span class="token punctuation">.</span><span class="token keyword">class</span><span class="token punctuation">)</span><span class="token punctuation">;</span>

        <span class="token keyword">byte</span><span class="token punctuation">[</span><span class="token punctuation">]</span> bytes <span class="token operator">=</span> mono<span class="token punctuation">.</span><span class="token function">block</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>

        <span class="token class-name">Path</span> path <span class="token operator">=</span> <span class="token class-name">Paths</span><span class="token punctuation">.</span><span class="token function">get</span><span class="token punctuation">(</span>destination<span class="token punctuation">)</span><span class="token punctuation">;</span>
        <span class="token class-name">Files</span><span class="token punctuation">.</span><span class="token function">write</span><span class="token punctuation">(</span>path<span class="token punctuation">,</span> bytes<span class="token punctuation">)</span><span class="token punctuation">;</span>
        <span class="token keyword">return</span> bytes<span class="token punctuation">.</span>length<span class="token punctuation">;</span>
    <span class="token punctuation">}</span>

    <span class="token comment">// ...</span>
<span class="token punctuation">}</span>
</code></pre><div class="line-numbers" aria-hidden="true"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><p>换句话说，<strong>我们正在将整个响应内容检索到一个_byte[]_中。</strong> 之后，我们将这些字节写入我们的_path_并返回下载的字节数。让我们创建一个_main()_方法来测试它：</p><div class="language-java line-numbers-mode" data-ext="java" data-title="java"><pre class="language-java"><code><span class="token keyword">public</span> <span class="token keyword">static</span> <span class="token keyword">void</span> <span class="token function">main</span><span class="token punctuation">(</span><span class="token class-name">String</span><span class="token punctuation">.</span><span class="token punctuation">.</span><span class="token punctuation">.</span> args<span class="token punctuation">)</span> <span class="token punctuation">{</span>
    <span class="token class-name">String</span> baseUrl <span class="token operator">=</span> args<span class="token punctuation">[</span><span class="token number">0</span><span class="token punctuation">]</span><span class="token punctuation">;</span>
    <span class="token class-name">String</span> destination <span class="token operator">=</span> args<span class="token punctuation">[</span><span class="token number">1</span><span class="token punctuation">]</span><span class="token punctuation">;</span>

    <span class="token class-name">WebClient</span> client <span class="token operator">=</span> <span class="token class-name">WebClient</span><span class="token punctuation">.</span><span class="token function">builder</span><span class="token punctuation">(</span><span class="token punctuation">)</span>
      <span class="token punctuation">.</span><span class="token function">baseUrl</span><span class="token punctuation">(</span>baseUrl<span class="token punctuation">)</span>
      <span class="token punctuation">.</span><span class="token function">exchangeStrategies</span><span class="token punctuation">(</span><span class="token function">useMaxMemory</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">)</span>
      <span class="token punctuation">.</span><span class="token function">build</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>

    <span class="token keyword">long</span> bytes <span class="token operator">=</span> <span class="token function">fetch</span><span class="token punctuation">(</span>client<span class="token punctuation">,</span> destination<span class="token punctuation">)</span><span class="token punctuation">;</span>
    <span class="token class-name">System</span><span class="token punctuation">.</span>out<span class="token punctuation">.</span><span class="token function">printf</span><span class="token punctuation">(</span><span class="token string">&quot;downloaded %d bytes&quot;</span><span class="token punctuation">,</span> bytes<span class="token punctuation">)</span><span class="token punctuation">;</span>
<span class="token punctuation">}</span>
</code></pre><div class="line-numbers" aria-hidden="true"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><p>此外，我们需要两个参数：下载URL和一个_destination_来本地保存它。<strong>为了避免在_客户端_中出现_DataBufferLimitException_，让我们配置一个交换策略来限制可加载到内存中的字节数。</strong> 而不是定义一个固定的大小，我们将使用_Runtime_获取为我们的应用程序配置的总内存。<strong>注意，这并不推荐，只是为了演示目的：</strong></p><div class="language-java line-numbers-mode" data-ext="java" data-title="java"><pre class="language-java"><code><span class="token keyword">private</span> <span class="token keyword">static</span> <span class="token class-name">ExchangeStrategies</span> <span class="token function">useMaxMemory</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>
    <span class="token keyword">long</span> totalMemory <span class="token operator">=</span> <span class="token class-name">Runtime</span><span class="token punctuation">.</span><span class="token function">getRuntime</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">.</span><span class="token function">maxMemory</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>

    <span class="token keyword">return</span> <span class="token class-name">ExchangeStrategies</span><span class="token punctuation">.</span><span class="token function">builder</span><span class="token punctuation">(</span><span class="token punctuation">)</span>
      <span class="token punctuation">.</span><span class="token function">codecs</span><span class="token punctuation">(</span>configurer <span class="token operator">-&gt;</span> configurer<span class="token punctuation">.</span><span class="token function">defaultCodecs</span><span class="token punctuation">(</span><span class="token punctuation">)</span>
        <span class="token punctuation">.</span><span class="token function">maxInMemorySize</span><span class="token punctuation">(</span><span class="token punctuation">(</span><span class="token keyword">int</span><span class="token punctuation">)</span> totalMemory<span class="token punctuation">)</span>
      <span class="token punctuation">)</span>
      <span class="token punctuation">.</span><span class="token function">build</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
<span class="token punctuation">}</span>
</code></pre><div class="line-numbers" aria-hidden="true"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><p>为了澄清，交换策略自定义了我们的_客户端_处理请求的方式。在这种情况下，我们使用构建器的_codecs()_方法，所以我们不会替换任何默认设置。</p><h3 id="_3-1-使用内存调整运行我们的客户端" tabindex="-1"><a class="header-anchor" href="#_3-1-使用内存调整运行我们的客户端"><span>3.1. 使用内存调整运行我们的客户端</span></a></h3><p>随后，我们将我们的项目打包为jar到_/tmp/app.jar_，并在_localhost:8081_上运行我们的服务器。然后，让我们定义一些变量，并从命令行运行我们的客户端：</p><div class="language-bash line-numbers-mode" data-ext="sh" data-title="sh"><pre class="language-bash"><code><span class="token assign-left variable">limitedClient</span><span class="token operator">=</span><span class="token string">&#39;com.baeldung.streamlargefile.client.LimitedFileDownloadWebClient&#39;</span>
<span class="token assign-left variable">endpoint</span><span class="token operator">=</span><span class="token string">&#39;http://localhost:8081/large-file&#39;</span>
<span class="token function">java</span> <span class="token parameter variable">-Xmx256m</span> <span class="token parameter variable">-cp</span> /tmp/app.jar <span class="token variable">$limitedClient</span> <span class="token variable">$endpoint</span> /tmp/download.dat
</code></pre><div class="line-numbers" aria-hidden="true"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><p><strong>注意我们允许我们的应用程序使用两倍于我们的128M文件大小的内存。</strong> 的确，我们将下载我们的文件，并得到以下输出：</p><div class="language-bash line-numbers-mode" data-ext="sh" data-title="sh"><pre class="language-bash"><code>downloaded <span class="token number">134217728</span> bytes
</code></pre><div class="line-numbers" aria-hidden="true"><div class="line-number"></div></div></div><p>另一方面，<strong>如果我们没有分配足够的内存，我们将得到一个_OutOfMemoryError_：</strong></p><div class="language-bash line-numbers-mode" data-ext="sh" data-title="sh"><pre class="language-bash"><code>$ <span class="token function">java</span> <span class="token parameter variable">-Xmx64m</span> <span class="token parameter variable">-cp</span> /tmp/app.jar <span class="token variable">$limitedClient</span> <span class="token variable">$endpoint</span> /tmp/download.dat
reactor.netty.ReactorNetty<span class="token variable">$InternalNettyException</span><span class="token builtin class-name">:</span> java.lang.OutOfMemoryError: Direct buffer memory
</code></pre><div class="line-numbers" aria-hidden="true"><div class="line-number"></div><div class="line-number"></div></div></div><p>这种方法不依赖于Spring核心实用程序。但是，它是有限的，因为我们不能下载任何接近我们应用程序最大内存大小的文件。</p><h2 id="_4-使用-databuffer-的-webclient-处理任何文件大小" tabindex="-1"><a class="header-anchor" href="#_4-使用-databuffer-的-webclient-处理任何文件大小"><span>4. 使用_DataBuffer_的_WebClient_处理任何文件大小</span></a></h2><p><strong>更安全的方法是使用_DataBuffer_和_DataBufferUtils_以块的形式流式传输我们的下载，这样整个文件就不会被加载到内存中。</strong> 然后，这次，我们将使用_bodyToFlux()<em>检索一个_Flux<code>&lt;DataBuffer&gt;</code></em>，将其写入我们的_path_，并以字节为单位返回其大小：</p><div class="language-java line-numbers-mode" data-ext="java" data-title="java"><pre class="language-java"><code><span class="token keyword">public</span> <span class="token keyword">class</span> <span class="token class-name">LargeFileDownloadWebClient</span> <span class="token punctuation">{</span>

    <span class="token keyword">public</span> <span class="token keyword">static</span> <span class="token keyword">long</span> <span class="token function">fetch</span><span class="token punctuation">(</span><span class="token class-name">WebClient</span> client<span class="token punctuation">,</span> <span class="token class-name">String</span> destination<span class="token punctuation">)</span> <span class="token punctuation">{</span>
        <span class="token class-name">Flux</span>\`\`<span class="token generics"><span class="token punctuation">&lt;</span><span class="token class-name">DataBuffer</span><span class="token punctuation">&gt;</span></span>\`\` flux <span class="token operator">=</span> client<span class="token punctuation">.</span><span class="token function">get</span><span class="token punctuation">(</span><span class="token punctuation">)</span>
          <span class="token punctuation">.</span><span class="token function">retrieve</span><span class="token punctuation">(</span><span class="token punctuation">)</span>
          <span class="token punctuation">.</span><span class="token function">bodyToFlux</span><span class="token punctuation">(</span><span class="token class-name">DataBuffer</span><span class="token punctuation">.</span><span class="token keyword">class</span><span class="token punctuation">)</span><span class="token punctuation">;</span>

        <span class="token class-name">Path</span> path <span class="token operator">=</span> <span class="token class-name">Paths</span><span class="token punctuation">.</span><span class="token function">get</span><span class="token punctuation">(</span>destination<span class="token punctuation">)</span><span class="token punctuation">;</span>
        <span class="token class-name">DataBufferUtils</span><span class="token punctuation">.</span><span class="token function">write</span><span class="token punctuation">(</span>flux<span class="token punctuation">,</span> path<span class="token punctuation">)</span>
          <span class="token punctuation">.</span><span class="token function">block</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>

        <span class="token keyword">return</span> <span class="token class-name">Files</span><span class="token punctuation">.</span><span class="token function">size</span><span class="token punctuation">(</span>path<span class="token punctuation">)</span><span class="token punctuation">;</span>
    <span class="token punctuation">}</span>

    <span class="token comment">// ...</span>
<span class="token punctuation">}</span>
</code></pre><div class="line-numbers" aria-hidden="true"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><p><strong>最后，让我们编写main方法来接收我们的参数，创建一个_WebClient_，并获取我们的文件：</strong></p><div class="language-java line-numbers-mode" data-ext="java" data-title="java"><pre class="language-java"><code><span class="token keyword">public</span> <span class="token keyword">static</span> <span class="token keyword">void</span> <span class="token function">main</span><span class="token punctuation">(</span><span class="token class-name">String</span><span class="token punctuation">.</span><span class="token punctuation">.</span><span class="token punctuation">.</span> args<span class="token punctuation">)</span> <span class="token punctuation">{</span>
    <span class="token class-name">String</span> baseUrl <span class="token operator">=</span> args<span class="token punctuation">[</span><span class="token number">0</span><span class="token punctuation">]</span><span class="token punctuation">;</span>
    <span class="token class-name">String</span> destination <span class="token operator">=</span> args<span class="token punctuation">[</span><span class="token number">1</span><span class="token punctuation">]</span><span class="token punctuation">;</span>

    <span class="token class-name">WebClient</span> client <span class="token operator">=</span> <span class="token class-name">WebClient</span><span class="token punctuation">.</span><span class="token function">create</span><span class="token punctuation">(</span>baseUrl<span class="token punctuation">)</span><span class="token punctuation">;</span>

    <span class="token keyword">long</span> bytes <span class="token operator">=</span> <span class="token function">fetch</span><span class="token punctuation">(</span>client<span class="token punctuation">,</span> destination<span class="token punctuation">)</span><span class="token punctuation">;</span>
    <span class="token class-name">System</span><span class="token punctuation">.</span>out<span class="token punctuation">.</span><span class="token function">printf</span><span class="token punctuation">(</span><span class="token string">&quot;downloaded %d bytes&quot;</span><span class="token punctuation">,</span> bytes<span class="token punctuation">)</span><span class="token punctuation">;</span>
<span class="token punctuation">}</span>
</code></pre><div class="line-numbers" aria-hidden="true"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><p>就是这样。<strong>这种方法更加通用，因为我们不依赖于文件或内存大小。</strong> 让我们将最大内存设置为我们文件大小的四分之一，并使用前面相同的_endpoint_运行它：</p><div class="language-bash line-numbers-mode" data-ext="sh" data-title="sh"><pre class="language-bash"><code><span class="token assign-left variable">client</span><span class="token operator">=</span><span class="token string">&#39;com.baeldung.streamlargefile.client.LargeFileDownloadWebClient&#39;</span>
<span class="token function">java</span> <span class="token parameter variable">-Xmx32m</span> <span class="token parameter variable">-cp</span> /tmp/app.jar <span class="token variable">$client</span> <span class="token variable">$endpoint</span> /tmp/download.dat
</code></pre><div class="line-numbers" aria-hidden="true"><div class="line-number"></div><div class="line-number"></div></div></div><p>最后，即使我们的应用程序的总内存小于我们的文件大小，我们也会得到一个成功的输出：</p><div class="language-bash line-numbers-mode" data-ext="sh" data-title="sh"><pre class="language-bash"><code>downloaded <span class="token number">134217728</span> bytes
</code></pre><div class="line-numbers" aria-hidden="true"><div class="line-number"></div></div></div><h2 id="_5-结论" tabindex="-1"><a class="header-anchor" href="#_5-结论"><span>5. 结论</span></a></h2><p>在本文中，我们学习了使用_WebClient_下载任意大型文件的不同方式。首先，我们学习了如何定义我们的_WebClient_操作可用的内存量。然后，我们看到了这种方法的缺点。<strong>最重要的是，我们学习了如何使我们的客户端高效地使用内存。</strong></p><p>如常，源代码可在GitHub上获得。</p>`,38),o=[p];function c(l,i){return s(),a("div",null,o)}const d=n(e,[["render",c],["__file","2024-07-11-Stream Large Byte   to File With WebClient.html.vue"]]),k=JSON.parse('{"path":"/posts/baeldung/2024-07-11/2024-07-11-Stream%20Large%20Byte%20%20%20to%20File%20With%20WebClient.html","title":"使用WebClient流式传输大型字节数组到文件","lang":"zh-CN","frontmatter":{"date":"2022-04-01T00:00:00.000Z","category":["Spring WebFlux","WebClient"],"tag":["Spring","WebClient","Large File"],"head":[["meta",{"name":"keywords","content":"Spring, WebFlux, WebClient, Large File Streaming"}],["meta",{"property":"og:url","content":"https://www.kahen.xyz/posts/baeldung/2024-07-11/2024-07-11-Stream%20Large%20Byte%20%20%20to%20File%20With%20WebClient.html"}],["meta",{"property":"og:site_name","content":"Baeldung 中文网"}],["meta",{"property":"og:title","content":"使用WebClient流式传输大型字节数组到文件"}],["meta",{"property":"og:description","content":"使用WebClient流式传输大型字节数组到文件 1. 引言 在本快速教程中，我们将使用_WebClient_从服务器流式传输一个大型文件。为了说明，我们将创建一个简单的控制器和两个客户端。最终，我们将学习如何以及何时使用Spring的_DataBuffer_和_DataBufferUtils_。 2. 我们的场景与简单服务器 我们将从一个简单的控制器..."}],["meta",{"property":"og:type","content":"article"}],["meta",{"property":"og:locale","content":"zh-CN"}],["meta",{"property":"og:updated_time","content":"2024-07-11T09:02:45.000Z"}],["meta",{"property":"article:author","content":"Kahen"}],["meta",{"property":"article:tag","content":"Spring"}],["meta",{"property":"article:tag","content":"WebClient"}],["meta",{"property":"article:tag","content":"Large File"}],["meta",{"property":"article:published_time","content":"2022-04-01T00:00:00.000Z"}],["meta",{"property":"article:modified_time","content":"2024-07-11T09:02:45.000Z"}],["script",{"type":"application/ld+json"},"{\\"@context\\":\\"https://schema.org\\",\\"@type\\":\\"Article\\",\\"headline\\":\\"使用WebClient流式传输大型字节数组到文件\\",\\"image\\":[\\"\\"],\\"datePublished\\":\\"2022-04-01T00:00:00.000Z\\",\\"dateModified\\":\\"2024-07-11T09:02:45.000Z\\",\\"author\\":[{\\"@type\\":\\"Person\\",\\"name\\":\\"Kahen\\",\\"url\\":\\"https://www.kahen.xyz\\"}]}"]],"description":"使用WebClient流式传输大型字节数组到文件 1. 引言 在本快速教程中，我们将使用_WebClient_从服务器流式传输一个大型文件。为了说明，我们将创建一个简单的控制器和两个客户端。最终，我们将学习如何以及何时使用Spring的_DataBuffer_和_DataBufferUtils_。 2. 我们的场景与简单服务器 我们将从一个简单的控制器..."},"headers":[{"level":2,"title":"1. 引言","slug":"_1-引言","link":"#_1-引言","children":[]},{"level":2,"title":"2. 我们的场景与简单服务器","slug":"_2-我们的场景与简单服务器","link":"#_2-我们的场景与简单服务器","children":[]},{"level":2,"title":"3. 使用_ExchangeStrategies_的_WebClient_处理大型文件","slug":"_3-使用-exchangestrategies-的-webclient-处理大型文件","link":"#_3-使用-exchangestrategies-的-webclient-处理大型文件","children":[{"level":3,"title":"3.1. 使用内存调整运行我们的客户端","slug":"_3-1-使用内存调整运行我们的客户端","link":"#_3-1-使用内存调整运行我们的客户端","children":[]}]},{"level":2,"title":"4. 使用_DataBuffer_的_WebClient_处理任何文件大小","slug":"_4-使用-databuffer-的-webclient-处理任何文件大小","link":"#_4-使用-databuffer-的-webclient-处理任何文件大小","children":[]},{"level":2,"title":"5. 结论","slug":"_5-结论","link":"#_5-结论","children":[]}],"git":{"createdTime":1720688565000,"updatedTime":1720688565000,"contributors":[{"name":"Kahen","email":"Kahen@users.noreply.github.com","commits":1}]},"readingTime":{"minutes":4.52,"words":1355},"filePathRelative":"posts/baeldung/2024-07-11/2024-07-11-Stream Large Byte   to File With WebClient.md","localizedDate":"2022年4月1日","excerpt":"<hr>\\n<h1>使用WebClient流式传输大型字节数组到文件</h1>\\n<h2>1. 引言</h2>\\n<p>在本快速教程中，我们将使用_WebClient_从服务器流式传输一个大型文件。为了说明，我们将创建一个简单的控制器和两个客户端。<strong>最终，我们将学习如何以及何时使用Spring的_DataBuffer_和_DataBufferUtils_。</strong></p>\\n<h2>2. 我们的场景与简单服务器</h2>\\n<p><strong>我们将从一个简单的控制器开始，用于下载任意文件。</strong> 首先，我们将构建一个_FileSystemResource_，传递一个文件_Path_，然后将其作为响应实体(ResponseEntity)的主体包装起来：</p>","autoDesc":true}');export{d as comp,k as data};
