import{_ as n}from"./plugin-vue_export-helper-DlAUqK2U.js";import{c as s,o as a,a as t}from"./app-BwYTipZw.js";const e={},p=t(`<hr><h1 id="modelassert-库指南-用于-json" tabindex="-1"><a class="header-anchor" href="#modelassert-库指南-用于-json"><span>ModelAssert 库指南：用于 JSON</span></a></h1><h2 id="_1-概述" tabindex="-1"><a class="header-anchor" href="#_1-概述"><span>1. 概述</span></a></h2><p>在编写使用 JSON 的软件的自动化测试时，我们经常需要将 JSON 数据与某个预期值进行比较。</p><p>在某些情况下，我们可以将实际和预期的 JSON 作为字符串进行字符串比较，但这种方法有很多限制。</p><p>在本教程中，我们将探讨如何使用 ModelAssert 编写断言并比较 JSON 值。我们将看到如何在 JSON 文档中的单个值上构建断言以及如何比较文档。我们还将涵盖如何处理无法预测确切值的字段，例如日期或 GUID。</p><h2 id="_2-入门" tabindex="-1"><a class="header-anchor" href="#_2-入门"><span>2. 入门</span></a></h2><p>ModelAssert 是一个数据断言库，语法类似于 AssertJ，并具有与 JSONAssert 相似的功能。它基于 Jackson 进行 JSON 解析，并使用 JSON Pointer 表达式来描述文档中字段的路径。</p><p>让我们从为以下 JSON 编写一些简单的断言开始：</p><div class="language-json line-numbers-mode" data-ext="json" data-title="json"><pre class="language-json"><code><span class="token punctuation">{</span>
   <span class="token property">&quot;name&quot;</span><span class="token operator">:</span> <span class="token string">&quot;Baeldung&quot;</span><span class="token punctuation">,</span>
   <span class="token property">&quot;isOnline&quot;</span><span class="token operator">:</span> <span class="token boolean">true</span><span class="token punctuation">,</span>
   <span class="token property">&quot;topics&quot;</span><span class="token operator">:</span> <span class="token punctuation">[</span> <span class="token string">&quot;Java&quot;</span><span class="token punctuation">,</span> <span class="token string">&quot;Spring&quot;</span><span class="token punctuation">,</span> <span class="token string">&quot;Kotlin&quot;</span><span class="token punctuation">,</span> <span class="token string">&quot;Scala&quot;</span><span class="token punctuation">,</span> <span class="token string">&quot;Linux&quot;</span> <span class="token punctuation">]</span>
<span class="token punctuation">}</span>
</code></pre><div class="line-numbers" aria-hidden="true"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><h3 id="_2-1-依赖" tabindex="-1"><a class="header-anchor" href="#_2-1-依赖"><span>2.1. 依赖</span></a></h3><p>首先，让我们将 ModelAssert 添加到我们的 <em>pom.xml</em>：</p><div class="language-xml line-numbers-mode" data-ext="xml" data-title="xml"><pre class="language-xml"><code>\`<span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>dependency</span><span class="token punctuation">&gt;</span></span>\`
    \`<span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>groupId</span><span class="token punctuation">&gt;</span></span>\`uk.org.webcompere\`<span class="token tag"><span class="token tag"><span class="token punctuation">&lt;/</span>groupId</span><span class="token punctuation">&gt;</span></span>\`
    \`<span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>artifactId</span><span class="token punctuation">&gt;</span></span>\`model-assert\`<span class="token tag"><span class="token tag"><span class="token punctuation">&lt;/</span>artifactId</span><span class="token punctuation">&gt;</span></span>\`
    \`<span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>version</span><span class="token punctuation">&gt;</span></span>\`1.0.0\`<span class="token tag"><span class="token tag"><span class="token punctuation">&lt;/</span>version</span><span class="token punctuation">&gt;</span></span>\`
    \`<span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>scope</span><span class="token punctuation">&gt;</span></span>\`test\`<span class="token tag"><span class="token tag"><span class="token punctuation">&lt;/</span>scope</span><span class="token punctuation">&gt;</span></span>\`
\`<span class="token tag"><span class="token tag"><span class="token punctuation">&lt;/</span>dependency</span><span class="token punctuation">&gt;</span></span>\`
</code></pre><div class="line-numbers" aria-hidden="true"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><h3 id="_2-2-断言-json-对象中的字段" tabindex="-1"><a class="header-anchor" href="#_2-2-断言-json-对象中的字段"><span>2.2. 断言 JSON 对象中的字段</span></a></h3><p>假设示例 JSON 已作为 <em>String</em> 返回给我们，我们希望检查 <em>name</em> 字段是否等于 <em>Baeldung</em>：</p><div class="language-java line-numbers-mode" data-ext="java" data-title="java"><pre class="language-java"><code><span class="token function">assertJson</span><span class="token punctuation">(</span>jsonString<span class="token punctuation">)</span>
  <span class="token punctuation">.</span><span class="token function">at</span><span class="token punctuation">(</span><span class="token string">&quot;/name&quot;</span><span class="token punctuation">)</span><span class="token punctuation">.</span><span class="token function">isText</span><span class="token punctuation">(</span><span class="token string">&quot;Baeldung&quot;</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
</code></pre><div class="line-numbers" aria-hidden="true"><div class="line-number"></div><div class="line-number"></div></div></div><p><em>assertJson</em> 方法将从各种来源读取 JSON，包括 <em>String</em>、<em>File</em>、<em>Path</em> 和 Jackson 的 <em>JsonNode</em>。返回的对象是一个断言，我们可以在其上使用流畅的 DSL（领域特定语言）来添加条件。</p><p><em>at</em> 方法描述了我们希望进行字段断言的文档中的位置。然后，<em>isText</em> 指定我们期望一个文本节点，其值为 <em>Baeldung</em>。</p><p>我们可以通过使用稍长的 JSON Pointer 表达式来断言 <em>topics</em> 数组中的路径：</p><div class="language-java line-numbers-mode" data-ext="java" data-title="java"><pre class="language-java"><code><span class="token function">assertJson</span><span class="token punctuation">(</span>jsonString<span class="token punctuation">)</span>
  <span class="token punctuation">.</span><span class="token function">at</span><span class="token punctuation">(</span><span class="token string">&quot;/topics/1&quot;</span><span class="token punctuation">)</span><span class="token punctuation">.</span><span class="token function">isText</span><span class="token punctuation">(</span><span class="token string">&quot;Spring&quot;</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
</code></pre><div class="line-numbers" aria-hidden="true"><div class="line-number"></div><div class="line-number"></div></div></div><p>虽然我们可以逐个编写字段断言，<strong>我们也可以将它们组合成一个单一的断言</strong>：</p><div class="language-java line-numbers-mode" data-ext="java" data-title="java"><pre class="language-java"><code><span class="token function">assertJson</span><span class="token punctuation">(</span>jsonString<span class="token punctuation">)</span>
  <span class="token punctuation">.</span><span class="token function">at</span><span class="token punctuation">(</span><span class="token string">&quot;/name&quot;</span><span class="token punctuation">)</span><span class="token punctuation">.</span><span class="token function">isText</span><span class="token punctuation">(</span><span class="token string">&quot;Baeldung&quot;</span><span class="token punctuation">)</span>
  <span class="token punctuation">.</span><span class="token function">at</span><span class="token punctuation">(</span><span class="token string">&quot;/topics/1&quot;</span><span class="token punctuation">)</span><span class="token punctuation">.</span><span class="token function">isText</span><span class="token punctuation">(</span><span class="token string">&quot;Spring&quot;</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
</code></pre><div class="line-numbers" aria-hidden="true"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><h3 id="_2-3-为什么字符串比较不起作用" tabindex="-1"><a class="header-anchor" href="#_2-3-为什么字符串比较不起作用"><span>2.3. 为什么字符串比较不起作用</span></a></h3><p>通常我们希望将整个 JSON 文档与另一个文档进行比较。虽然在某些情况下字符串比较是可能的，但往往会因为不相关的 JSON 格式问题而 <strong>陷入困境</strong>：</p><div class="language-java line-numbers-mode" data-ext="java" data-title="java"><pre class="language-java"><code><span class="token class-name">String</span> expected <span class="token operator">=</span> <span class="token function">loadFile</span><span class="token punctuation">(</span><span class="token constant">EXPECTED_JSON_PATH</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
<span class="token function">assertThat</span><span class="token punctuation">(</span>jsonString<span class="token punctuation">)</span>
  <span class="token punctuation">.</span><span class="token function">isEqualTo</span><span class="token punctuation">(</span>expected<span class="token punctuation">)</span><span class="token punctuation">;</span>
</code></pre><div class="line-numbers" aria-hidden="true"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><p>这种失败消息很常见：</p><div class="language-java line-numbers-mode" data-ext="java" data-title="java"><pre class="language-java"><code><span class="token class-name"><span class="token namespace">org<span class="token punctuation">.</span>opentest4j<span class="token punctuation">.</span></span>AssertionFailedError</span><span class="token operator">:</span>
expected<span class="token operator">:</span> <span class="token string">&quot;{\\n    \\&quot;name\\&quot;: \\&quot;Baeldung\\&quot;,\\n    \\&quot;isOnline\\&quot;: true,\\n    \\&quot;topics\\&quot;: [ \\&quot;Java\\&quot;, \\&quot;Spring\\&quot;, \\&quot;Kotlin\\&quot;, \\&quot;Scala\\&quot;, \\&quot;Linux\\&quot; ]\\n}&quot;</span>
but was <span class="token operator">:</span> <span class="token string">&quot;{\\&quot;name\\&quot;: \\&quot;Baeldung\\&quot;,\\&quot;isOnline\\&quot;: true,\\&quot;topics\\&quot;: [ \\&quot;Java\\&quot;, \\&quot;Spring\\&quot;, \\&quot;Kotlin\\&quot;, \\&quot;Scala\\&quot;, \\&quot;Linux\\&quot; ]}&quot;</span>
</code></pre><div class="line-numbers" aria-hidden="true"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><h3 id="_2-4-语义上比较树" tabindex="-1"><a class="header-anchor" href="#_2-4-语义上比较树"><span>2.4. 语义上比较树</span></a></h3><p><strong>要进行整个文档的比较，我们可以使用 <em>isEqualTo</em></strong>：</p><div class="language-java line-numbers-mode" data-ext="java" data-title="java"><pre class="language-java"><code><span class="token function">assertJson</span><span class="token punctuation">(</span>jsonString<span class="token punctuation">)</span>
  <span class="token punctuation">.</span><span class="token function">isEqualTo</span><span class="token punctuation">(</span><span class="token constant">EXPECTED_JSON_PATH</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
</code></pre><div class="line-numbers" aria-hidden="true"><div class="line-number"></div><div class="line-number"></div></div></div><p>在这种情况下，实际 JSON 的字符串由 <em>assertJson</em> 加载，预期的 JSON 文档 - 由 <em>Path</em> 描述的文件 - 在 <em>isEqualTo</em> 内部加载。比较是基于数据进行的。</p><h3 id="_2-5-不同格式" tabindex="-1"><a class="header-anchor" href="#_2-5-不同格式"><span>2.5. 不同格式</span></a></h3><p>ModelAssert 还支持可以由 Jackson 转换为 <em>JsonNode</em> 的 Java 对象，以及 <em>yaml</em> 格式。</p><div class="language-java line-numbers-mode" data-ext="java" data-title="java"><pre class="language-java"><code><span class="token class-name">Map</span>\`<span class="token generics"><span class="token punctuation">&lt;</span><span class="token class-name">String</span><span class="token punctuation">,</span> <span class="token class-name">String</span><span class="token punctuation">&gt;</span></span>\` map <span class="token operator">=</span> <span class="token keyword">new</span> <span class="token class-name">HashMap</span><span class="token generics"><span class="token punctuation">&lt;</span><span class="token punctuation">&gt;</span></span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
map<span class="token punctuation">.</span><span class="token function">put</span><span class="token punctuation">(</span><span class="token string">&quot;name&quot;</span><span class="token punctuation">,</span> <span class="token string">&quot;baeldung&quot;</span><span class="token punctuation">)</span><span class="token punctuation">;</span>

<span class="token function">assertJson</span><span class="token punctuation">(</span>map<span class="token punctuation">)</span>
  <span class="token punctuation">.</span><span class="token function">isEqualToYaml</span><span class="token punctuation">(</span><span class="token string">&quot;name: baeldung&quot;</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
</code></pre><div class="line-numbers" aria-hidden="true"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><p>对于 <em>yaml</em> 处理，使用 <em>isEqualToYaml</em> 方法来指示字符串或文件的格式。如果源是 <em>yaml</em>，则需要使用 <em>assertYaml</em>：</p><div class="language-java line-numbers-mode" data-ext="java" data-title="java"><pre class="language-java"><code><span class="token function">assertYaml</span><span class="token punctuation">(</span><span class="token string">&quot;name: baeldung&quot;</span><span class="token punctuation">)</span>
  <span class="token punctuation">.</span><span class="token function">isEqualTo</span><span class="token punctuation">(</span>map<span class="token punctuation">)</span><span class="token punctuation">;</span>
</code></pre><div class="line-numbers" aria-hidden="true"><div class="line-number"></div><div class="line-number"></div></div></div><h2 id="_3-字段断言" tabindex="-1"><a class="header-anchor" href="#_3-字段断言"><span>3. 字段断言</span></a></h2><p>到目前为止，我们已经看到了一些基本的断言。让我们看看更多的 DSL。</p><h3 id="_3-1-在任何节点断言" tabindex="-1"><a class="header-anchor" href="#_3-1-在任何节点断言"><span>3.1. 在任何节点断言</span></a></h3><p>ModelAssert 的 DSL 允许几乎可以在树的任何节点上添加可能的条件。这是因为 JSON 树在任何级别都可能包含任何类型的节点。</p><p>让我们看看我们可能会在示例 JSON 的根节点上添加的一些断言：</p><div class="language-java line-numbers-mode" data-ext="java" data-title="java"><pre class="language-java"><code><span class="token function">assertJson</span><span class="token punctuation">(</span>jsonString<span class="token punctuation">)</span>
  <span class="token punctuation">.</span><span class="token function">isNotNull</span><span class="token punctuation">(</span><span class="token punctuation">)</span>
  <span class="token punctuation">.</span><span class="token function">isNotNumber</span><span class="token punctuation">(</span><span class="token punctuation">)</span>
  <span class="token punctuation">.</span><span class="token function">isObject</span><span class="token punctuation">(</span><span class="token punctuation">)</span>
  <span class="token punctuation">.</span><span class="token function">containsKey</span><span class="token punctuation">(</span><span class="token string">&quot;name&quot;</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
</code></pre><div class="line-numbers" aria-hidden="true"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><p>由于断言对象在其接口上提供了这些方法，我们的 IDE 会在我们按下 <em>“.”</em> 键时立即建议我们可以添加的各种断言。</p><p>在大多数情况下，我们使用 JSON Pointer 表达式从根节点开始，以便对树中较低级别的节点进行断言：</p><div class="language-java line-numbers-mode" data-ext="java" data-title="java"><pre class="language-java"><code><span class="token function">assertJson</span><span class="token punctuation">(</span>jsonString<span class="token punctuation">)</span>
  <span class="token punctuation">.</span><span class="token function">at</span><span class="token punctuation">(</span><span class="token string">&quot;/topics&quot;</span><span class="token punctuation">)</span><span class="token punctuation">.</span><span class="token function">hasSize</span><span class="token punctuation">(</span><span class="token number">5</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
</code></pre><div class="line-numbers" aria-hidden="true"><div class="line-number"></div><div class="line-number"></div></div></div><p>这个断言使用 <em>hasSize</em> 来检查 <em>topic</em> 字段中的数组有五个元素。<em>hasSize</em> 方法适用于对象、数组和字符串。对象的大小是其键的数量，字符串的大小是其字符数，数组的大小是其元素数量。</p><p>我们对字段进行的大多数断言都取决于字段的确切类型。我们可以使用方法 <em>number</em>、<em>array</em>、<em>text</em>、<em>booleanNode</em> 和 <em>object</em> 来进入更具体的断言子集，当我们试图对特定类型的字段编写断言时。这是可选的，但可以更有表现力：</p><div class="language-java line-numbers-mode" data-ext="java" data-title="java"><pre class="language-java"><code><span class="token function">assertJson</span><span class="token punctuation">(</span>jsonString<span class="token punctuation">)</span>
  <span class="token punctuation">.</span><span class="token function">at</span><span class="token punctuation">(</span><span class="token string">&quot;/isOnline&quot;</span><span class="token punctuation">)</span><span class="token punctuation">.</span><span class="token function">booleanNode</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">.</span><span class="token function">isTrue</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
</code></pre><div class="line-numbers" aria-hidden="true"><div class="line-number"></div><div class="line-number"></div></div></div><p>当我们在 IDE 中按下 <em>booleanNode</em> 后的 <em>“.”</em> 键时，我们只会看到布尔节点的自动完成选项。</p><h3 id="_3-2-文本节点" tabindex="-1"><a class="header-anchor" href="#_3-2-文本节点"><span>3.2. 文本节点</span></a></h3><p>当我们断言文本节点时，我们可以使用 <em>isText</em> 进行精确值比较。或者，我们可以使用 <em>textContains</em> 来断言一个子字符串：</p><div class="language-java line-numbers-mode" data-ext="java" data-title="java"><pre class="language-java"><code><span class="token function">assertJson</span><span class="token punctuation">(</span>jsonString<span class="token punctuation">)</span>
  <span class="token punctuation">.</span><span class="token function">at</span><span class="token punctuation">(</span><span class="token string">&quot;/name&quot;</span><span class="token punctuation">)</span><span class="token punctuation">.</span><span class="token function">textContains</span><span class="token punctuation">(</span><span class="token string">&quot;ael&quot;</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
</code></pre><div class="line-numbers" aria-hidden="true"><div class="line-number"></div><div class="line-number"></div></div></div><p>我们还可以通过对 _<em>matches</em> 的使用来使用正则表达式：</p><div class="language-java line-numbers-mode" data-ext="java" data-title="java"><pre class="language-java"><code><span class="token function">assertJson</span><span class="token punctuation">(</span>jsonString<span class="token punctuation">)</span>
  <span class="token punctuation">.</span><span class="token function">at</span><span class="token punctuation">(</span><span class="token string">&quot;/name&quot;</span><span class="token punctuation">)</span><span class="token punctuation">.</span><span class="token function">matches</span><span class="token punctuation">(</span><span class="token string">&quot;[A-Z].+&quot;</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
</code></pre><div class="line-numbers" aria-hidden="true"><div class="line-number"></div><div class="line-number"></div></div></div><p>这个例子断言 <em>name</em> 以大写字母开头。</p><h3 id="_3-3-数字节点" tabindex="-1"><a class="header-anchor" href="#_3-3-数字节点"><span>3.3. 数字节点</span></a></h3><p>对于数字节点，DSL 提供了一些有用的数字比较：</p><div class="language-java line-numbers-mode" data-ext="java" data-title="java"><pre class="language-java"><code><span class="token function">assertJson</span><span class="token punctuation">(</span><span class="token string">&quot;{count: 12}&quot;</span><span class="token punctuation">)</span>
  <span class="token punctuation">.</span><span class="token function">at</span><span class="token punctuation">(</span><span class="token string">&quot;/count&quot;</span><span class="token punctuation">)</span><span class="token punctuation">.</span><span class="token function">isBetween</span><span class="token punctuation">(</span><span class="token number">1</span><span class="token punctuation">,</span> <span class="token number">25</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
</code></pre><div class="line-numbers" aria-hidden="true"><div class="line-number"></div><div class="line-number"></div></div></div><p>我们还可以指定我们期望的 Java 数字类型：</p><div class="language-java line-numbers-mode" data-ext="java" data-title="java"><pre class="language-java"><code><span class="token function">assertJson</span><span class="token punctuation">(</span><span class="token string">&quot;{height: 6.3}&quot;</span><span class="token punctuation">)</span>
  <span class="token punctuation">.</span><span class="token function">at</span><span class="token punctuation">(</span><span class="token string">&quot;/height&quot;</span><span class="token punctuation">)</span><span class="token punctuation">.</span><span class="token function">isGreaterThanDouble</span><span class="token punctuation">(</span><span class="token number">6.0</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
</code></pre><div class="line-numbers" aria-hidden="true"><div class="line-number"></div><div class="line-number"></div></div></div><p><em>isEqualTo</em> 方法保留用于整个树匹配，因此对于比较数字等式，我们使用 <em>isNumberEqualTo</em>：</p><div class="language-java line-numbers-mode" data-ext="java" data-title="java"><pre class="language-java"><code><span class="token function">assertJson</span><span class="token punctuation">(</span><span class="token string">&quot;{height: 6.3}&quot;</span><span class="token punctuation">)</span>
  <span class="token punctuation">.</span><span class="token function">at</span><span class="token punctuation">(</span><span class="token string">&quot;/height&quot;</span><span class="token punctuation">)</span><span class="token punctuation">.</span><span class="token function">isNumberEqualTo</span><span class="token punctuation">(</span><span class="token number">6.3</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
</code></pre><div class="line-numbers" aria-hidden="true"><div class="line-number"></div><div class="line-number"></div></div></div><h3 id="_3-4-数组节点" tabindex="-1"><a class="header-anchor" href="#_3-4-数组节点"><span>3.4. 数组节点</span></a></h3><p>我们可以使用 <em>isArrayContaining</em> 来测试数组的内容：</p><div class="language-java line-numbers-mode" data-ext="java" data-title="java"><pre class="language-java"><code><span class="token function">assertJson</span><span class="token punctuation">(</span>jsonString<span class="token punctuation">)</span>
  <span class="token punctuation">.</span><span class="token function">at</span><span class="token punctuation">(</span><span class="token string">&quot;/topics&quot;</span><span class="token punctuation">)</span><span class="token punctuation">.</span><span class="token function">isArrayContaining</span><span class="token punctuation">(</span><span class="token string">&quot;Scala&quot;</span><span class="token punctuation">,</span> <span class="token string">&quot;Spring&quot;</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
</code></pre><div class="line-numbers" aria-hidden="true"><div class="line-number"></div><div class="line-number"></div></div></div><p>这测试了给定值的存在，并允许实际数组包含其他项目。如果我们希望断言更精确的匹配，我们可以使用 <em>isArrayContainingExactlyInAnyOrder</em>：</p><div class="language-java line-numbers-mode" data-ext="java" data-title="java"><pre class="language-java"><code><span class="token function">assertJson</span><span class="token punctuation">(</span>jsonString<span class="token punctuation">)</span>
   <span class="token punctuation">.</span><span class="token function">at</span><span class="token punctuation">(</span><span class="token string">&quot;/topics&quot;</span><span class="token punctuation">)</span>
   <span class="token punctuation">.</span><span class="token function">isArrayContainingExactlyInAnyOrder</span><span class="token punctuation">(</span><span class="token string">&quot;Scala&quot;</span><span class="token punctuation">,</span> <span class="token string">&quot;Spring&quot;</span><span class="token punctuation">,</span> <span class="token string">&quot;Java&quot;</span><span class="token punctuation">,</span> <span class="token string">&quot;Linux&quot;</span><span class="token punctuation">,</span> <span class="token string">&quot;Kotlin&quot;</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
</code></pre><div class="line-numbers" aria-hidden="true"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><p>我们还可以使其要求确切的顺序：</p><div class="language-java line-numbers-mode" data-ext="java" data-title="java"><pre class="language-java"><code><span class="token function">assertJson</span><span class="token punctuation">(</span><span class="token constant">ACTUAL_JSON</span><span class="token punctuation">)</span>
  <span class="token punctuation">.</span><span class="token function">at</span><span class="token punctuation">(</span><span class="token string">&quot;/topics&quot;</span><span class="token punctuation">)</span>
  <span class="token punctuation">.</span><span class="token function">isArrayContainingExactly</span><span class="token punctuation">(</span><span class="token string">&quot;Java&quot;</span><span class="token punctuation">,</span> <span class="token string">&quot;Spring&quot;</span><span class="token punctuation">,</span> <span class="token string">&quot;Kotlin&quot;</span><span class="token punctuation">,</span> <span class="token string">&quot;Scala&quot;</span><span class="token punctuation">,</span> <span class="token string">&quot;Linux&quot;</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
</code></pre><div class="line-numbers" aria-hidden="true"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><p>这是一种在数组包含原始值时断言数组内容的好技术。如果数组包含对象，我们可能希望使用 <em>isEqualTo</em> 代替。</p><h2 id="_4-整棵树匹配" tabindex="-1"><a class="header-anchor" href="#_4-整棵树匹配"><span>4. 整棵树匹配</span></a></h2><p>虽然我们可以使用多个特定于字段的条件构建断言来检查 JSON 文档中的内容，但我们经常需要将整个文档与另一个文档进行比较。</p><p><em>isEqualTo</em> 方法（或 <em>isNotEqualTo</em>）用于比较整棵树。这可以与 <em>at</em> 结合使用，以便在进行比较之前移动到实际的子树：</p><div class="language-java line-numbers-mode" data-ext="java" data-title="java"><pre class="language-java"><code><span class="token function">assertJson</span><span class="token punctuation">(</span>jsonString<span class="token punctuation">)</span>
  <span class="token punctuation">.</span><span class="token function">at</span><span class="token punctuation">(</span><span class="token string">&quot;/topics&quot;</span><span class="token punctuation">)</span>
  <span class="token punctuation">.</span><span class="token function">isEqualTo</span><span class="token punctuation">(</span><span class="token string">&quot;[ \\&quot;Java\\&quot;, \\&quot;Spring\\&quot;, \\&quot;Kotlin\\&quot;, \\&quot;Scala\\&quot;, \\&quot;Linux\\&quot; ]&quot;</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
</code></pre><div class="line-numbers" aria-hidden="true"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><p>当 JSON 包含数据时，整棵树比较可能会遇到问题，这些数据要么：</p><ul><li>相同，但顺序不同</li><li>包含一些无法预测的值</li></ul><p><em>where</em> 方法用于自定义下一次 <em>isEqualTo</em> 操作，以解决这些问题。</p><h3 id="_4-1-添加键顺序约束" tabindex="-1"><a class="header-anchor" href="#_4-1-添加键顺序约束"><span>4.1. 添加键顺序约束</span></a></h3><p>让我们看两个看起来相同的 JSON 文档：</p><div class="language-java line-numbers-mode" data-ext="java" data-title="java"><pre class="language-java"><code><span class="token class-name">String</span> actualJson <span class="token operator">=</span> <span class="token string">&quot;{a:{d:3, c:2, b:1}}&quot;</span><span class="token punctuation">;</span>
<span class="token class-name">String</span> expectedJson <span class="token operator">=</span> <span class="token string">&quot;{a:{b:1, c:2, d:3}}&quot;</span><span class="token punctuation">;</span>
</code></pre><div class="line-numbers" aria-hidden="true"><div class="line-number"></div><div class="line-number"></div></div></div><p>我们应该注意，这不是严格的 JSON 格式。<strong>ModelAssert 允许我们使用 JSON 的 JavaScript 表示法</strong>，以及通常引用字段名称的线路格式。</p><p>这两个文档在 <em>“a”</em> 下面有完全相同的键，但它们的顺序不同。对这些文档的断言将会失败，因为 <strong>ModelAssert 默认使用严格的键顺序</strong>。</p><p>我们可以通过添加 <em>where</em> 配置来放宽键顺序规则：</p><div class="language-java line-numbers-mode" data-ext="java" data-title="java"><pre class="language-java"><code><span class="token function">assertJson</span><span class="token punctuation">(</span>actualJson<span class="token punctuation">)</span>
  <span class="token punctuation">.</span><span class="token function">where</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">.</span><span class="token function">keysInAnyOrder</span><span class="token punctuation">(</span><span class="token punctuation">)</span>
  <span class="token punctuation">.</span><span class="token function">isEqualTo</span><span class="token punctuation">(</span>expectedJson<span class="token punctuation">)</span><span class="token punctuation">;</span>
</code></pre><div class="line-numbers" aria-hidden="true"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><p>这允许树中的任何对象具有与预期文档不同的键顺序，并且仍然匹配。</p><p>我们可以将此规则限制到特定路径：</p><div class="language-java line-numbers-mode" data-ext="java" data-title="java"><pre class="language-java"><code><span class="token function">assertJson</span><span class="token punctuation">(</span>actualJson<span class="token punctuation">)</span>
  <span class="token punctuation">.</span><span class="token function">where</span><span class="token punctuation">(</span><span class="token punctuation">)</span>
    <span class="token punctuation">.</span><span class="token function">at</span><span class="token punctuation">(</span><span class="token string">&quot;/a&quot;</span><span class="token punctuation">)</span><span class="token punctuation">.</span><span class="token function">keysInAnyOrder</span><span class="token punctuation">(</span><span class="token punctuation">)</span>
  <span class="token punctuation">.</span><span class="token function">isEqualTo</span><span class="token punctuation">(</span>expectedJson<span class="token punctuation">)</span><span class="token punctuation">;</span>
</code></pre><div class="line-numbers" aria-hidden="true"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><p>这将 <em>keysInAnyOrder</em> 限制为仅根对象中的 <em>“a”</em> 字段。</p><p><strong>自定义比较规则的能力使我们能够处理许多场景</strong>，其中无法完全控制或预测生成的确切文档。</p><h3 id="_4-2-放宽数组约束" tabindex="-1"><a class="header-anchor" href="#_4-2-放宽数组约束"><span>4.2. 放宽数组约束</span></a></h3><p>如果我们有数组，其中值的顺序可能会变化，那么我们可以放宽整个比较的数组排序约束：</p><div class="language-java line-numbers-mode" data-ext="java" data-title="java"><pre class="language-java"><code><span class="token class-name">String</span> actualJson <span class="token operator">=</span> <span class="token string">&quot;{a:[1, 2, 3, 4, 5]}&quot;</span><span class="token punctuation">;</span>
<span class="token class-name">String</span> expectedJson <span class="token operator">=</span> <span class="token string">&quot;{a:[5, 4, 3, 2, 1]}&quot;</span><span class="token punctuation">;</span>

<span class="token function">assertJson</span><span class="token punctuation">(</span>actualJson<span class="token punctuation">)</span>
  <span class="token punctuation">.</span><span class="token function">where</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">.</span><span class="token function">arrayInAnyOrder</span><span class="token punctuation">(</span><span class="token punctuation">)</span>
  <span class="token punctuation">.</span><span class="token function">isEqualTo</span><span class="token punctuation">(</span>expectedJson<span class="token punctuation">)</span><span class="token punctuation">;</span>
</code></pre><div class="line-numbers" aria-hidden="true"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><p>或者，我们可以像我们对 <em>keysInAnyOrder</em> 那样限制该约束。</p><h3 id="_4-3-忽略路径" tabindex="-1"><a class="header-anchor" href="#_4-3-忽略路径"><span>4.3. 忽略路径</span></a></h3><p>也许我们的实际文档包含一些我们不感兴趣或无法预测的字段。我们可以添加一个规则来忽略该路径：</p><div class="language-java line-numbers-mode" data-ext="java" data-title="java"><pre class="language-java"><code><span class="token class-name">String</span> actualJson <span class="token operator">=</span> <span class="token string">&quot;{user:{name: \\&quot;Baeldung\\&quot;, url:\\&quot;http://www.baeldung.com\\&quot;}}&quot;</span><span class="token punctuation">;</span>
<span class="token class-name">String</span> expectedJson <span class="token operator">=</span> <span class="token string">&quot;{user:{name: \\&quot;Baeldung\\&quot;}}&quot;</span><span class="token punctuation">;</span>

<span class="token function">assertJson</span><span class="token punctuation">(</span>actualJson<span class="token punctuation">)</span>
  <span class="token punctuation">.</span><span class="token function">where</span><span class="token punctuation">(</span><span class="token punctuation">)</span>
    <span class="token punctuation">.</span><span class="token function">at</span><span class="token punctuation">(</span><span class="token string">&quot;/user/url&quot;</span><span class="token punctuation">)</span><span class="token punctuation">.</span><span class="token function">isIgnored</span><span class="token punctuation">(</span><span class="token punctuation">)</span>
  <span class="token punctuation">.</span><span class="token function">isEqualTo</span><span class="token punctuation">(</span>expectedJson<span class="token punctuation">)</span><span class="token punctuation">;</span>
</code></pre><div class="line-numbers" aria-hidden="true"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><p>我们应该注意到，我们表达的路径 <strong>始终是实际中的 JSON Pointer</strong>。</p><p>实际中的额外字段 <em>“url”</em> 现在被忽略了。</p><h3 id="_4-4-忽略任何-guid" tabindex="-1"><a class="header-anchor" href="#_4-4-忽略任何-guid"><span>4.4. 忽略任何 GUID</span></a></h3><p>到目前为止，我们只添加了使用 <em>at</em> 的规则，以便在文档的特定位置自定义比较。</p><p><em>path</em> 语法允许我们使用通配符来描述我们的规则适用的位置。当我们向比较的 <em>where</em> 添加 <em>at</em> 或 <em>path</em> 条件时，<strong>我们也可以提供任何上述字段断言</strong>，以替代与预期文档的并排比较。</p><p>假设我们有一个 <em>id</em> 字段，它出现在文档的多个地方，并且是一个我们无法预测的 GUID。</p><p>我们可以使用路径规则来忽略这个字段：</p><div class="language-java line-numbers-mode" data-ext="java" data-title="java"><pre class="language-java"><code><span class="token class-name">String</span> actualJson <span class="token operator">=</span> &quot;<span class="token punctuation">{</span>user<span class="token operator">:</span><span class="token punctuation">{</span>credentials<span class="token operator">:</span><span class="token punctuation">[</span>\\&quot; <span class="token operator">+</span> 
  \\&quot;<span class="token punctuation">{</span>id<span class="token operator">:</span>\\&quot;a7dc2567<span class="token operator">-</span><span class="token number">3340</span><span class="token operator">-</span><span class="token number">4</span>a3b<span class="token operator">-</span>b1ab<span class="token operator">-</span><span class="token number">9</span>ce1778f265d\\&quot;<span class="token punctuation">,</span>role<span class="token operator">:</span>\\&quot;<span class="token class-name">Admin</span>\\&quot;<span class="token punctuation">}</span><span class="token punctuation">,</span>\\&quot; <span class="token operator">+</span> 
  \\&quot;<span class="token punctuation">{</span>id<span class="token operator">:</span>\\&quot;<span class="token number">09d</span>a84ba<span class="token operator">-</span><span class="token number">19</span>c2<span class="token operator">-</span><span class="token number">4674</span><span class="token operator">-</span><span class="token number">974f</span><span class="token operator">-</span>fd5afff3a0e5\\&quot;<span class="token punctuation">,</span>role<span class="token operator">:</span>\\&quot;<span class="token class-name">Sales</span>\\&quot;<span class="token punctuation">}</span><span class="token punctuation">]</span><span class="token punctuation">}</span><span class="token punctuation">}</span>&quot;<span class="token punctuation">;</span>
<span class="token class-name">String</span> expectedJson <span class="token operator">=</span> &quot;<span class="token punctuation">{</span>user<span class="token operator">:</span><span class="token punctuation">{</span>credentials<span class="token operator">:</span>\\&quot; <span class="token operator">+</span> 
  \\&quot;<span class="token punctuation">[</span><span class="token punctuation">{</span>id<span class="token operator">:</span>\\&quot;<span class="token operator">?</span><span class="token operator">?</span><span class="token operator">?</span>\\&quot;<span class="token punctuation">,</span>role<span class="token operator">:</span>\\&quot;<span class="token class-name">Admin</span>\\&quot;<span class="token punctuation">}</span><span class="token punctuation">,</span>\\&quot; <span class="token operator">+</span> 
  \\&quot;<span class="token punctuation">{</span>id<span class="token operator">:</span>\\&quot;<span class="token operator">?</span><span class="token operator">?</span><span class="token operator">?</span>\\&quot;<span class="token punctuation">,</span>role<span class="token operator">:</span>\\&quot;<span class="token class-name">Sales</span>\\&quot;<span class="token punctuation">}</span><span class="token punctuation">]</span><span class="token punctuation">}</span><span class="token punctuation">}</span>&quot;<span class="token punctuation">;</span>

<span class="token function">assertJson</span><span class="token punctuation">(</span>actualJson<span class="token punctuation">)</span>
  <span class="token punctuation">.</span><span class="token function">where</span><span class="token punctuation">(</span><span class="token punctuation">)</span>
    <span class="token punctuation">.</span><span class="token function">path</span><span class="token punctuation">(</span><span class="token string">&quot;user&quot;</span><span class="token punctuation">,</span> <span class="token string">&quot;credentials&quot;</span><span class="token punctuation">,</span> <span class="token constant">ANY</span><span class="token punctuation">,</span> <span class="token string">&quot;id&quot;</span><span class="token punctuation">)</span><span class="token punctuation">.</span><span class="token function">isIgnored</span><span class="token punctuation">(</span><span class="token punctuation">)</span>
  <span class="token punctuation">.</span><span class="token function">isEqualTo</span><span class="token punctuation">(</span>expectedJson<span class="token punctuation">)</span><span class="token punctuation">;</span>
</code></pre><div class="line-numbers" aria-hidden="true"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><p>在这里，我们的预期值可以有任何 <em>id</em> 字段的值，因为我们简单地忽略了任何 JSON Pointer 以 <em>“/user/credentials”</em> 开始，然后有一个单独的节点（数组索引）并以 <em>“/id”</em> 结束的字段。</p><h3 id="_4-5-匹配任何-guid" tabindex="-1"><a class="header-anchor" href="#_4-5-匹配任何-guid"><span>4.5. 匹配任何 GUID</span></a></h3><p>忽略我们无法预测的字段是一个选项。更好的做法是按类型匹配这些节点，并可能还满足它们必须满足的其他条件。让我们切换到强制这些 GUID 匹配 GUID 的模式，并允许 <em>id</em> 节点出现在树的任何叶节点：</p><div class="language-java line-numbers-mode" data-ext="java" data-title="java"><pre class="language-java"><code><span class="token function">assertJson</span><span class="token punctuation">(</span>actualJson<span class="token punctuation">)</span>
  <span class="token punctuation">.</span><span class="token function">where</span><span class="token punctuation">(</span><span class="token punctuation">)</span>
    <span class="token punctuation">.</span><span class="token function">path</span><span class="token punctuation">(</span><span class="token constant">ANY_SUBTREE</span><span class="token punctuation">,</span> <span class="token string">&quot;id&quot;</span><span class="token punctuation">)</span><span class="token punctuation">.</span><span class="token function">matches</span><span class="token punctuation">(</span><span class="token constant">GUID_PATTERN</span><span class="token punctuation">)</span>
  <span class="token punctuation">.</span><span class="token function">isEqualTo</span><span class="token punctuation">(</span>expectedJson<span class="token punctuation">)</span><span class="token punctuation">;</span>
</code></pre><div class="line-numbers" aria-hidden="true"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><p><em>ANY_SUBTREE</em> 通配符匹配路径表达式的部分之间的任意数量的节点。<em>GUID_PATTERN</em> 来自 ModelAssert 的 <em>Patterns</em> 类，其中包含一些常见的正则表达式，用于匹配像数字和日期戳这样的东西。</p><h3 id="_4-6-自定义-isequalto" tabindex="-1"><a class="header-anchor" href="#_4-6-自定义-isequalto"><span>4.6. 自定义 <em>isEqualTo</em></span></a></h3><p><em>where</em> 与 <em>path</em> 或 <em>at</em> 表达式的组合允许我们在树的任何位置覆盖比较。我们要么添加内置的对象或数组匹配规则，要么指定用于比较的特定替代断言，用于单个或类别的路径。</p><p>如果我们有一个在各种比较中重复使用的常见配置，我们可以将其提取到一个方法中：</p><div class="language-java line-numbers-mode" data-ext="java" data-title="java"><pre class="language-java"><code><span class="token keyword">private</span> <span class="token keyword">static</span> \`\`\`<span class="token generics"><span class="token punctuation">&lt;</span><span class="token class-name">T</span><span class="token punctuation">&gt;</span></span>\`\`\` <span class="token class-name">WhereDsl</span>\`\`\`<span class="token generics"><span class="token punctuation">&lt;</span><span class="token class-name">T</span><span class="token punctuation">&gt;</span></span>\`\`\` <span class="token function">idsAreGuids</span><span class="token punctuation">(</span><span class="token class-name">WhereDsl</span>\`\`\`<span class="token generics"><span class="token punctuation">&lt;</span><span class="token class-name">T</span><span class="token punctuation">&gt;</span></span>\`\`\` where<span class="token punctuation">)</span> <span class="token punctuation">{</span>
    <span class="token keyword">return</span> where<span class="token punctuation">.</span><span class="token function">path</span><span class="token punctuation">(</span><span class="token constant">ANY_SUBTREE</span><span class="token punctuation">,</span> <span class="token string">&quot;id&quot;</span><span class="token punctuation">)</span><span class="token punctuation">.</span><span class="token function">matches</span><span class="token punctuation">(</span><span class="token constant">GUID_PATTERN</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
<span class="token punctuation">}</span>
</code></pre><div class="line-numbers" aria-hidden="true"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><p>然后，我们可以将该配置添加到特定断言中，使用 <em>configuredBy</em>：</p><div class="language-java line-numbers-mode" data-ext="java" data-title="java"><pre class="language-java"><code><span class="token function">assertJson</span><span class="token punctuation">(</span>actualJson<span class="token punctuation">)</span>
  <span class="token punctuation">.</span><span class="token function">where</span><span class="token punctuation">(</span><span class="token punctuation">)</span>
    <span class="token punctuation">.</span><span class="token function">configuredBy</span><span class="token punctuation">(</span>where <span class="token operator">-&gt;</span> <span class="token function">idsAreGuids</span><span class="token punctuation">(</span>where<span class="token punctuation">)</span><span class="token punctuation">)</span>
  <span class="token punctuation">.</span><span class="token function">isEqualTo</span><span class="token punctuation">(</span>expectedJson<span class="token punctuation">)</span><span class="token punctuation">;</span>
</code></pre><div class="line-numbers" aria-hidden="true"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><h2 id="_5-与其他库的兼容性" tabindex="-1"><a class="header-anchor" href="#_5-与其他库的兼容性"><span>5. 与其他库的兼容性</span></a></h2><p>ModelAssert 为互操作性而构建。到目前为止，我们已经看到了 AssertJ 风格的断言。这些可以有多个条件，并且 <strong>它们将在第一个不满足的条件上失败</strong>。</p><p>然而，有时我们需要为其他类型的测试生成匹配器对象。</p><h3 id="_5-1-hamcrest-匹配器" tabindex="-1"><a class="header-anchor" href="#_5-1-hamcrest-匹配器"><span>5.1. Hamcrest 匹配器</span></a></h3><p>Hamcrest 是一个由许多工具支持的主要断言助手库。<strong>我们可以使用 ModelAssert 的 DSL 生成 Hamcrest 匹配器</strong>：</p><div class="language-java line-numbers-mode" data-ext="java" data-title="java"><pre class="language-java"><code><span class="token class-name">Matcher</span>\`<span class="token generics"><span class="token punctuation">&lt;</span><span class="token class-name">String</span><span class="token punctuation">&gt;</span></span>\` matcher <span class="token operator">=</span> <span class="token function">json</span><span class="token punctuation">(</span><span class="token punctuation">)</span>
  <span class="token punctuation">.</span><span class="token function">at</span><span class="token punctuation">(</span><span class="token string">&quot;/name&quot;</span><span class="token punctuation">)</span><span class="token punctuation">.</span><span class="token function">hasValue</span><span class="token punctuation">(</span><span class="token string">&quot;Baeldung&quot;</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
</code></pre><div class="line-numbers" aria-hidden="true"><div class="line-number"></div><div class="line-number"></div></div></div><p><em>json</em> 方法用于描述一个将接受包含 JSON 数据的 <em>String</em> 的匹配器。我们也可以使用方法 <em>jsonFile</em> 来生成一个期望断言 <em>File</em> 内容的 <em>Matcher</em>。ModelAssert 的 <em>JsonAssertions</em> 类包含多个像这样的构建器方法，以开始构建 Hamcrest 匹配器。</p><p>表达比较的 DSL 与 <em>assertJson</em> 相同，但比较直到有东西使用匹配器时才会执行。</p><p>因此，我们可以使用 ModelAssert 与 Hamcrest 的 <em>MatcherAssert</em>：</p><div class="language-java line-numbers-mode" data-ext="java" data-title="java"><pre class="language-java"><code><span class="token class-name">MatcherAssert</span><span class="token punctuation">.</span><span class="token function">assertThat</span><span class="token punctuation">(</span>jsonString<span class="token punctuation">,</span> <span class="token function">json</span><span class="token punctuation">(</span><span class="token punctuation">)</span>
  <span class="token punctuation">.</span><span class="token function">at</span><span class="token punctuation">(</span><span class="token string">&quot;/name&quot;</span><span class="token punctuation">)</span><span class="token punctuation">.</span><span class="token function">hasValue</span><span class="token punctuation">(</span><span class="token string">&quot;Baeldung&quot;</span><span class="token punctuation">)</span>
  <span class="token punctuation">.</span><span class="token function">at</span><span class="token punctuation">(</span><span class="token string">&quot;/topics/1&quot;</span><span class="token punctuation">)</span><span class="token punctuation">.</span><span class="token function">isText</span><span class="token punctuation">(</span><span class="token string">&quot;Spring&quot;</span><span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
</code></pre><div class="line-numbers" aria-hidden="true"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><h3 id="_5-2-与-spring-mock-mvc-一起使用" tabindex="-1"><a class="header-anchor" href="#_5-2-与-spring-mock-mvc-一起使用"><span>5.2. 与 Spring Mock MVC 一起使用</span></a></h3><p>在使用 Spring Mock MVC 的响应体验证时，我们可以使用 Spring 内置的 <em>jsonPath</em> 断言。然而，Spring 还允许我们使用 Hamcrest 匹配器来断言作为响应内容返回的字符串。这意味着我们可以使用 ModelAssert 进行复杂的内容断言。</p><h3 id="_5-3-与-mockito-一起使用" tabindex="-1"><a class="header-anchor" href="#_5-3-与-mockito-一起使用"><span>5.3. 与 Mockito 一起使用</span></a></h3><p>Mockito 已经与 Hamcrest 互操作。然而，ModelAssert 还提供了一个本地的 <em>ArgumentMatcher</em>。这可以用于设置存根的行为以及验证对它们的调用：</p><div class="language-java line-numbers-mode" data-ext="java" data-title="java"><pre class="language-java"><code><span class="token keyword">public</span> <span class="token keyword">interface</span> <span class="token class-name">DataService</span> <span class="token punctuation">{</span>
    <span class="token keyword">boolean</span> <span class="token function">isUserLoggedIn</span><span class="token punctuation">(</span><span class="token class-name">String</span> userDetails<span class="token punctuation">)</span><span class="token punctuation">;</span>
<span class="token punctuation">}</span>

<span class="token annotation punctuation">@Mock</span>
<span class="token keyword">private</span> <span class="token class-name">DataService</span> mockDataService<span class="token punctuation">;</span>

<span class="token annotation punctuation">@Test</span>
<span class="token keyword">void</span> <span class="token function">givenUserIsOnline_thenIsLoggedIn</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>
    <span class="token function">given</span><span class="token punctuation">(</span>mockDataService<span class="token punctuation">.</span><span class="token function">isUserLoggedIn</span><span class="token punctuation">(</span><span class="token function">argThat</span><span class="token punctuation">(</span><span class="token function">json</span><span class="token punctuation">(</span><span class="token punctuation">)</span>
      <span class="token punctuation">.</span><span class="token function">at</span><span class="token punctuation">(</span><span class="token string">&quot;/isOnline&quot;</span><span class="token punctuation">)</span><span class="token punctuation">.</span><span class="token function">isTrue</span><span class="token punctuation">(</span><span class="token punctuation">)</span>
      <span class="token punctuation">.</span><span class="token function">toArgumentMatcher</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">)</span>
      <span class="token punctuation">.</span><span class="token function">willReturn</span><span class="token punctuation">(</span><span class="token boolean">true</span><span class="token punctuation">)</span><span class="token punctuation">;</span>

    <span class="token function">assertThat</span><span class="token punctuation">(</span>mockDataService<span class="token punctuation">.</span><span class="token function">isUserLoggedIn</span><span class="token punctuation">(</span>jsonString<span class="token punctuation">)</span><span class="token punctuation">)</span>
      <span class="token punctuation">.</span><span class="token function">isTrue</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>

    <span class="token function">verify</span><span class="token punctuation">(</span>mockDataService<span class="token punctuation">)</span>
      <span class="token punctuation">.</span><span class="token function">isUserLoggedIn</span><span class="token punctuation">(</span><span class="token function">argThat</span><span class="token punctuation">(</span><span class="token function">json</span><span class="token punctuation">(</span><span class="token punctuation">)</span>
        <span class="token punctuation">.</span><span class="token function">at</span><span class="token punctuation">(</span><span class="token string">&quot;/name&quot;</span><span class="token punctuation">)</span><span class="token punctuation">.</span><span class="token function">isText</span><span class="token punctuation">(</span><span class="token string">&quot;Baeldung&quot;</span><span class="token punctuation">)</span>
        <span class="token punctuation">.</span><span class="token function">toArgumentMatcher</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
<span class="token punctuation">}</span>
</code></pre><div class="line-numbers" aria-hidden="true"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><p>在这个例子中，Mockito 的 <em>argThat</em> 用于模拟的设置和 <em>verify</em>。在其中，我们使用 Hamcrest 风格的构建器为匹配器 - <em>json</em>。然后我们向它添加条件，最后使用 <em>toArgumentMatcher</em> 将其转换为 Mockito 的 <em>ArgumentMatcher</em>。</p><h2 id="_6-结论" tabindex="-1"><a class="header-anchor" href="#_6-结论"><span>6. 结论</span></a></h2><p>在本文中，我们探讨了在我们的测试中语义上比较 JSON 的</p>`,133),o=[p];function c(i,u){return a(),s("div",null,o)}const d=n(e,[["render",c],["__file","2024-07-28-Guide to the ModelAssert Library for JSON.html.vue"]]),k=JSON.parse('{"path":"/posts/baeldung/2024-07-28/2024-07-28-Guide%20to%20the%20ModelAssert%20Library%20for%20JSON.html","title":"ModelAssert 库指南：用于 JSON","lang":"zh-CN","frontmatter":{"date":"2024-07-29T00:00:00.000Z","category":["Testing","JSON"],"tag":["ModelAssert","JSON Testing","AssertJ","Jackson"],"head":[["meta",{"name":"keywords","content":"JSON, ModelAssert, Testing, AssertJ, Jackson"}],["meta",{"property":"og:url","content":"https://www.kahen.xyz/posts/baeldung/2024-07-28/2024-07-28-Guide%20to%20the%20ModelAssert%20Library%20for%20JSON.html"}],["meta",{"property":"og:site_name","content":"Baeldung 中文网"}],["meta",{"property":"og:title","content":"ModelAssert 库指南：用于 JSON"}],["meta",{"property":"og:description","content":"ModelAssert 库指南：用于 JSON 1. 概述 在编写使用 JSON 的软件的自动化测试时，我们经常需要将 JSON 数据与某个预期值进行比较。 在某些情况下，我们可以将实际和预期的 JSON 作为字符串进行字符串比较，但这种方法有很多限制。 在本教程中，我们将探讨如何使用 ModelAssert 编写断言并比较 JSON 值。我们将看到如..."}],["meta",{"property":"og:type","content":"article"}],["meta",{"property":"og:locale","content":"zh-CN"}],["meta",{"property":"og:updated_time","content":"2024-07-28T20:06:23.000Z"}],["meta",{"property":"article:author","content":"Kahen"}],["meta",{"property":"article:tag","content":"ModelAssert"}],["meta",{"property":"article:tag","content":"JSON Testing"}],["meta",{"property":"article:tag","content":"AssertJ"}],["meta",{"property":"article:tag","content":"Jackson"}],["meta",{"property":"article:published_time","content":"2024-07-29T00:00:00.000Z"}],["meta",{"property":"article:modified_time","content":"2024-07-28T20:06:23.000Z"}],["script",{"type":"application/ld+json"},"{\\"@context\\":\\"https://schema.org\\",\\"@type\\":\\"Article\\",\\"headline\\":\\"ModelAssert 库指南：用于 JSON\\",\\"image\\":[\\"\\"],\\"datePublished\\":\\"2024-07-29T00:00:00.000Z\\",\\"dateModified\\":\\"2024-07-28T20:06:23.000Z\\",\\"author\\":[{\\"@type\\":\\"Person\\",\\"name\\":\\"Kahen\\",\\"url\\":\\"https://www.kahen.xyz\\"}]}"]],"description":"ModelAssert 库指南：用于 JSON 1. 概述 在编写使用 JSON 的软件的自动化测试时，我们经常需要将 JSON 数据与某个预期值进行比较。 在某些情况下，我们可以将实际和预期的 JSON 作为字符串进行字符串比较，但这种方法有很多限制。 在本教程中，我们将探讨如何使用 ModelAssert 编写断言并比较 JSON 值。我们将看到如..."},"headers":[{"level":2,"title":"1. 概述","slug":"_1-概述","link":"#_1-概述","children":[]},{"level":2,"title":"2. 入门","slug":"_2-入门","link":"#_2-入门","children":[{"level":3,"title":"2.1. 依赖","slug":"_2-1-依赖","link":"#_2-1-依赖","children":[]},{"level":3,"title":"2.2. 断言 JSON 对象中的字段","slug":"_2-2-断言-json-对象中的字段","link":"#_2-2-断言-json-对象中的字段","children":[]},{"level":3,"title":"2.3. 为什么字符串比较不起作用","slug":"_2-3-为什么字符串比较不起作用","link":"#_2-3-为什么字符串比较不起作用","children":[]},{"level":3,"title":"2.4. 语义上比较树","slug":"_2-4-语义上比较树","link":"#_2-4-语义上比较树","children":[]},{"level":3,"title":"2.5. 不同格式","slug":"_2-5-不同格式","link":"#_2-5-不同格式","children":[]}]},{"level":2,"title":"3. 字段断言","slug":"_3-字段断言","link":"#_3-字段断言","children":[{"level":3,"title":"3.1. 在任何节点断言","slug":"_3-1-在任何节点断言","link":"#_3-1-在任何节点断言","children":[]},{"level":3,"title":"3.2. 文本节点","slug":"_3-2-文本节点","link":"#_3-2-文本节点","children":[]},{"level":3,"title":"3.3. 数字节点","slug":"_3-3-数字节点","link":"#_3-3-数字节点","children":[]},{"level":3,"title":"3.4. 数组节点","slug":"_3-4-数组节点","link":"#_3-4-数组节点","children":[]}]},{"level":2,"title":"4. 整棵树匹配","slug":"_4-整棵树匹配","link":"#_4-整棵树匹配","children":[{"level":3,"title":"4.1. 添加键顺序约束","slug":"_4-1-添加键顺序约束","link":"#_4-1-添加键顺序约束","children":[]},{"level":3,"title":"4.2. 放宽数组约束","slug":"_4-2-放宽数组约束","link":"#_4-2-放宽数组约束","children":[]},{"level":3,"title":"4.3. 忽略路径","slug":"_4-3-忽略路径","link":"#_4-3-忽略路径","children":[]},{"level":3,"title":"4.4. 忽略任何 GUID","slug":"_4-4-忽略任何-guid","link":"#_4-4-忽略任何-guid","children":[]},{"level":3,"title":"4.5. 匹配任何 GUID","slug":"_4-5-匹配任何-guid","link":"#_4-5-匹配任何-guid","children":[]},{"level":3,"title":"4.6. 自定义 isEqualTo","slug":"_4-6-自定义-isequalto","link":"#_4-6-自定义-isequalto","children":[]}]},{"level":2,"title":"5. 与其他库的兼容性","slug":"_5-与其他库的兼容性","link":"#_5-与其他库的兼容性","children":[{"level":3,"title":"5.1. Hamcrest 匹配器","slug":"_5-1-hamcrest-匹配器","link":"#_5-1-hamcrest-匹配器","children":[]},{"level":3,"title":"5.2. 与 Spring Mock MVC 一起使用","slug":"_5-2-与-spring-mock-mvc-一起使用","link":"#_5-2-与-spring-mock-mvc-一起使用","children":[]},{"level":3,"title":"5.3. 与 Mockito 一起使用","slug":"_5-3-与-mockito-一起使用","link":"#_5-3-与-mockito-一起使用","children":[]}]},{"level":2,"title":"6. 结论","slug":"_6-结论","link":"#_6-结论","children":[]}],"git":{"createdTime":1722197183000,"updatedTime":1722197183000,"contributors":[{"name":"Kahen","email":"Kahen@users.noreply.github.com","commits":1}]},"readingTime":{"minutes":10.93,"words":3279},"filePathRelative":"posts/baeldung/2024-07-28/2024-07-28-Guide to the ModelAssert Library for JSON.md","localizedDate":"2024年7月29日","excerpt":"<hr>\\n<h1>ModelAssert 库指南：用于 JSON</h1>\\n<h2>1. 概述</h2>\\n<p>在编写使用 JSON 的软件的自动化测试时，我们经常需要将 JSON 数据与某个预期值进行比较。</p>\\n<p>在某些情况下，我们可以将实际和预期的 JSON 作为字符串进行字符串比较，但这种方法有很多限制。</p>\\n<p>在本教程中，我们将探讨如何使用 ModelAssert 编写断言并比较 JSON 值。我们将看到如何在 JSON 文档中的单个值上构建断言以及如何比较文档。我们还将涵盖如何处理无法预测确切值的字段，例如日期或 GUID。</p>\\n<h2>2. 入门</h2>\\n<p>ModelAssert 是一个数据断言库，语法类似于 AssertJ，并具有与 JSONAssert 相似的功能。它基于 Jackson 进行 JSON 解析，并使用 JSON Pointer 表达式来描述文档中字段的路径。</p>","autoDesc":true}');export{d as comp,k as data};
