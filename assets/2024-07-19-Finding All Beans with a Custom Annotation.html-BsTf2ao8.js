import{_ as e}from"./plugin-vue_export-helper-DlAUqK2U.js";import{c as n,o as i,a as t}from"./app-0nXvcScy.js";const a={},s=t('<h1 id="在spring中查找所有带有自定义注解的bean" tabindex="-1"><a class="header-anchor" href="#在spring中查找所有带有自定义注解的bean"><span>在Spring中查找所有带有自定义注解的Bean</span></a></h1><p>在本教程中，我们将解释如何在Spring中查找所有带有自定义注解的Bean。我们将展示根据不同的Spring版本使用的不同方法。</p><h2 id="_2-使用spring-boot-2-2或更高版本" tabindex="-1"><a class="header-anchor" href="#_2-使用spring-boot-2-2或更高版本"><span>2. 使用Spring Boot 2.2或更高版本</span></a></h2><p>自Spring Boot 2.2以来，我们可以使用<code>getBeansWithAnnotation</code>方法。</p><p>让我们构建一个示例。首先，我们将定义我们的自定义注解。我们将使用<code>@Retention(RetentionPolicy.RUNTIME)</code>对其进行注解，以确保程序在运行时可以访问该注解：</p><div class="language-text line-numbers-mode" data-ext="text" data-title="text"><pre class="language-text"><code>@Retention(RetentionPolicy.RUNTIME)\npublic @interface MyCustomAnnotation {\n}\n</code></pre><div class="line-numbers" aria-hidden="true"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><p>现在，让我们定义一个带有我们注解的第一个Bean。我们还将使用<code>@Component</code>对其进行注解：</p><div class="language-text line-numbers-mode" data-ext="text" data-title="text"><pre class="language-text"><code>@Component\n@MyCustomAnnotation\npublic class MyComponent {\n}\n</code></pre><div class="line-numbers" aria-hidden="true"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><p>然后，让我们定义另一个带有我们注解的Bean。但这次我们将通过<code>@Configuration</code>文件中的<code>@Bean</code>注解方法来创建它：</p><div class="language-text line-numbers-mode" data-ext="text" data-title="text"><pre class="language-text"><code>public class MyService {\n}\n\n@Configuration\npublic class MyConfigurationBean {\n    @Bean\n    @MyCustomAnnotation\n    MyService myService() {\n        return new MyService();\n    }\n}\n</code></pre><div class="line-numbers" aria-hidden="true"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><p>现在，让我们编写一个测试来检查<code>getBeansWithAnnotation</code>方法是否可以检测到我们的两个Bean：</p><div class="language-text line-numbers-mode" data-ext="text" data-title="text"><pre class="language-text"><code>@Test\nvoid whenApplicationContextStarted_ThenShouldDetectAllAnnotatedBeans() {\n    try (AnnotationConfigApplicationContext applicationContext = new AnnotationConfigApplicationContext(MyComponent.class, MyConfigurationBean.class)) {\n        Map`&lt;String, Object&gt;` beans = applicationContext.getBeansWithAnnotation(MyCustomAnnotation.class);\n        assertEquals(2, beans.size());\n        assertTrue(beans.keySet().containsAll(List.of(&quot;myComponent&quot;, &quot;myService&quot;)));\n    }\n}\n</code></pre><div class="line-numbers" aria-hidden="true"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><h2 id="_3-使用旧版本的spring" tabindex="-1"><a class="header-anchor" href="#_3-使用旧版本的spring"><span>3. 使用旧版本的Spring</span></a></h2><h3 id="_3-1-历史背景" tabindex="-1"><a class="header-anchor" href="#_3-1-历史背景"><span>3.1. 历史背景</span></a></h3><p>在5.2之前的Spring Framework版本中，<code>getBeansWithAnnotation</code>方法只能检测到在类或接口级别注解的Bean，但不能检测到在工厂方法级别注解的Bean。</p><p>Spring Boot 2.2升级了Spring Framework依赖到5.2，这就是为什么使用旧版本的Spring时，我们刚刚编写的测试会失败：</p><ul><li><code>MyComponent</code> Bean被正确检测到，因为注解在类级别</li><li><code>MyService</code> Bean没有被检测到，因为它是通过工厂方法创建的</li></ul><p>让我们看看如何绕过这种行为。</p><h3 id="_3-2-使用-qualifier装饰自定义注解" tabindex="-1"><a class="header-anchor" href="#_3-2-使用-qualifier装饰自定义注解"><span>3.2. 使用@Qualifier装饰自定义注解</span></a></h3><p>有一个相当单的解决方法：我们可以简单地使用<code>@Qualifier</code>来装饰我们的注解。</p><p>然后我们的注解看起来像这样：</p><div class="language-text line-numbers-mode" data-ext="text" data-title="text"><pre class="language-text"><code>@Retention(RetentionPolicy.RUNTIME)\n@Qualifier\npublic @interface MyCustomAnnotation {\n}\n</code></pre><div class="line-numbers" aria-hidden="true"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><p>现在，我们能够自动注入两个注解的Bean。让我们通过一个测试来检查：</p><div class="language-text line-numbers-mode" data-ext="text" data-title="text"><pre class="language-text"><code>@Autowired\n@MyCustomAnnotation\nprivate List`&lt;Object&gt;` annotatedBeans;\n\n@Test\nvoid whenAutowiring_ThenShouldDetectAllAnnotatedBeans() {\n    assertEquals(2, annotatedBeans.size());\n    List``````&lt;String&gt;`````` classNames = annotatedBeans.stream()\n        .map(Object::getClass)\n        .map(Class::getName)\n        .map(s -&gt; s.substring(s.lastIndexOf(&quot;.&quot;) + 1))\n        .collect(Collectors.toList());\n    assertTrue(classNames.containsAll(List.of(&quot;MyComponent&quot;, &quot;MyService&quot;)));\n}\n</code></pre><div class="line-numbers" aria-hidden="true"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><p>这种解决方法最简单，但是，<strong>它可能不符合我们的需求，例如，如果我们不拥有注解</strong>。</p><p>让我们还注意到，使用<code>@Qualifier</code>装饰我们的自定义注解会将其变成Spring的限定符。</p><h3 id="_3-3-列出通过工厂方法创建的bean" tabindex="-1"><a class="header-anchor" href="#_3-3-列出通过工厂方法创建的bean"><span>3.3. 列出通过工厂方法创建的Bean</span></a></h3><p>现在我们已经理解了问题主要出现在通过工厂方法创建的Bean上，让我们专注于如何只列出这些Bean。我们将展示一个在所有情况下都有效的解决方案，而不需要对我们的自定义注解进行任何更改。我们将使用反射来访问Bean的注解。</p><p>鉴于我们可以访问Spring的<code>ApplicationContext</code>，我们将按照以下步骤进行：</p><ul><li>访问<code>BeanFactory</code></li><li>查找与每个Bean相关联的<code>BeanDefinition</code></li><li>检查<code>BeanDefinition</code>的来源是否是<code>AnnotatedTypeMetadata</code>，这意味着我们将能够访问Bean的注解</li><li>如果Bean有注解，检查所需的注解是否在其中</li></ul><p>让我们创建我们自己的<code>BeanUtils</code>工具类，并在方法中实现这个逻辑：</p><div class="language-text line-numbers-mode" data-ext="text" data-title="text"><pre class="language-text"><code>public class BeanUtils {\n    public static List``````&lt;String&gt;`````` getBeansWithAnnotation(GenericApplicationContext applicationContext, Class````&lt;?&gt;```` annotationClass) {\n        List``````&lt;String&gt;`````` result = new ArrayList``````&lt;String&gt;``````();\n        ConfigurableListableBeanFactory factory = applicationContext.getBeanFactory();\n        for(String name : factory.getBeanDefinitionNames()) {\n            BeanDefinition bd = factory.getBeanDefinition(name);\n            if(bd.getSource() instanceof AnnotatedTypeMetadata) {\n                AnnotatedTypeMetadata metadata = (AnnotatedTypeMetadata) bd.getSource();\n                if (metadata.getAnnotationAttributes(annotationClass.getName()) != null) {\n                    result.add(name);\n                }\n            }\n        }\n        return result;\n    }\n}\n</code></pre><div class="line-numbers" aria-hidden="true"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><p>或者，我们也可以使用<code>Streams</code>来编写相同的函数：</p><div class="language-text line-numbers-mode" data-ext="text" data-title="text"><pre class="language-text"><code>public static List``````&lt;String&gt;`````` getBeansWithAnnotation(GenericApplicationContext applicationContext, Class````&lt;?&gt;```` annotationClass) {\n    ConfigurableListableBeanFactory factory = applicationContext.getBeanFactory();\n    return Arrays.stream(factory.getBeanDefinitionNames())\n        .filter(name -&gt; isAnnotated(factory, name, annotationClass))\n        .collect(Collectors.toList());\n}\n\nprivate static boolean isAnnotated(ConfigurableListableBeanFactory factory, String beanName, Class````&lt;?&gt;```` annotationClass) {\n    BeanDefinition beanDefinition = factory.getBeanDefinition(beanName);\n    if(beanDefinition.getSource() instanceof AnnotatedTypeMetadata) {\n        AnnotatedTypeMetadata metadata = (AnnotatedTypeMetadata) beanDefinition.getSource();\n        return metadata.getAnnotationAttributes(annotationClass.getName()) != null;\n    }\n    return false;\n}\n</code></pre><div class="line-numbers" aria-hidden="true"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><p>在这些方法中，我们使用了<code>GenericApplicationContext</code>，它是Spring <code>ApplicationContext</code>的一个实现，不假定特定的Bean定义格式。</p><p>要访问<code>GenericApplicationContext</code>，例如，我们可以将其注入到一个Spring组件中：</p><div class="language-text line-numbers-mode" data-ext="text" data-title="text"><pre class="language-text"><code>@Component\npublic class AnnotatedBeansComponent {\n    @Autowired\n    GenericApplicationContext applicationContext;\n\n    public List``````&lt;String&gt;`````` getBeansWithAnnotation(Class````&lt;?&gt;```` annotationClass) {\n        return BeanUtils.getBeansWithAnnotation(applicationContext, annotationClass);\n    }\n}\n</code></pre><div class="line-numbers" aria-hidden="true"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><h2 id="_4-结论" tabindex="-1"><a class="header-anchor" href="#_4-结论"><span>4. 结论</span></a></h2><p>在本文中，我们讨论了如何列出带有给定注解的Bean。我们看到自Spring Boot 2.2以来，这是通过<code>getBeansWithAnnotation</code>方法自然完成的。</p><p>另一方面，我们也展示了一些替代方法来克服这种方法以前行为的限制：要么仅在我们的注解上添加<code>@Qualifier</code>，要么通过查找Bean，使用反射来检查它们是否有注解。</p><p>如常，完整的代码可在GitHub上获得。</p>',41),l=[s];function o(d,r){return i(),n("div",null,l)}const u=e(a,[["render",o],["__file","2024-07-19-Finding All Beans with a Custom Annotation.html.vue"]]),v=JSON.parse('{"path":"/posts/baeldung/2024-07-19/2024-07-19-Finding%20All%20Beans%20with%20a%20Custom%20Annotation.html","title":"在Spring中查找所有带有自定义注解的Bean","lang":"zh-CN","frontmatter":{"date":"2022-04-01T00:00:00.000Z","category":["Spring","Spring Boot"],"tag":["Spring Framework","Custom Annotation"],"head":[["meta",{"name":"keywords","content":"Spring, Spring Boot, Custom Annotation, Beans, Injection"}],["meta",{"property":"og:url","content":"https://www.kahen.xyz/posts/baeldung/2024-07-19/2024-07-19-Finding%20All%20Beans%20with%20a%20Custom%20Annotation.html"}],["meta",{"property":"og:site_name","content":"Baeldung 中文网"}],["meta",{"property":"og:title","content":"在Spring中查找所有带有自定义注解的Bean"}],["meta",{"property":"og:description","content":"在Spring中查找所有带有自定义注解的Bean 在本教程中，我们将解释如何在Spring中查找所有带有自定义注解的Bean。我们将展示根据不同的Spring版本使用的不同方法。 2. 使用Spring Boot 2.2或更高版本 自Spring Boot 2.2以来，我们可以使用getBeansWithAnnotation方法。 让我们构建一个示例。..."}],["meta",{"property":"og:type","content":"article"}],["meta",{"property":"og:locale","content":"zh-CN"}],["meta",{"property":"og:updated_time","content":"2024-07-19T07:11:02.000Z"}],["meta",{"property":"article:author","content":"Kahen"}],["meta",{"property":"article:tag","content":"Spring Framework"}],["meta",{"property":"article:tag","content":"Custom Annotation"}],["meta",{"property":"article:published_time","content":"2022-04-01T00:00:00.000Z"}],["meta",{"property":"article:modified_time","content":"2024-07-19T07:11:02.000Z"}],["script",{"type":"application/ld+json"},"{\\"@context\\":\\"https://schema.org\\",\\"@type\\":\\"Article\\",\\"headline\\":\\"在Spring中查找所有带有自定义注解的Bean\\",\\"image\\":[\\"\\"],\\"datePublished\\":\\"2022-04-01T00:00:00.000Z\\",\\"dateModified\\":\\"2024-07-19T07:11:02.000Z\\",\\"author\\":[{\\"@type\\":\\"Person\\",\\"name\\":\\"Kahen\\",\\"url\\":\\"https://www.kahen.xyz\\"}]}"]],"description":"在Spring中查找所有带有自定义注解的Bean 在本教程中，我们将解释如何在Spring中查找所有带有自定义注解的Bean。我们将展示根据不同的Spring版本使用的不同方法。 2. 使用Spring Boot 2.2或更高版本 自Spring Boot 2.2以来，我们可以使用getBeansWithAnnotation方法。 让我们构建一个示例。..."},"headers":[{"level":2,"title":"2. 使用Spring Boot 2.2或更高版本","slug":"_2-使用spring-boot-2-2或更高版本","link":"#_2-使用spring-boot-2-2或更高版本","children":[]},{"level":2,"title":"3. 使用旧版本的Spring","slug":"_3-使用旧版本的spring","link":"#_3-使用旧版本的spring","children":[{"level":3,"title":"3.1. 历史背景","slug":"_3-1-历史背景","link":"#_3-1-历史背景","children":[]},{"level":3,"title":"3.2. 使用@Qualifier装饰自定义注解","slug":"_3-2-使用-qualifier装饰自定义注解","link":"#_3-2-使用-qualifier装饰自定义注解","children":[]},{"level":3,"title":"3.3. 列出通过工厂方法创建的Bean","slug":"_3-3-列出通过工厂方法创建的bean","link":"#_3-3-列出通过工厂方法创建的bean","children":[]}]},{"level":2,"title":"4. 结论","slug":"_4-结论","link":"#_4-结论","children":[]}],"git":{"createdTime":1721373062000,"updatedTime":1721373062000,"contributors":[{"name":"Kahen","email":"Kahen@users.noreply.github.com","commits":1}]},"readingTime":{"minutes":3.9,"words":1171},"filePathRelative":"posts/baeldung/2024-07-19/2024-07-19-Finding All Beans with a Custom Annotation.md","localizedDate":"2022年4月1日","excerpt":"\\n<p>在本教程中，我们将解释如何在Spring中查找所有带有自定义注解的Bean。我们将展示根据不同的Spring版本使用的不同方法。</p>\\n<h2>2. 使用Spring Boot 2.2或更高版本</h2>\\n<p>自Spring Boot 2.2以来，我们可以使用<code>getBeansWithAnnotation</code>方法。</p>\\n<p>让我们构建一个示例。首先，我们将定义我们的自定义注解。我们将使用<code>@Retention(RetentionPolicy.RUNTIME)</code>对其进行注解，以确保程序在运行时可以访问该注解：</p>\\n<div class=\\"language-text\\" data-ext=\\"text\\" data-title=\\"text\\"><pre class=\\"language-text\\"><code>@Retention(RetentionPolicy.RUNTIME)\\npublic @interface MyCustomAnnotation {\\n}\\n</code></pre></div>","autoDesc":true}');export{u as comp,v as data};
