import{_ as n}from"./plugin-vue_export-helper-DlAUqK2U.js";import{c as s,o as a,a as t}from"./app-uCPH-HyI.js";const e={},p=t(`<h1 id="使用spock测试捕获方法参数" tabindex="-1"><a class="header-anchor" href="#使用spock测试捕获方法参数"><span>使用Spock测试捕获方法参数</span></a></h1><p>当我们测试代码时，有时我们想要捕获传递给方法的参数。</p><p>在本教程中，我们将学习如何使用Spock测试中的_Stubs_、_Mocks_和_Spies_来捕获参数，并检查我们捕获的内容。我们还将学习如何验证对同一_Mock_的多次调用使用不同的参数，并断言这些调用的顺序。</p><h2 id="_2-我们测试的主题" tabindex="-1"><a class="header-anchor" href="#_2-我们测试的主题"><span>2. 我们测试的主题</span></a></h2><p>首先，我们需要一个接受我们想要捕获的单个参数或参数的方法。</p><p>让我们创建一个_ArgumentCaptureSubject_类，它有一个_catchMeIfYouCan()_方法，该方法接受一个_String_并返回它，前面加上“Received ”：</p><div class="language-java line-numbers-mode" data-ext="java" data-title="java"><pre class="language-java"><code><span class="token keyword">public</span> <span class="token keyword">class</span> <span class="token class-name">ArgumentCaptureSubject</span> <span class="token punctuation">{</span>
    <span class="token keyword">public</span> <span class="token class-name">String</span> <span class="token function">catchMeIfYouCan</span><span class="token punctuation">(</span><span class="token class-name">String</span> input<span class="token punctuation">)</span> <span class="token punctuation">{</span>
        <span class="token keyword">return</span> <span class="token string">&quot;Received &quot;</span> <span class="token operator">+</span> input<span class="token punctuation">;</span>
    <span class="token punctuation">}</span>
<span class="token punctuation">}</span>
</code></pre><div class="line-numbers" aria-hidden="true"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><h2 id="_3-准备我们的数据驱动测试" tabindex="-1"><a class="header-anchor" href="#_3-准备我们的数据驱动测试"><span>3. 准备我们的数据驱动测试</span></a></h2><p>我们将从典型的_Stub_使用开始，并发展到捕获参数。</p><p>让我们创建一个我们类的_Stub_，返回一个“42”的存根响应，并调用它的_catchMeIfYouCan()_方法：</p><div class="language-groovy line-numbers-mode" data-ext="groovy" data-title="groovy"><pre class="language-groovy"><code><span class="token keyword">def</span> <span class="token interpolation-string"><span class="token string">&quot;given a Stub when we invoke it then we capture the stubbed response&quot;</span></span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>
    <span class="token spock-block">given:</span> <span class="token interpolation-string"><span class="token string">&quot;an input and a result&quot;</span></span>
    <span class="token keyword">def</span> input <span class="token operator">=</span> <span class="token interpolation-string"><span class="token string">&quot;Input&quot;</span></span>
    <span class="token keyword">def</span> stubbedResponse <span class="token operator">=</span> <span class="token interpolation-string"><span class="token string">&quot;42&quot;</span></span>

    <span class="token spock-block">and:</span> <span class="token interpolation-string"><span class="token string">&quot;a Stub for our response&quot;</span></span>
    <span class="token annotation punctuation">@Subject</span>
    ArgumentCaptureSubject stubClass <span class="token operator">=</span> <span class="token function">Stub</span><span class="token punctuation">(</span><span class="token punctuation">)</span>
    stubClass<span class="token punctuation">.</span><span class="token function">catchMeIfYouCan</span><span class="token punctuation">(</span><span class="token number">_</span><span class="token punctuation">)</span> <span class="token operator">&gt;&gt;&gt;</span> stubbedResponse

    <span class="token spock-block">when:</span> <span class="token interpolation-string"><span class="token string">&quot;we invoke our Stub&#39;s method&quot;</span></span>
    <span class="token keyword">def</span> result <span class="token operator">=</span> stubClass<span class="token punctuation">.</span><span class="token function">catchMeIfYouCan</span><span class="token punctuation">(</span>input<span class="token punctuation">)</span>

    <span class="token spock-block">then:</span> <span class="token interpolation-string"><span class="token string">&quot;we get our stubbed response&quot;</span></span>
    result <span class="token operator">==</span> stubbedResponse
<span class="token punctuation">}</span>
</code></pre><div class="line-numbers" aria-hidden="true"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><p>在这个例子中，我们使用了简单的_Stub_，因为我们没有验证任何方法调用。</p><p>现在我们有了基本的测试，让我们看看如何捕获我们用来调用我们方法的参数。</p><p>首先，我们将声明一个方法作用域变量，以便在捕获参数时分配：</p><div class="language-groovy line-numbers-mode" data-ext="groovy" data-title="groovy"><pre class="language-groovy"><code><span class="token keyword">def</span> captured
</code></pre><div class="line-numbers" aria-hidden="true"><div class="line-number"></div></div></div><p>接下来，我们将静态_stubbedResponse_替换为Groovy_Closure_。<strong>当Spock的存根方法被调用时，Spock会向我们的_Closure_传递一个方法参数的_List_。</strong></p><p>让我们创建一个简单的_Closure_来捕获参数列表并将其分配给我们的_captured_变量：</p><div class="language-groovy line-numbers-mode" data-ext="groovy" data-title="groovy"><pre class="language-groovy"><code><span class="token punctuation">{</span> arguments <span class="token operator">-&gt;</span> captured <span class="token operator">=</span> arguments <span class="token punctuation">}</span>
</code></pre><div class="line-numbers" aria-hidden="true"><div class="line-number"></div></div></div><p>对于我们的断言，我们将断言捕获的参数列表中的第一个元素，即索引0，等于我们的输入：</p><div class="language-groovy line-numbers-mode" data-ext="groovy" data-title="groovy"><pre class="language-groovy"><code>captured<span class="token punctuation">[</span><span class="token number">0</span><span class="token punctuation">]</span> <span class="token operator">==</span> input
</code></pre><div class="line-numbers" aria-hidden="true"><div class="line-number"></div></div></div><p>所以，让我们使用我们的_captured_变量声明，用我们的参数捕获_Closure_替换我们的_stubbedResponse_，并添加我们的断言：</p><div class="language-groovy line-numbers-mode" data-ext="groovy" data-title="groovy"><pre class="language-groovy"><code><span class="token keyword">def</span> <span class="token interpolation-string"><span class="token string">&quot;given a Stub when we invoke it then we capture the argument&quot;</span></span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>
    <span class="token spock-block">given:</span> <span class="token interpolation-string"><span class="token string">&quot;an input&quot;</span></span>
    <span class="token keyword">def</span> input <span class="token operator">=</span> <span class="token interpolation-string"><span class="token string">&quot;Input&quot;</span></span>

    <span class="token spock-block">and:</span> <span class="token interpolation-string"><span class="token string">&quot;a variable and a Stub with a Closure to capture our arguments&quot;</span></span>
    <span class="token keyword">def</span> captured
    <span class="token annotation punctuation">@Subject</span>
    ArgumentCaptureSubject stubClass <span class="token operator">=</span> <span class="token function">Stub</span><span class="token punctuation">(</span><span class="token punctuation">)</span>
    stubClass<span class="token punctuation">.</span><span class="token function">catchMeIfYouCan</span><span class="token punctuation">(</span><span class="token number">_</span><span class="token punctuation">)</span> <span class="token operator">&gt;&gt;&gt;</span> <span class="token punctuation">{</span> arguments <span class="token operator">-&gt;</span> captured <span class="token operator">=</span> arguments <span class="token punctuation">}</span>

    <span class="token spock-block">when:</span> <span class="token interpolation-string"><span class="token string">&quot;we invoke our method&quot;</span></span>
    stubClass<span class="token punctuation">.</span><span class="token function">catchMeIfYouCan</span><span class="token punctuation">(</span>input<span class="token punctuation">)</span>

    <span class="token spock-block">then:</span> <span class="token interpolation-string"><span class="token string">&quot;we captured the method argument&quot;</span></span>
    captured<span class="token punctuation">[</span><span class="token number">0</span><span class="token punctuation">]</span> <span class="token operator">==</span> input
<span class="token punctuation">}</span>
</code></pre><div class="line-numbers" aria-hidden="true"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><p>当我们想要返回一个_stubbedResponse_以及捕获参数时，我们更新我们的_Closure_以返回它：</p><div class="language-groovy line-numbers-mode" data-ext="groovy" data-title="groovy"><pre class="language-groovy"><code><span class="token punctuation">{</span> arguments <span class="token operator">-&gt;</span> captured <span class="token operator">=</span> arguments<span class="token punctuation">;</span> <span class="token keyword">return</span> stubbedResponse <span class="token punctuation">}</span>

<span class="token punctuation">...</span>
<span class="token spock-block">then:</span> <span class="token interpolation-string"><span class="token string">&quot;what we captured matches the input and we got our stubbed response&quot;</span></span>
captured <span class="token operator">==</span> input
result <span class="token operator">==</span> stubbedResponse
</code></pre><div class="line-numbers" aria-hidden="true"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><p>请注意，尽管我们使用了“<em>return</em>”以清晰起见，但这并不严格必要，因为Groovy闭包默认返回最后执行语句的结果。</p><p>当我们只对捕获其中一个参数感兴趣时，<strong>我们可以通过在_Closure_中使用其索引来捕获我们想要的参数：</strong></p><div class="language-groovy line-numbers-mode" data-ext="groovy" data-title="groovy"><pre class="language-groovy"><code><span class="token punctuation">{</span> arguments <span class="token operator">-&gt;</span> captured <span class="token operator">=</span> arguments<span class="token punctuation">[</span><span class="token number">0</span><span class="token punctuation">]</span> <span class="token punctuation">}</span>

<span class="token punctuation">...</span>
<span class="token spock-block">then:</span> <span class="token interpolation-string"><span class="token string">&quot;what we captured matches the input&quot;</span></span>
captured <span class="token operator">==</span> input
</code></pre><div class="line-numbers" aria-hidden="true"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><p>在这种情况下，我们的_captured_变量将与我们的参数类型相同——一个_String_。</p><h2 id="_5-使用spies捕获" tabindex="-1"><a class="header-anchor" href="#_5-使用spies捕获"><span>5. 使用Spies捕获</span></a></h2><p><strong>当我们想要捕获一个值，但也希望方法继续执行时，我们在_Spy_的_callRealMethod()_中添加一个调用。</strong></p><p>让我们更新我们的测试以使用_Spy_而不是_Stub_，并在_Closure_中使用_Spy_的_callRealMethod()_：</p><div class="language-groovy line-numbers-mode" data-ext="groovy" data-title="groovy"><pre class="language-groovy"><code><span class="token keyword">def</span> <span class="token interpolation-string"><span class="token string">&quot;given a Spy when we invoke it then we capture the argument and then delegate to the real method&quot;</span></span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>
    <span class="token spock-block">given:</span> <span class="token interpolation-string"><span class="token string">&quot;an input string&quot;</span></span>
    <span class="token keyword">def</span> input <span class="token operator">=</span> <span class="token interpolation-string"><span class="token string">&quot;Input&quot;</span></span>

    <span class="token spock-block">and:</span> <span class="token interpolation-string"><span class="token string">&quot;a variable and a Spy with a Closure to capture the first argument and call the underlying method&quot;</span></span>
    <span class="token keyword">def</span> captured
    <span class="token annotation punctuation">@Subject</span>
    ArgumentCaptureSubject spyClass <span class="token operator">=</span> <span class="token function">Spy</span><span class="token punctuation">(</span><span class="token punctuation">)</span>
    spyClass<span class="token punctuation">.</span><span class="token function">catchMeIfYouCan</span><span class="token punctuation">(</span><span class="token number">_</span><span class="token punctuation">)</span> <span class="token operator">&gt;&gt;&gt;</span> <span class="token punctuation">{</span> arguments <span class="token operator">-&gt;</span> captured <span class="token operator">=</span> arguments<span class="token punctuation">[</span><span class="token number">0</span><span class="token punctuation">]</span><span class="token punctuation">;</span> <span class="token function">callRealMethod</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">}</span>

    <span class="token spock-block">when:</span> <span class="token interpolation-string"><span class="token string">&quot;we invoke our method&quot;</span></span>
    <span class="token keyword">def</span> result <span class="token operator">=</span> spyClass<span class="token punctuation">.</span><span class="token function">catchMeIfYouCan</span><span class="token punctuation">(</span>input<span class="token punctuation">)</span>

    <span class="token spock-block">then:</span> <span class="token interpolation-string"><span class="token string">&quot;what we captured matches the input and our result comes from the real method&quot;</span></span>
    captured <span class="token operator">==</span> input
    result <span class="token operator">==</span> <span class="token interpolation-string"><span class="token string">&quot;Received Input&quot;</span></span>
<span class="token punctuation">}</span>
</code></pre><div class="line-numbers" aria-hidden="true"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><p>在这里，我们捕获了输入参数，而不影响方法的返回值。</p><p><strong>当我们想要在将其传递给真实方法之前更改捕获的参数时，我们在内部更新它，然后使用_Spy_的_callRealMethodWithArgs_来传递我们更新后的参数。</strong></p><p>所以，让我们更新我们的_Closure_，在将其传递给真实方法之前，将“Tampered: ”添加到我们的_String_之前：</p><div class="language-groovy line-numbers-mode" data-ext="groovy" data-title="groovy"><pre class="language-groovy"><code>spyClass<span class="token punctuation">.</span><span class="token function">catchMeIfYouCan</span><span class="token punctuation">(</span><span class="token number">_</span><span class="token punctuation">)</span> <span class="token operator">&gt;&gt;&gt;</span> <span class="token punctuation">{</span> arguments <span class="token operator">-&gt;</span> captured <span class="token operator">=</span> arguments<span class="token punctuation">[</span><span class="token number">0</span><span class="token punctuation">]</span><span class="token punctuation">;</span> <span class="token function">callRealMethodWithArgs</span><span class="token punctuation">(</span><span class="token string">&#39;Tampered:&#39;</span> <span class="token operator">+</span> captured<span class="token punctuation">)</span> <span class="token punctuation">}</span>
</code></pre><div class="line-numbers" aria-hidden="true"><div class="line-number"></div></div></div><p>让我们更新我们的断言，以期望我们被篡改的结果：</p><div class="language-groovy line-numbers-mode" data-ext="groovy" data-title="groovy"><pre class="language-groovy"><code>result <span class="token operator">==</span> <span class="token interpolation-string"><span class="token string">&quot;Received Tampered:Input&quot;</span></span>
</code></pre><div class="line-numbers" aria-hidden="true"><div class="line-number"></div></div></div><h2 id="_6-使用注入的mock捕获参数" tabindex="-1"><a class="header-anchor" href="#_6-使用注入的mock捕获参数"><span>6. 使用注入的Mock捕获参数</span></a></h2><p>现在我们已经看到了如何使用Spock的模拟框架来捕获参数，让我们将这种技术应用到一个我们可以模拟的依赖类的类中。</p><p>首先，让我们创建一个_ArgumentCaptureDependency_类，我们的主体可以调用它的一个简单的_catchMe()<em>方法，该方法接受并修改一个_String</em>：</p><div class="language-java line-numbers-mode" data-ext="java" data-title="java"><pre class="language-java"><code><span class="token keyword">public</span> <span class="token keyword">class</span> <span class="token class-name">ArgumentCaptureDependency</span> <span class="token punctuation">{</span>
    <span class="token keyword">public</span> <span class="token class-name">String</span> <span class="token function">catchMe</span><span class="token punctuation">(</span><span class="token class-name">String</span> input<span class="token punctuation">)</span> <span class="token punctuation">{</span>
        <span class="token keyword">return</span> <span class="token string">&quot;***&quot;</span> <span class="token operator">+</span> input <span class="token operator">+</span> <span class="token string">&quot;***&quot;</span><span class="token punctuation">;</span>
    <span class="token punctuation">}</span>
<span class="token punctuation">}</span>
</code></pre><div class="line-numbers" aria-hidden="true"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><p>现在，让我们更新_ArgumentCaptureSubject_类，添加一个构造函数，接受我们的_ArgumentCaptureDependency_。让我们还添加一个_callOtherClass_方法，该方法不接受参数，并使用参数调用我们的_ArgumentCaptureDependency_的_catchMe()_方法：</p><div class="language-java line-numbers-mode" data-ext="java" data-title="java"><pre class="language-java"><code><span class="token keyword">public</span> <span class="token keyword">class</span> <span class="token class-name">ArgumentCaptureSubject</span> <span class="token punctuation">{</span>
    <span class="token class-name">ArgumentCaptureDependency</span> calledClass<span class="token punctuation">;</span>

    <span class="token keyword">public</span> <span class="token class-name">ArgumentCaptureSubject</span><span class="token punctuation">(</span><span class="token class-name">ArgumentCaptureDependency</span> calledClass<span class="token punctuation">)</span> <span class="token punctuation">{</span>
        <span class="token keyword">this</span><span class="token punctuation">.</span>calledClass <span class="token operator">=</span> calledClass<span class="token punctuation">;</span>
    <span class="token punctuation">}</span>

    <span class="token keyword">public</span> <span class="token class-name">String</span> <span class="token function">callOtherClass</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>
        <span class="token keyword">return</span> calledClass<span class="token punctuation">.</span><span class="token function">catchMe</span><span class="token punctuation">(</span><span class="token string">&quot;Internal Parameter&quot;</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
    <span class="token punctuation">}</span>
<span class="token punctuation">}</span>
</code></pre><div class="line-numbers" aria-hidden="true"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><p>最后，让我们像以前一样创建一个测试。这次，让我们在创建它时将一个_Spy_注入我们的_ArgumentCaptureSubject_，以便我们也可以_callRealMethod()_并比较结果：</p><div class="language-groovy line-numbers-mode" data-ext="groovy" data-title="groovy"><pre class="language-groovy"><code><span class="token keyword">def</span> <span class="token interpolation-string"><span class="token string">&quot;given an internal method call when we invoke our subject then we capture the internal argument and return the result of the real method&quot;</span></span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>
    <span class="token spock-block">given:</span> <span class="token interpolation-string"><span class="token string">&quot;a mock and a variable for our captured argument&quot;</span></span>
    ArgumentCaptureDependency spyClass <span class="token operator">=</span> <span class="token function">Spy</span><span class="token punctuation">(</span><span class="token punctuation">)</span>
    <span class="token keyword">def</span> captured
    spyClass<span class="token punctuation">.</span><span class="token function">catchMe</span><span class="token punctuation">(</span><span class="token number">_</span><span class="token punctuation">)</span> <span class="token operator">&gt;&gt;&gt;</span> <span class="token punctuation">{</span> arguments <span class="token operator">-&gt;</span> captured <span class="token operator">=</span> arguments<span class="token punctuation">[</span><span class="token number">0</span><span class="token punctuation">]</span><span class="token punctuation">;</span> <span class="token function">callRealMethod</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">}</span>

    <span class="token spock-block">and:</span> <span class="token interpolation-string"><span class="token string">&quot;our subject with an injected Spy&quot;</span></span>
    <span class="token annotation punctuation">@Subject</span> argumentCaptureSubject <span class="token operator">=</span> <span class="token keyword">new</span> <span class="token class-name">ArgumentCaptureSubject</span><span class="token punctuation">(</span>spyClass<span class="token punctuation">)</span>

    <span class="token spock-block">when:</span> <span class="token interpolation-string"><span class="token string">&quot;we invoke our method&quot;</span></span>
    <span class="token keyword">def</span> result <span class="token operator">=</span> argumentCaptureSubject<span class="token punctuation">.</span><span class="token function">callOtherClass</span><span class="token punctuation">(</span><span class="token punctuation">)</span>

    <span class="token spock-block">then:</span> <span class="token interpolation-string"><span class="token string">&quot;what we captured matches the internal method argument&quot;</span></span>
    captured <span class="token operator">==</span> <span class="token interpolation-string"><span class="token string">&quot;Internal Parameter&quot;</span></span>
    result <span class="token operator">==</span> <span class="token interpolation-string"><span class="token string">&quot;***Internal Parameter***&quot;</span></span>
<span class="token punctuation">}</span>
</code></pre><div class="line-numbers" aria-hidden="true"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><p>我们的测试捕获了内部参数“<em>Internal Parameter</em>”。此外，我们对_Spy_的_callRealMethod_的调用确保我们没有影响方法的结果：<em>“<em><strong>Internal Parameter</strong></em>”</em>。</p><p>当我们不需要返回真实结果时，我们可以简单地使用_Stub_或_Mock_。</p><p><strong>请注意，当我们测试Spring应用程序时，我们可以使用Spock的@ <em>SpringBean_注解注入我们的_Mock</em>。</strong></p><h2 id="_7-从多次调用中捕获参数" tabindex="-1"><a class="header-anchor" href="#_7-从多次调用中捕获参数"><span>7. 从多次调用中捕获参数</span></a></h2><p>有时，我们的代码多次调用一个方法，我们想要捕获每次调用的值。</p><p>所以，让我们向我们的_ArgumentCaptureSubject_的_callOtherClass()_方法添加一个_String_参数。我们将使用不同的参数调用它并捕获它们。</p><div class="language-java line-numbers-mode" data-ext="java" data-title="java"><pre class="language-java"><code><span class="token keyword">public</span> <span class="token class-name">String</span> <span class="token function">callOtherClass</span><span class="token punctuation">(</span><span class="token class-name">String</span> input<span class="token punctuation">)</span> <span class="token punctuation">{</span>
    <span class="token keyword">return</span> calledClass<span class="token punctuation">.</span><span class="token function">catchMe</span><span class="token punctuation">(</span>input<span class="token punctuation">)</span><span class="token punctuation">;</span>
<span class="token punctuation">}</span>
</code></pre><div class="line-numbers" aria-hidden="true"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><p>我们需要一个集合来捕获每次调用的参数。所以，我们将声明一个_capturedStrings_变量作为一个_ArrayList_：</p><div class="language-groovy line-numbers-mode" data-ext="groovy" data-title="groovy"><pre class="language-groovy"><code><span class="token keyword">def</span> capturedStrings <span class="token operator">=</span> <span class="token keyword">new</span> <span class="token class-name">ArrayList</span><span class="token punctuation">(</span><span class="token punctuation">)</span>
</code></pre><div class="line-numbers" aria-hidden="true"><div class="line-number"></div></div></div><p>现在，让我们创建我们的测试，并让它两次调用我们的_callOtherClass()_，首先使用“First”作为参数，然后使用“Second”：</p><div class="language-groovy line-numbers-mode" data-ext="groovy" data-title="groovy"><pre class="language-groovy"><code><span class="token keyword">def</span> <span class="token interpolation-string"><span class="token string">&quot;given a dynamic Mock when we invoke our subject then we capture the argument for each invocation&quot;</span></span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>
    <span class="token spock-block">given:</span> <span class="token interpolation-string"><span class="token string">&quot;a variable for our captured arguments and a mock to capture them&quot;</span></span>
    <span class="token keyword">def</span> capturedStrings <span class="token operator">=</span> <span class="token keyword">new</span> <span class="token class-name">ArrayList</span><span class="token punctuation">(</span><span class="token punctuation">)</span>
    ArgumentCaptureDependency mockClass <span class="token operator">=</span> <span class="token function">Mock</span><span class="token punctuation">(</span><span class="token punctuation">)</span>

    <span class="token spock-block">and:</span> <span class="token interpolation-string"><span class="token string">&quot;our subject&quot;</span></span>
    <span class="token annotation punctuation">@Subject</span> argumentCaptureSubject <span class="token operator">=</span> <span class="token keyword">new</span> <span class="token class-name">ArgumentCaptureSubject</span><span class="token punctuation">(</span>mockClass<span class="token punctuation">)</span>

    <span class="token spock-block">when:</span> <span class="token interpolation-string"><span class="token string">&quot;we invoke our method&quot;</span></span>
    argumentCaptureSubject<span class="token punctuation">.</span><span class="token function">callOtherClass</span><span class="token punctuation">(</span><span class="token interpolation-string"><span class="token string">&quot;First&quot;</span></span><span class="token punctuation">)</span>
    argumentCaptureSubject<span class="token punctuation">.</span><span class="token function">callOtherClass</span><span class="token punctuation">(</span><span class="token interpolation-string"><span class="token string">&quot;Second&quot;</span></span><span class="token punctuation">)</span>
<span class="token punctuation">}</span>
</code></pre><div class="line-numbers" aria-hidden="true"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><p>现在，让我们添加一个_Closure_到我们的Mock，以捕获每次调用的参数并将其添加到我们的列表中。让我们还让我们的_Mock_通过将“2 *”前缀到我们的语句来验证我们的方法被调用了两次：</p><div class="language-groovy line-numbers-mode" data-ext="groovy" data-title="groovy"><pre class="language-groovy"><code><span class="token spock-block">then:</span> <span class="token interpolation-string"><span class="token string">&quot;our method was called twice and captured the argument&quot;</span></span>
<span class="token number">2</span> <span class="token operator">*</span> mockClass<span class="token punctuation">.</span><span class="token function">catchMe</span><span class="token punctuation">(</span><span class="token number">_</span> <span class="token keyword">as</span> String<span class="token punctuation">)</span> <span class="token operator">&gt;&gt;&gt;</span> <span class="token punctuation">{</span> arguments <span class="token operator">-&gt;</span> capturedStrings<span class="token punctuation">.</span><span class="token function">add</span><span class="token punctuation">(</span>arguments<span class="token punctuation">[</span><span class="token number">0</span><span class="token punctuation">]</span><span class="token punctuation">)</span> <span class="token punctuation">}</span>
</code></pre><div class="line-numbers" aria-hidden="true"><div class="line-number"></div><div class="line-number"></div></div></div><p>最后，让我们断言我们以正确的顺序捕获了两个参数：</p><div class="language-groovy line-numbers-mode" data-ext="groovy" data-title="groovy"><pre class="language-groovy"><code><span class="token spock-block">and:</span> <span class="token interpolation-string"><span class="token string">&quot;we captured the list and it contains an entry for both of our input values&quot;</span></span>
capturedStrings<span class="token punctuation">[</span><span class="token number">0</span><span class="token punctuation">]</span> <span class="token operator">==</span> <span class="token interpolation-string"><span class="token string">&quot;First&quot;</span></span>
capturedStrings<span class="token punctuation">[</span><span class="token number">1</span><span class="token punctuation">]</span> <span class="token operator">==</span> <span class="token interpolation-string"><span class="token string">&quot;Second&quot;</span></span>
</code></pre><div class="line-numbers" aria-hidden="true"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><p>当我们不关心顺序时，我们可以使用_List_的_contains_方法：</p><div class="language-groovy line-numbers-mode" data-ext="groovy" data-title="groovy"><pre class="language-groovy"><code>capturedStrings<span class="token punctuation">.</span><span class="token function">contains</span><span class="token punctuation">(</span><span class="token interpolation-string"><span class="token string">&quot;First&quot;</span></span><span class="token punctuation">)</span>
</code></pre><div class="line-numbers" aria-hidden="true"><div class="line-number"></div></div></div><h2 id="_8-使用多个-then-块" tabindex="-1"><a class="header-anchor" href="#_8-使用多个-then-块"><span>8. 使用多个_Then_块</span></a></h2><p>有时，我们想使用相同的方法断言不同参数的调用序列，但不需要捕获它们。Spock允许在同一个_then_块中的断言以任何顺序进行验证，所以我们编写它们的顺序并不重要。然而，我们可以通过添加多个_then_块来强制执行顺序。</p><p><strong>Spock验证一个_then_块中的断言在下一个_then_块中的断言之前满足。</strong></p><p>所以，让我们添加两个_then_块来验证我们的方法使用正确的参数以正确的顺序被调用：</p><div class="language-groovy line-numbers-mode" data-ext="groovy" data-title="groovy"><pre class="language-groovy"><code><span class="token keyword">def</span> <span class="token interpolation-string"><span class="token string">&quot;given a Mock when we invoke our subject twice then our Mock verifies the sequence&quot;</span></span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>
    <span class="token spock-block">given:</span> <span class="token interpolation-string"><span class="token string">&quot;a mock&quot;</span></span>
    ArgumentCaptureDependency mockClass <span class="token operator">=</span> <span class="token function">Mock</span><span class="token punctuation">(</span><span class="token punctuation">)</span>

    <span class="token spock-block">and:</span> <span class="token interpolation-string"><span class="token string">&quot;our subject&quot;</span></span>
    <span class="token annotation punctuation">@Subject</span> argumentCaptureSubject <span class="token operator">=</span> <span class="token keyword">new</span> <span class="token class-name">ArgumentCaptureSubject</span><span class="token punctuation">(</span>mockClass<span class="token punctuation">)</span>

    <span class="token spock-block">when:</span> <span class="token interpolation-string"><span class="token string">&quot;we invoke our method&quot;</span></span>
    argumentCaptureSubject<span class="token punctuation">.</span><span class="token function">callOtherClass</span><span class="token punctuation">(</span><span class="token interpolation-string"><span class="token string">&quot;First&quot;</span></span><span class="token punctuation">)</span>
    argumentCaptureSubject<span class="token punctuation">.</span><span class="token function">callOtherClass</span><span class="token punctuation">(</span><span class="token interpolation-string"><span class="token string">&quot;Second&quot;</span></span><span class="token punctuation">)</span>

    <span class="token spock-block">then:</span> <span class="token interpolation-string"><span class="token string">&quot;we invoked our Mock with &#39;First&#39; the first time&quot;</span></span>
    <span class="token number">1</span> <span class="token operator">*</span> mockClass<span class="token punctuation">.</span><span class="token function">catchMe</span><span class="token punctuation">(</span><span class="token interpolation-string"><span class="token string">&quot;First&quot;</span></span><span class="token punctuation">)</span>

    <span class="token spock-block">then:</span> <span class="token interpolation-string"><span class="token string">&quot;we invoked our Mock with &#39;Second&#39; the next time&quot;</span></span>
    <span class="token number">1</span> <span class="token operator">*</span> mockClass<span class="token punctuation">.</span><span class="token function">catchMe</span><span class="token punctuation">(</span><span class="token interpolation-string"><span class="token string">&quot;Second&quot;</span></span><span class="token punctuation">)</span>
<span class="token punctuation">}</span>
</code></pre><div class="line-numbers" aria-hidden="true"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><p>当我们的调用顺序错误时，比如我们首先调用_callOtherClass(&quot;Second&quot;)_，Spock会给我们一个有用的消息：</p><div class="language-plaintext line-numbers-mode" data-ext="plaintext" data-title="plaintext"><pre class="language-plaintext"><code>Wrong invocation order for:

1 * mockClass.catchMe(&quot;First&quot;)   (1 invocation)

Last invocation: mockClass.catchMe(&#39;First&#39;)

Previous invocation:
    mockClass.catchMe(&#39;Second&#39;)
</code></pre><div class="line-numbers" aria-hidden="true"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><h2 id="_9-结论" tabindex="-1"><a class="header-anchor" href="#_9-结论"><span>9. 结论</span></a></h2><p>在本教程中，我们学习了如何使用Spock的_Stub_ s、<em>Mock</em> s和_Spies_使用_Closure_ s来捕获方法参数。接下来，我们学习了如何使用_Spy_在调用真实方法之前更改捕获的参数。我们还学习了如何收集当方法被多次调用时的参数。最后，作为捕获参数的替代方案，我们学习了如何使用多个_then_块来检查我们的调用是否以正确的顺序发生。</p><p>像往常一样，本文的源代码可以在GitHub上找到。</p><p>OK</p>`,74),o=[p];function c(i,l){return a(),s("div",null,o)}const d=n(e,[["render",c],["__file","2024-06-21-Capturing Method Arguments When Running Spock Tests.html.vue"]]),k=JSON.parse('{"path":"/posts/baeldung/Archive/2024-06-21-Capturing%20Method%20Arguments%20When%20Running%20Spock%20Tests.html","title":"使用Spock测试捕获方法参数","lang":"zh-CN","frontmatter":{"date":"2024-06-21T00:00:00.000Z","category":["Java","Spock"],"tag":["测试","Groovy"],"head":[["meta",{"name":"keywords","content":"Spock测试, 参数捕获, 测试驱动开发"}],["meta",{"property":"og:url","content":"https://www.kahen.xyz/posts/baeldung/Archive/2024-06-21-Capturing%20Method%20Arguments%20When%20Running%20Spock%20Tests.html"}],["meta",{"property":"og:site_name","content":"Baeldung 中文网"}],["meta",{"property":"og:title","content":"使用Spock测试捕获方法参数"}],["meta",{"property":"og:description","content":"使用Spock测试捕获方法参数 当我们测试代码时，有时我们想要捕获传递给方法的参数。 在本教程中，我们将学习如何使用Spock测试中的_Stubs_、_Mocks_和_Spies_来捕获参数，并检查我们捕获的内容。我们还将学习如何验证对同一_Mock_的多次调用使用不同的参数，并断言这些调用的顺序。 2. 我们测试的主题 首先，我们需要一个接受我们想要..."}],["meta",{"property":"og:type","content":"article"}],["meta",{"property":"og:locale","content":"zh-CN"}],["meta",{"property":"og:updated_time","content":"2024-06-21T09:54:56.000Z"}],["meta",{"property":"article:author","content":"Kahen"}],["meta",{"property":"article:tag","content":"测试"}],["meta",{"property":"article:tag","content":"Groovy"}],["meta",{"property":"article:published_time","content":"2024-06-21T00:00:00.000Z"}],["meta",{"property":"article:modified_time","content":"2024-06-21T09:54:56.000Z"}],["script",{"type":"application/ld+json"},"{\\"@context\\":\\"https://schema.org\\",\\"@type\\":\\"Article\\",\\"headline\\":\\"使用Spock测试捕获方法参数\\",\\"image\\":[\\"\\"],\\"datePublished\\":\\"2024-06-21T00:00:00.000Z\\",\\"dateModified\\":\\"2024-06-21T09:54:56.000Z\\",\\"author\\":[{\\"@type\\":\\"Person\\",\\"name\\":\\"Kahen\\",\\"url\\":\\"https://www.kahen.xyz\\"}]}"]],"description":"使用Spock测试捕获方法参数 当我们测试代码时，有时我们想要捕获传递给方法的参数。 在本教程中，我们将学习如何使用Spock测试中的_Stubs_、_Mocks_和_Spies_来捕获参数，并检查我们捕获的内容。我们还将学习如何验证对同一_Mock_的多次调用使用不同的参数，并断言这些调用的顺序。 2. 我们测试的主题 首先，我们需要一个接受我们想要..."},"headers":[{"level":2,"title":"2. 我们测试的主题","slug":"_2-我们测试的主题","link":"#_2-我们测试的主题","children":[]},{"level":2,"title":"3. 准备我们的数据驱动测试","slug":"_3-准备我们的数据驱动测试","link":"#_3-准备我们的数据驱动测试","children":[]},{"level":2,"title":"5. 使用Spies捕获","slug":"_5-使用spies捕获","link":"#_5-使用spies捕获","children":[]},{"level":2,"title":"6. 使用注入的Mock捕获参数","slug":"_6-使用注入的mock捕获参数","link":"#_6-使用注入的mock捕获参数","children":[]},{"level":2,"title":"7. 从多次调用中捕获参数","slug":"_7-从多次调用中捕获参数","link":"#_7-从多次调用中捕获参数","children":[]},{"level":2,"title":"8. 使用多个_Then_块","slug":"_8-使用多个-then-块","link":"#_8-使用多个-then-块","children":[]},{"level":2,"title":"9. 结论","slug":"_9-结论","link":"#_9-结论","children":[]}],"git":{"createdTime":1718963696000,"updatedTime":1718963696000,"contributors":[{"name":"Lance Li","email":"lance.jx.li@gtomato.com","commits":1}]},"readingTime":{"minutes":7.84,"words":2352},"filePathRelative":"posts/baeldung/Archive/2024-06-21-Capturing Method Arguments When Running Spock Tests.md","localizedDate":"2024年6月21日","excerpt":"\\n<p>当我们测试代码时，有时我们想要捕获传递给方法的参数。</p>\\n<p>在本教程中，我们将学习如何使用Spock测试中的_Stubs_、_Mocks_和_Spies_来捕获参数，并检查我们捕获的内容。我们还将学习如何验证对同一_Mock_的多次调用使用不同的参数，并断言这些调用的顺序。</p>\\n<h2>2. 我们测试的主题</h2>\\n<p>首先，我们需要一个接受我们想要捕获的单个参数或参数的方法。</p>\\n<p>让我们创建一个_ArgumentCaptureSubject_类，它有一个_catchMeIfYouCan()_方法，该方法接受一个_String_并返回它，前面加上“Received ”：</p>","autoDesc":true}');export{d as comp,k as data};
