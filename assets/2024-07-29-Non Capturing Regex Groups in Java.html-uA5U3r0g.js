import{_ as n}from"./plugin-vue_export-helper-DlAUqK2U.js";import{c as a,o as s,a as t}from"./app-DFhKiB50.js";const e={},p=t(`<hr><h1 id="java正则表达式中的非捕获组" tabindex="-1"><a class="header-anchor" href="#java正则表达式中的非捕获组"><span>Java正则表达式中的非捕获组</span></a></h1><h2 id="_1-概述" tabindex="-1"><a class="header-anchor" href="#_1-概述"><span>1. 概述</span></a></h2><p>非捕获组是Java正则表达式中的重要结构。**它们创建了一个作为单一单元工作的子模式，但不会保存匹配的字符序列。**在本教程中，我们将探讨如何在Java正则表达式中使用非捕获组。</p><h2 id="_2-正则表达式组" tabindex="-1"><a class="header-anchor" href="#_2-正则表达式组"><span>2. 正则表达式组</span></a></h2><p>正则表达式组可以是两种类型之一：捕获和非捕获。</p><p>捕获组会保存匹配的字符序列。它们的值可以作为模式中的反向引用使用，或者稍后在代码中检索。</p><p>尽管它们不会保存匹配的字符序列，<strong>非捕获组可以改变组内的模式匹配修饰符。一些非捕获组甚至可以在成功匹配子模式后丢弃回溯信息。</strong></p><p>让我们通过一些非捕获组的示例来深入了解。</p><p>非捕获组是通过操作符“ <em>(?:X)</em>”创建的。“ <em>X</em>”是组的模式：</p><div class="language-java line-numbers-mode" data-ext="java" data-title="java"><pre class="language-java"><code><span class="token class-name">Pattern</span><span class="token punctuation">.</span><span class="token function">compile</span><span class="token punctuation">(</span><span class="token string">&quot;[^:]+://(?:[.a-z]+/?)+&quot;</span><span class="token punctuation">)</span>
</code></pre><div class="line-numbers" aria-hidden="true"><div class="line-number"></div></div></div><p>这个模式有一个单一的非捕获组。如果它像URL一样，它将匹配一个值。一个完整的URL正则表达式会更复杂。我们使用一个简单的模式来专注于非捕获组。</p><p>模式 <em>“\\[^:\\]:</em>” 匹配协议 — 例如，“ <em>http://</em>”。非捕获组“ <em>(?:\\[.a-z\\]+/?)</em>”匹配带有可选斜杠的域名。由于“ <em>+</em>”操作符匹配这个模式的一个或多个出现，我们也会匹配后续的路径段。让我们在一个URL上测试这个模式：</p><div class="language-java line-numbers-mode" data-ext="java" data-title="java"><pre class="language-java"><code><span class="token class-name">Pattern</span> simpleUrlPattern <span class="token operator">=</span> <span class="token class-name">Pattern</span><span class="token punctuation">.</span><span class="token function">compile</span><span class="token punctuation">(</span><span class="token string">&quot;[^:]+://(?:[.a-z]+/?)+&quot;</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
<span class="token class-name">Matcher</span> urlMatcher
  <span class="token operator">=</span> simpleUrlPattern<span class="token punctuation">.</span><span class="token function">matcher</span><span class="token punctuation">(</span><span class="token string">&quot;http://www.microsoft.com/some/other/url/path&quot;</span><span class="token punctuation">)</span><span class="token punctuation">;</span>

<span class="token class-name">Assertions</span><span class="token punctuation">.</span><span class="token function">assertThat</span><span class="token punctuation">(</span>urlMatcher<span class="token punctuation">.</span><span class="token function">matches</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">.</span><span class="token function">isTrue</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
</code></pre><div class="line-numbers" aria-hidden="true"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><p>让我们看看当我们尝试检索匹配的文本时会发生什么：</p><div class="language-java line-numbers-mode" data-ext="java" data-title="java"><pre class="language-java"><code><span class="token class-name">Pattern</span> simpleUrlPattern <span class="token operator">=</span> <span class="token class-name">Pattern</span><span class="token punctuation">.</span><span class="token function">compile</span><span class="token punctuation">(</span><span class="token string">&quot;[^:]+://(?:[.a-z]+/?)+&quot;</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
<span class="token class-name">Matcher</span> urlMatcher <span class="token operator">=</span> simpleUrlPattern<span class="token punctuation">.</span><span class="token function">matcher</span><span class="token punctuation">(</span><span class="token string">&quot;http://www.microsoft.com/&quot;</span><span class="token punctuation">)</span><span class="token punctuation">;</span>

<span class="token class-name">Assertions</span><span class="token punctuation">.</span><span class="token function">assertThat</span><span class="token punctuation">(</span>urlMatcher<span class="token punctuation">.</span><span class="token function">matches</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">.</span><span class="token function">isTrue</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
<span class="token class-name">Assertions</span><span class="token punctuation">.</span><span class="token function">assertThatThrownBy</span><span class="token punctuation">(</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token operator">-&gt;</span> urlMatcher<span class="token punctuation">.</span><span class="token function">group</span><span class="token punctuation">(</span><span class="token number">1</span><span class="token punctuation">)</span><span class="token punctuation">)</span>
  <span class="token punctuation">.</span><span class="token function">isInstanceOf</span><span class="token punctuation">(</span><span class="token class-name">IndexOutOfBoundsException</span><span class="token punctuation">.</span><span class="token keyword">class</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
</code></pre><div class="line-numbers" aria-hidden="true"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><p>正则表达式被编译成一个 <em>java.util.Pattern</em> 对象。然后，我们创建一个 <em>java.util.Matcher</em> 来将我们的 <em>Pattern</em> 应用到提供的值。</p><p>接下来，我们断言 <em>matches()</em> 的结果返回 <em>true</em>。</p><p>我们使用一个非捕获组来匹配URL中的域名。**由于非捕获组不保存匹配的文本，我们无法检索匹配的文本 <em>“www.microsoft.com/”</em>。**尝试检索域名将导致 <em>IndexOutOfBoundsException</em>。</p><h3 id="_3-1-内联修饰符" tabindex="-1"><a class="header-anchor" href="#_3-1-内联修饰符"><span>3.1. 内联修饰符</span></a></h3><p>**正则表达式是区分大小写的。**如果我们将我们的模式应用于一个混合大小写的URL，匹配将失败：</p><div class="language-java line-numbers-mode" data-ext="java" data-title="java"><pre class="language-java"><code><span class="token class-name">Pattern</span> simpleUrlPattern
  <span class="token operator">=</span> <span class="token class-name">Pattern</span><span class="token punctuation">.</span><span class="token function">compile</span><span class="token punctuation">(</span><span class="token string">&quot;[^:]+://(?:[.a-z]+/?)+&quot;</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
<span class="token class-name">Matcher</span> urlMatcher
  <span class="token operator">=</span> simpleUrlPattern<span class="token punctuation">.</span><span class="token function">matcher</span><span class="token punctuation">(</span><span class="token string">&quot;http://www.Microsoft.com/&quot;</span><span class="token punctuation">)</span><span class="token punctuation">;</span>

<span class="token class-name">Assertions</span><span class="token punctuation">.</span><span class="token function">assertThat</span><span class="token punctuation">(</span>urlMatcher<span class="token punctuation">.</span><span class="token function">matches</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">.</span><span class="token function">isFalse</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
</code></pre><div class="line-numbers" aria-hidden="true"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><p>在这种情况下，我们想要匹配大写字母，我们可以尝试几种选项。</p><p>一个选项是将大写字符范围添加到模式中：</p><div class="language-java line-numbers-mode" data-ext="java" data-title="java"><pre class="language-java"><code><span class="token class-name">Pattern</span><span class="token punctuation">.</span><span class="token function">compile</span><span class="token punctuation">(</span><span class="token string">&quot;[^:]+://(?:[.a-zA-Z]+/?)+&quot;</span><span class="token punctuation">)</span>
</code></pre><div class="line-numbers" aria-hidden="true"><div class="line-number"></div></div></div><p>另一个选项是使用修饰符标志。因此，我们可以编译正则表达式使其不区分大小写：</p><div class="language-java line-numbers-mode" data-ext="java" data-title="java"><pre class="language-java"><code><span class="token class-name">Pattern</span><span class="token punctuation">.</span><span class="token function">compile</span><span class="token punctuation">(</span><span class="token string">&quot;[^:]+://(?:[.a-z]+/?)+&quot;</span><span class="token punctuation">,</span> <span class="token class-name">Pattern</span><span class="token punctuation">.</span><span class="token constant">CASE_INSENSITIVE</span><span class="token punctuation">)</span>
</code></pre><div class="line-numbers" aria-hidden="true"><div class="line-number"></div></div></div><p>非捕获组允许第三种选项：**我们可以仅为组更改修饰符标志。**让我们向组添加不区分大小写的修饰符标志（“ <em>i</em>”）：</p><div class="language-java line-numbers-mode" data-ext="java" data-title="java"><pre class="language-java"><code><span class="token class-name">Pattern</span><span class="token punctuation">.</span><span class="token function">compile</span><span class="token punctuation">(</span><span class="token string">&quot;[^:]+://(?i:[.a-z]+/?)+&quot;</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
</code></pre><div class="line-numbers" aria-hidden="true"><div class="line-number"></div></div></div><p>现在我们已经使组不区分大小写，让我们将这个模式应用于一个混合大小写的URL：</p><div class="language-java line-numbers-mode" data-ext="java" data-title="java"><pre class="language-java"><code><span class="token class-name">Pattern</span> scopedCaseInsensitiveUrlPattern
  <span class="token operator">=</span> <span class="token class-name">Pattern</span><span class="token punctuation">.</span><span class="token function">compile</span><span class="token punctuation">(</span><span class="token string">&quot;[^:]+://(?i:[.a-z]+/?)+&quot;</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
<span class="token class-name">Matcher</span> urlMatcher
  <span class="token operator">=</span> scopedCaseInsensitiveUrlPattern<span class="token punctuation">.</span><span class="token function">matcher</span><span class="token punctuation">(</span><span class="token string">&quot;http://www.Microsoft.com/&quot;</span><span class="token punctuation">)</span><span class="token punctuation">;</span>

<span class="token class-name">Assertions</span><span class="token punctuation">.</span><span class="token function">assertThat</span><span class="token punctuation">(</span>urlMatcher<span class="token punctuation">.</span><span class="token function">matches</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">.</span><span class="token function">isTrue</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
</code></pre><div class="line-numbers" aria-hidden="true"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><p>**当一个模式被编译为不区分大小写时，我们可以通过在修饰符前面添加“-”操作符来关闭它。**让我们将这个模式应用于另一个混合大小写的URL：</p><div class="language-java line-numbers-mode" data-ext="java" data-title="java"><pre class="language-java"><code><span class="token class-name">Pattern</span> scopedCaseSensitiveUrlPattern
  <span class="token operator">=</span> <span class="token class-name">Pattern</span><span class="token punctuation">.</span><span class="token function">compile</span><span class="token punctuation">(</span><span class="token string">&quot;[^:]+://(?-i:[.a-z]+/?)+/ending-path&quot;</span><span class="token punctuation">,</span> <span class="token class-name">Pattern</span><span class="token punctuation">.</span><span class="token constant">CASE_INSENSITIVE</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
<span class="token class-name">Matcher</span> urlMatcher
  <span class="token operator">=</span> scopedCaseSensitiveUrlPattern<span class="token punctuation">.</span><span class="token function">matcher</span><span class="token punctuation">(</span><span class="token string">&quot;http://www.Microsoft.com/ending-path&quot;</span><span class="token punctuation">)</span><span class="token punctuation">;</span>

<span class="token class-name">Assertions</span><span class="token punctuation">.</span><span class="token function">assertThat</span><span class="token punctuation">(</span>urlMatcher<span class="token punctuation">.</span><span class="token function">matches</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">.</span><span class="token function">isFalse</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
</code></pre><div class="line-numbers" aria-hidden="true"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><p>在这个示例中，最终的路径段“ <em>/ending-path</em>”是不区分大小写的。模式的“ <em>/ending-path</em>”部分将匹配大写和小写字符。</p><p>当我们在组内关闭不区分大小写的选项时，非捕获组仅支持小写字符。因此，混合大小写的域名不匹配。</p><h2 id="_4-独立非捕获组" tabindex="-1"><a class="header-anchor" href="#_4-独立非捕获组"><span>4. 独立非捕获组</span></a></h2><p>独立非捕获组是一种正则表达式组。这些组**在找到成功的匹配后丢弃回溯信息。**当使用这种类型的组时，我们需要意识到回溯何时会发生。否则，我们的模式可能不会匹配我们认为应该匹配的值。</p><p>回溯是不确定有限自动机（NFA）正则表达式引擎的一个特性。**当引擎无法匹配文本时，NFA引擎可以探索模式中的替代方案。**引擎会在耗尽所有可用的替代方案后失败匹配。我们仅涉及与独立非捕获组相关的回溯。</p><p>独立非捕获组是通过操作符“ <em>(?\\u003eX)</em>”创建的，其中 <em>X</em> 是子模式：</p><div class="language-java line-numbers-mode" data-ext="java" data-title="java"><pre class="language-java"><code><span class="token class-name">Pattern</span><span class="token punctuation">.</span><span class="token function">compile</span><span class="token punctuation">(</span><span class="token string">&quot;[^:]+://(?\\u003e[.a-z]+/?)+/ending-path&quot;</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
</code></pre><div class="line-numbers" aria-hidden="true"><div class="line-number"></div></div></div><p>我们添加了“ <em>/ending-path</em>”作为一个常量路径段。这个额外的要求迫使回溯情况。域名和其他路径段可以匹配斜杠字符。为了匹配 <em>“/ending-path”</em>，引擎需要回溯。通过回溯，引擎可以从组中删除斜杠并将其应用于模式的“ <em>/ending-path</em>”部分。</p><p>让我们将我们的独立非捕获组模式应用于一个URL：</p><div class="language-java line-numbers-mode" data-ext="java" data-title="java"><pre class="language-java"><code><span class="token class-name">Pattern</span> independentUrlPattern
  <span class="token operator">=</span> <span class="token class-name">Pattern</span><span class="token punctuation">.</span><span class="token function">compile</span><span class="token punctuation">(</span><span class="token string">&quot;[^:]+://(?\\u003e[.a-z]+/?)+/ending-path&quot;</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
<span class="token class-name">Matcher</span> independentMatcher
  <span class="token operator">=</span> independentUrlPattern<span class="token punctuation">.</span><span class="token function">matcher</span><span class="token punctuation">(</span><span class="token string">&quot;http://www.microsoft.com/ending-path&quot;</span><span class="token punctuation">)</span><span class="token punctuation">;</span>

<span class="token class-name">Assertions</span><span class="token punctuation">.</span><span class="token function">assertThat</span><span class="token punctuation">(</span>independentMatcher<span class="token punctuation">.</span><span class="token function">matches</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">.</span><span class="token function">isFalse</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
</code></pre><div class="line-numbers" aria-hidden="true"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><p>该组成功匹配了域名和斜杠。因此，我们离开了独立非捕获组的范围。</p><p>这个模式要求在 <em>“ending-path”</em> 之前出现斜杠。然而，我们的独立非捕获组已经匹配了斜杠。</p><p>NFA引擎应该尝试回溯。**由于组末尾的斜杠是可选的，NFA引擎会从组中删除斜杠并再次尝试。**独立非捕获组丢弃了回溯信息。因此，NFA引擎无法回溯。</p><h3 id="_4-1-组内的回溯" tabindex="-1"><a class="header-anchor" href="#_4-1-组内的回溯"><span>4.1. 组内的回溯</span></a></h3><p>可以在独立非捕获组内发生回溯。<strong>当NFA引擎匹配组时，回溯信息尚未丢弃。回溯信息在组成功匹配后才会被丢弃：</strong></p><div class="language-java line-numbers-mode" data-ext="java" data-title="java"><pre class="language-java"><code><span class="token class-name">Pattern</span> independentUrlPatternWithBacktracking
  <span class="token operator">=</span> <span class="token class-name">Pattern</span><span class="token punctuation">.</span><span class="token function">compile</span><span class="token punctuation">(</span><span class="token string">&quot;[^:]+://(?\\u003e(?:[.a-z]+/?)+/)ending-path&quot;</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
<span class="token class-name">Matcher</span> independentMatcher
  <span class="token operator">=</span> independentUrlPatternWithBacktracking<span class="token punctuation">.</span><span class="token function">matcher</span><span class="token punctuation">(</span><span class="token string">&quot;http://www.microsoft.com/ending-path&quot;</span><span class="token punctuation">)</span><span class="token punctuation">;</span>

<span class="token class-name">Assertions</span><span class="token punctuation">.</span><span class="token function">assertThat</span><span class="token punctuation">(</span>independentMatcher<span class="token punctuation">.</span><span class="token function">matches</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">.</span><span class="token function">isTrue</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
</code></pre><div class="line-numbers" aria-hidden="true"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><p>现在我们有一个独立非捕获组内的非捕获组。我们仍然有一个涉及 <em>“ending-path”</em> 前面的斜杠的回溯情况。然而，我们将模式的回溯部分封装在独立非捕获组内。<strong>因此，回溯将在独立非捕获组内发生。因此NFA引擎有足够的信息进行回溯，并且模式匹配提供的URL。</strong></p><h2 id="_5-结论" tabindex="-1"><a class="header-anchor" href="#_5-结论"><span>5. 结论</span></a></h2><p>我们已经展示了非捕获组与捕获组的不同。然而，它们像它们的捕获对应物一样作为一个单一单元工作。我们还展示了<strong>非捕获组可以启用或禁用组而不是整个模式的修饰符。</strong></p><p>同样，我们已经展示了独立非捕获组如何丢弃回溯信息。**没有这些信息，NFA引擎无法探索替代方案以成功匹配。**然而，组内可以发生回溯。</p><p>正如往常一样，源代码可在GitHub上获得。</p><p><a href="https://www.baeldung.com" target="_blank" rel="noopener noreferrer"><img src="https://www.baeldung.com/wp-content/themes/baeldung/icon/logo.svg" alt="Baeldung Logo" loading="lazy"></a><a href="https://www.baeldung.com/" target="_blank" rel="noopener noreferrer"><img src="https://secure.gravatar.com/avatar/dc417739e22ae675b0e1f7012bbddaa5?s=50&amp;r=g" alt="Gravatar Image" loading="lazy"></a><a href="https://www.baeldung.com/" target="_blank" rel="noopener noreferrer"><img src="https://www.baeldung.com/wp-content/uploads/custom_avatars/Eric-Martin-150x150.jpg" alt="Eric Martin Avatar" loading="lazy"></a><a href="https://www.baeldung.com/" target="_blank" rel="noopener noreferrer"><img src="https://www.baeldung.com/wp-content/uploads/2022/04/announcement-icon.png" alt="Announcement Icon" loading="lazy"></a><a href="https://www.baeldung.com/" target="_blank" rel="noopener noreferrer"><img src="https://www.baeldung.com/wp-content/uploads/2016/05/baeldung-rest-post-footer-main-1.2.0.jpg" alt="REST API Post Footer" loading="lazy"></a><a href="https://www.baeldung.com/" target="_blank" rel="noopener noreferrer"><img src="https://www.baeldung.com/wp-content/uploads/2016/05/baeldung-rest-post-footer-icn-1.0.0.png" alt="REST API Icon" loading="lazy"></a></p><p>OK</p>`,56),o=[p];function c(l,i){return s(),a("div",null,o)}const d=n(e,[["render",c],["__file","2024-07-29-Non Capturing Regex Groups in Java.html.vue"]]),k=JSON.parse('{"path":"/posts/baeldung/2024-07-29/2024-07-29-Non%20Capturing%20Regex%20Groups%20in%20Java.html","title":"Java正则表达式中的非捕获组","lang":"zh-CN","frontmatter":{"date":"2022-04-01T00:00:00.000Z","category":["Java","Regular Expressions"],"tag":["Java","Regex","Non-Capturing Groups"],"head":[["meta",{"name":"keywords","content":"Java, Regular Expressions, Non-Capturing Groups"}],["meta",{"property":"og:url","content":"https://www.kahen.xyz/posts/baeldung/2024-07-29/2024-07-29-Non%20Capturing%20Regex%20Groups%20in%20Java.html"}],["meta",{"property":"og:site_name","content":"Baeldung 中文网"}],["meta",{"property":"og:title","content":"Java正则表达式中的非捕获组"}],["meta",{"property":"og:description","content":"Java正则表达式中的非捕获组 1. 概述 非捕获组是Java正则表达式中的重要结构。**它们创建了一个作为单一单元工作的子模式，但不会保存匹配的字符序列。**在本教程中，我们将探讨如何在Java正则表达式中使用非捕获组。 2. 正则表达式组 正则表达式组可以是两种类型之一：捕获和非捕获。 捕获组会保存匹配的字符序列。它们的值可以作为模式中的反向引用使..."}],["meta",{"property":"og:type","content":"article"}],["meta",{"property":"og:image","content":"https://www.baeldung.com/wp-content/themes/baeldung/icon/logo.svg"}],["meta",{"property":"og:locale","content":"zh-CN"}],["meta",{"property":"og:updated_time","content":"2024-07-29T02:31:37.000Z"}],["meta",{"property":"article:author","content":"Kahen"}],["meta",{"property":"article:tag","content":"Java"}],["meta",{"property":"article:tag","content":"Regex"}],["meta",{"property":"article:tag","content":"Non-Capturing Groups"}],["meta",{"property":"article:published_time","content":"2022-04-01T00:00:00.000Z"}],["meta",{"property":"article:modified_time","content":"2024-07-29T02:31:37.000Z"}],["script",{"type":"application/ld+json"},"{\\"@context\\":\\"https://schema.org\\",\\"@type\\":\\"Article\\",\\"headline\\":\\"Java正则表达式中的非捕获组\\",\\"image\\":[\\"https://www.baeldung.com/wp-content/themes/baeldung/icon/logo.svg\\",\\"https://secure.gravatar.com/avatar/dc417739e22ae675b0e1f7012bbddaa5?s=50&r=g\\",\\"https://www.baeldung.com/wp-content/uploads/custom_avatars/Eric-Martin-150x150.jpg\\",\\"https://www.baeldung.com/wp-content/uploads/2022/04/announcement-icon.png\\",\\"https://www.baeldung.com/wp-content/uploads/2016/05/baeldung-rest-post-footer-main-1.2.0.jpg\\",\\"https://www.baeldung.com/wp-content/uploads/2016/05/baeldung-rest-post-footer-icn-1.0.0.png\\"],\\"datePublished\\":\\"2022-04-01T00:00:00.000Z\\",\\"dateModified\\":\\"2024-07-29T02:31:37.000Z\\",\\"author\\":[{\\"@type\\":\\"Person\\",\\"name\\":\\"Kahen\\",\\"url\\":\\"https://www.kahen.xyz\\"}]}"]],"description":"Java正则表达式中的非捕获组 1. 概述 非捕获组是Java正则表达式中的重要结构。**它们创建了一个作为单一单元工作的子模式，但不会保存匹配的字符序列。**在本教程中，我们将探讨如何在Java正则表达式中使用非捕获组。 2. 正则表达式组 正则表达式组可以是两种类型之一：捕获和非捕获。 捕获组会保存匹配的字符序列。它们的值可以作为模式中的反向引用使..."},"headers":[{"level":2,"title":"1. 概述","slug":"_1-概述","link":"#_1-概述","children":[]},{"level":2,"title":"2. 正则表达式组","slug":"_2-正则表达式组","link":"#_2-正则表达式组","children":[{"level":3,"title":"3.1. 内联修饰符","slug":"_3-1-内联修饰符","link":"#_3-1-内联修饰符","children":[]}]},{"level":2,"title":"4. 独立非捕获组","slug":"_4-独立非捕获组","link":"#_4-独立非捕获组","children":[{"level":3,"title":"4.1. 组内的回溯","slug":"_4-1-组内的回溯","link":"#_4-1-组内的回溯","children":[]}]},{"level":2,"title":"5. 结论","slug":"_5-结论","link":"#_5-结论","children":[]}],"git":{"createdTime":1722220297000,"updatedTime":1722220297000,"contributors":[{"name":"Kahen","email":"Kahen@users.noreply.github.com","commits":1}]},"readingTime":{"minutes":6.18,"words":1854},"filePathRelative":"posts/baeldung/2024-07-29/2024-07-29-Non Capturing Regex Groups in Java.md","localizedDate":"2022年4月1日","excerpt":"<hr>\\n<h1>Java正则表达式中的非捕获组</h1>\\n<h2>1. 概述</h2>\\n<p>非捕获组是Java正则表达式中的重要结构。**它们创建了一个作为单一单元工作的子模式，但不会保存匹配的字符序列。**在本教程中，我们将探讨如何在Java正则表达式中使用非捕获组。</p>\\n<h2>2. 正则表达式组</h2>\\n<p>正则表达式组可以是两种类型之一：捕获和非捕获。</p>\\n<p>捕获组会保存匹配的字符序列。它们的值可以作为模式中的反向引用使用，或者稍后在代码中检索。</p>\\n<p>尽管它们不会保存匹配的字符序列，<strong>非捕获组可以改变组内的模式匹配修饰符。一些非捕获组甚至可以在成功匹配子模式后丢弃回溯信息。</strong></p>","autoDesc":true}');export{d as comp,k as data};
