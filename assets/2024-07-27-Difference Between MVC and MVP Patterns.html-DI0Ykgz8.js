import{_ as e}from"./plugin-vue_export-helper-DlAUqK2U.js";import{c as n,o as t,a as i}from"./app-DWhzy7sT.js";const a={},r=i(`<h1 id="mvc和mvp模式的区别-baeldung" tabindex="-1"><a class="header-anchor" href="#mvc和mvp模式的区别-baeldung"><span>MVC和MVP模式的区别 | Baeldung</span></a></h1><h2 id="_1-概述" tabindex="-1"><a class="header-anchor" href="#_1-概述"><span>1. 概述</span></a></h2><p>在本教程中，我们将学习模型-视图-控制器（Model View Controller，简称MVC）和模型-视图-呈现器（Model View Presenter，简称MVP）模式。我们还将讨论它们之间的区别。</p><h2 id="_2-设计模式和架构模式" tabindex="-1"><a class="header-anchor" href="#_2-设计模式和架构模式"><span>2. 设计模式和架构模式</span></a></h2><h3 id="_2-1-架构模式" tabindex="-1"><a class="header-anchor" href="#_2-1-架构模式"><span>2.1. 架构模式</span></a></h3><p>架构模式是软件架构中常见问题的通用且可复用的解决方案。它们对代码库有广泛的影响。</p><p>例如，它们会水平或垂直地影响软件。所谓水平，是指如何在一个层内组织代码。相反，垂直则意味着一个请求是如何从外层处理到内层并返回的。</p><p>一些更常见的架构模式包括<strong>MVC</strong>、<strong>MVP</strong>和<strong>MVVM</strong>。</p><h3 id="_2-2-设计模式" tabindex="-1"><a class="header-anchor" href="#_2-2-设计模式"><span>2.2. 设计模式</span></a></h3><p>设计模式通常与代码级别的共性相关。它们为细化和构建较小的子系统提供了各种方案。</p><p>此外，设计模式是中等规模的策略，它们细化了实体及其关系的某些结构和行为。一些常用的设计模式包括单例、工厂和建造者模式。</p><p><strong>设计模式与架构模式在范围上有所不同</strong>。它们更加局部化，对代码库的影响较小。相反，它们只影响代码库的特定部分。在下一节中，我们将讨论我们为什么使用这些模式。</p><p>使用这些模式的主要思想是<strong>分离业务层和UI层之间的关注点</strong>。这些模式为我们提供了易于测试等功能。它们还隐藏了数据访问。</p><p>我们可以说，通过隔离主要组件，它们更适应变化。然而，最大的缺点是增加了复杂性和学习曲线。</p><h2 id="_4-mvc模式" tabindex="-1"><a class="header-anchor" href="#_4-mvc模式"><span>4. MVC模式</span></a></h2><p>在MVC模式中，根据三个不同的关注点将功能划分为三个组件。首先，<strong>视图负责渲染UI元素</strong>。其次，<strong>控制器响应UI操作</strong>。最后，<strong>模型处理业务行为和状态管理</strong>。</p><p>在大多数实现中，所有三个组件可以直接相互交互。然而，在某些实现中，控制器负责确定要显示哪个视图。</p><p>下面的图表显示了MVC的控制流程：</p><figure><img src="https://www.baeldung.com/wp-content/uploads/2021/08/MVC_Pattern-273x300-1.png" alt="img" tabindex="0" loading="lazy"><figcaption>img</figcaption></figure><p>模型代表整个业务逻辑层。视图代表从模型获取的数据。此外，它还处理呈现逻辑。最后，控制器处理控制流程逻辑并更新模型。</p><p>MVC<strong>没有指定视图和模型应该如何内部结构化</strong>。通常，视图层在一个单独的类中实现。</p><p>然而，在这种情况下，<strong>可能会出现一些问题</strong>：</p><ul><li>视图和模型紧密耦合。结果，视图的功能需求可以很容易地渗透到模型中，污染业务逻辑层</li><li>视图是单体的，并且通常与UI框架紧密耦合。因此，对视图进行单元测试变得困难</li></ul><h2 id="_5-mvp模式" tabindex="-1"><a class="header-anchor" href="#_5-mvp模式"><span>5. MVP模式</span></a></h2><p>MVP模式是一种基于MVC模式概念的UI呈现模式。然而，它并没有指定如何构建整个系统。<strong>它只规定了如何构建视图</strong>。</p><p>一般来说，这种模式将责任分配给四个组件。首先<strong>视图负责渲染UI元素</strong>。其次，视图接口用于松散地将呈现器与其视图解耦。</p><p>最后，<strong>呈现器与视图和模型交互，模型负责业务行为和状态管理</strong>。</p><p>在某些实现中，呈现器与服务（控制器）层交互以检索/持久化模型。视图接口和服务层通常用于使编写呈现器和模型的单元测试更容易。</p><p>下面的图表显示了MVP的控制流程：</p><figure><img src="https://www.baeldung.com/wp-content/uploads/2021/08/mvp-300x227-1.png" alt="img" tabindex="0" loading="lazy"><figcaption>img</figcaption></figure><p>模型与MVC中的相同，包含业务逻辑。视图是一个被动接口，显示数据。它将用户操作发送给呈现器。</p><p>呈现器位于模型和视图之间。它触发业务逻辑并使视图更新。它从模型接收数据并在视图中显示相同的数据。这使得测试呈现器变得更加容易。</p><p>尽管如此，<strong>MVP还是存在一些问题</strong>：</p><ul><li>控制器经常被省略。由于缺少控制器，控制流程也必须由呈现器处理。这使得呈现器负责两个关注点：更新模型和呈现模型</li><li>我们不能使用数据绑定。如果UI框架允许绑定，我们应该利用它来简化呈现器</li></ul><h2 id="_6-mvc和mvp实现" tabindex="-1"><a class="header-anchor" href="#_6-mvc和mvp实现"><span>6. MVC和MVP实现</span></a></h2><p>我们将通过一个简单的例子来理解这些模式。我们有一个需要显示和更新的产品。这些操作在MVC和MVP中处理方式不同。</p><h3 id="_6-1-视图类" tabindex="-1"><a class="header-anchor" href="#_6-1-视图类"><span>6.1. 视图类</span></a></h3><p>我们有一个简单的视图类，输出产品详情。MVP和MVC的视图类相似：</p><div class="language-text line-numbers-mode" data-ext="text" data-title="text"><pre class="language-text"><code>public class ProductView {
    public void printProductDetails(String name, String description, Double price) {
        log.info(&quot;Product details:&quot;);
        log.info(&quot;product Name: &quot; + name);
        log.info(&quot;product Description: &quot; + description);
        log.info(&quot;product price: &quot; + price);
    }
}
</code></pre><div class="line-numbers" aria-hidden="true"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><h3 id="_6-2-mvp模型和呈现器类" tabindex="-1"><a class="header-anchor" href="#_6-2-mvp模型和呈现器类"><span>6.2. MVP模型和呈现器类</span></a></h3><p>现在让我们定义一个负责业务逻辑的_MVP中的Product_类：</p><div class="language-text line-numbers-mode" data-ext="text" data-title="text"><pre class="language-text"><code>public class Product {
    private String name;
    private String description;
    private Double price;

   //getters &amp; setters
}
</code></pre><div class="line-numbers" aria-hidden="true"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><p>MVP中的呈现器类从模型获取数据并将其传递给视图：</p><div class="language-text line-numbers-mode" data-ext="text" data-title="text"><pre class="language-text"><code>public class ProductPresenter {
    private final Product product;
    private final ProductView view;

     //getters,setters &amp; constructor

    public void showProduct() {
        productView.printProductDetails(product.getName(), product.getDescription(), product.getPrice());
    }
}
</code></pre><div class="line-numbers" aria-hidden="true"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><h3 id="_6-3-mvc模型类" tabindex="-1"><a class="header-anchor" href="#_6-3-mvc模型类"><span>6.3. MVC模型类</span></a></h3><p>对于MVC，区别在于<strong>视图将从模型类而不是MVP中的呈现器类获取数据</strong>。</p><p>我们可以为MVC定义一个模型类：</p><div class="language-text line-numbers-mode" data-ext="text" data-title="text"><pre class="language-text"><code>public class Product {
    private String name;
    private String description;
    private Double price;
    private ProductView view;

    //getters,setters

    public void showProduct() {
        view.printProductDetails(name, description, price);
    }
}
</code></pre><div class="line-numbers" aria-hidden="true"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><p><strong>注意_showProduct()_方法</strong>。这个方法处理从模型到视图的数据传递。在MVP中，这是在呈现器类中完成的，在MVC中，是在模型类中完成的。</p><h2 id="_7-mvc和mvp的比较" tabindex="-1"><a class="header-anchor" href="#_7-mvc和mvp的比较"><span>7. MVC和MVP的比较</span></a></h2><p>MVC和MVP之间没有太多区别。两种模式都侧重于将责任分配给多个组件，从而促进UI（视图）与业务层（模型）的松散耦合。</p><p>主要区别在于模式的实现方式以及在一些高级场景中。让我们看看<strong>一些关键区别</strong>：</p><ul><li>耦合：在MVC中，视图和模型紧密耦合，但在MVP中松散耦合</li><li>通信：在MVP中，视图-呈现器和呈现器-模型之间的通信通过接口进行。然而，在MVC中，控制器和视图层位于同一活动/片段中</li><li>用户输入：在MVC中，用户输入由控制器处理，它指导模型进行进一步操作。但在MVP中，用户输入由视图处理，它指导呈现器调用适当的函数</li><li>关系类型：在MVC中，控制器和视图之间存在<strong>多对一</strong>的关系。一个控制器可以根据所需操作选择不同的视图。另一方面，在MVP中，呈现器和视图具有一对一的关系，一个呈现器类一次管理一个视图</li><li>主要组件：在MVC中，控制器负责。它创建适当的视图并根据用户请求与模型交互。相反，在MVP中，视图负责。视图调用呈现器的方法，后者进一步指导模型</li><li>单元测试：由于紧密耦合，MVC对单元测试的支持有限。另一方面，MVP很好地支持单元测试</li></ul><h2 id="_8-为什么mvp比mvc有优势" tabindex="-1"><a class="header-anchor" href="#_8-为什么mvp比mvc有优势"><span>8. 为什么MVP比MVC有优势</span></a></h2><p>MVP比MVC略胜一筹，因为它可以将我们的应用程序分解为模块。因此，我们可以避免不断创建视图。换句话说，MVP可以帮助我们使视图可重用。</p><h2 id="_9-结论" tabindex="-1"><a class="header-anchor" href="#_9-结论"><span>9. 结论</span></a></h2><p>在本教程中，我们看到了MVC和MVP架构模式以及它们之间的比较。</p><p>示例代码可在GitHub上找到。</p>`,58),l=[r];function s(d,p){return t(),n("div",null,l)}const v=e(a,[["render",s],["__file","2024-07-27-Difference Between MVC and MVP Patterns.html.vue"]]),u=JSON.parse('{"path":"/posts/baeldung/2024-07-27/2024-07-27-Difference%20Between%20MVC%20and%20MVP%20Patterns.html","title":"MVC和MVP模式的区别 | Baeldung","lang":"zh-CN","frontmatter":{"date":"2021-08-01T00:00:00.000Z","category":["Software Engineering","Design Patterns"],"tag":["MVC","MVP"],"head":[["meta",{"name":"keywords","content":"MVC, MVP, design pattern, software architecture"}],["meta",{"property":"og:url","content":"https://www.kahen.xyz/posts/baeldung/2024-07-27/2024-07-27-Difference%20Between%20MVC%20and%20MVP%20Patterns.html"}],["meta",{"property":"og:site_name","content":"Baeldung 中文网"}],["meta",{"property":"og:title","content":"MVC和MVP模式的区别 | Baeldung"}],["meta",{"property":"og:description","content":"MVC和MVP模式的区别 | Baeldung 1. 概述 在本教程中，我们将学习模型-视图-控制器（Model View Controller，简称MVC）和模型-视图-呈现器（Model View Presenter，简称MVP）模式。我们还将讨论它们之间的区别。 2. 设计模式和架构模式 2.1. 架构模式 架构模式是软件架构中常见问题的通用且可..."}],["meta",{"property":"og:type","content":"article"}],["meta",{"property":"og:image","content":"https://www.baeldung.com/wp-content/uploads/2021/08/MVC_Pattern-273x300-1.png"}],["meta",{"property":"og:locale","content":"zh-CN"}],["meta",{"property":"og:updated_time","content":"2024-07-27T08:22:58.000Z"}],["meta",{"property":"article:author","content":"Kahen"}],["meta",{"property":"article:tag","content":"MVC"}],["meta",{"property":"article:tag","content":"MVP"}],["meta",{"property":"article:published_time","content":"2021-08-01T00:00:00.000Z"}],["meta",{"property":"article:modified_time","content":"2024-07-27T08:22:58.000Z"}],["script",{"type":"application/ld+json"},"{\\"@context\\":\\"https://schema.org\\",\\"@type\\":\\"Article\\",\\"headline\\":\\"MVC和MVP模式的区别 | Baeldung\\",\\"image\\":[\\"https://www.baeldung.com/wp-content/uploads/2021/08/MVC_Pattern-273x300-1.png\\",\\"https://www.baeldung.com/wp-content/uploads/2021/08/mvp-300x227-1.png\\"],\\"datePublished\\":\\"2021-08-01T00:00:00.000Z\\",\\"dateModified\\":\\"2024-07-27T08:22:58.000Z\\",\\"author\\":[{\\"@type\\":\\"Person\\",\\"name\\":\\"Kahen\\",\\"url\\":\\"https://www.kahen.xyz\\"}]}"]],"description":"MVC和MVP模式的区别 | Baeldung 1. 概述 在本教程中，我们将学习模型-视图-控制器（Model View Controller，简称MVC）和模型-视图-呈现器（Model View Presenter，简称MVP）模式。我们还将讨论它们之间的区别。 2. 设计模式和架构模式 2.1. 架构模式 架构模式是软件架构中常见问题的通用且可..."},"headers":[{"level":2,"title":"1. 概述","slug":"_1-概述","link":"#_1-概述","children":[]},{"level":2,"title":"2. 设计模式和架构模式","slug":"_2-设计模式和架构模式","link":"#_2-设计模式和架构模式","children":[{"level":3,"title":"2.1. 架构模式","slug":"_2-1-架构模式","link":"#_2-1-架构模式","children":[]},{"level":3,"title":"2.2. 设计模式","slug":"_2-2-设计模式","link":"#_2-2-设计模式","children":[]}]},{"level":2,"title":"4. MVC模式","slug":"_4-mvc模式","link":"#_4-mvc模式","children":[]},{"level":2,"title":"5. MVP模式","slug":"_5-mvp模式","link":"#_5-mvp模式","children":[]},{"level":2,"title":"6. MVC和MVP实现","slug":"_6-mvc和mvp实现","link":"#_6-mvc和mvp实现","children":[{"level":3,"title":"6.1. 视图类","slug":"_6-1-视图类","link":"#_6-1-视图类","children":[]},{"level":3,"title":"6.2. MVP模型和呈现器类","slug":"_6-2-mvp模型和呈现器类","link":"#_6-2-mvp模型和呈现器类","children":[]},{"level":3,"title":"6.3. MVC模型类","slug":"_6-3-mvc模型类","link":"#_6-3-mvc模型类","children":[]}]},{"level":2,"title":"7. MVC和MVP的比较","slug":"_7-mvc和mvp的比较","link":"#_7-mvc和mvp的比较","children":[]},{"level":2,"title":"8. 为什么MVP比MVC有优势","slug":"_8-为什么mvp比mvc有优势","link":"#_8-为什么mvp比mvc有优势","children":[]},{"level":2,"title":"9. 结论","slug":"_9-结论","link":"#_9-结论","children":[]}],"git":{"createdTime":1722068578000,"updatedTime":1722068578000,"contributors":[{"name":"Kahen","email":"Kahen@users.noreply.github.com","commits":1}]},"readingTime":{"minutes":6.59,"words":1977},"filePathRelative":"posts/baeldung/2024-07-27/2024-07-27-Difference Between MVC and MVP Patterns.md","localizedDate":"2021年8月1日","excerpt":"\\n<h2>1. 概述</h2>\\n<p>在本教程中，我们将学习模型-视图-控制器（Model View Controller，简称MVC）和模型-视图-呈现器（Model View Presenter，简称MVP）模式。我们还将讨论它们之间的区别。</p>\\n<h2>2. 设计模式和架构模式</h2>\\n<h3>2.1. 架构模式</h3>\\n<p>架构模式是软件架构中常见问题的通用且可复用的解决方案。它们对代码库有广泛的影响。</p>\\n<p>例如，它们会水平或垂直地影响软件。所谓水平，是指如何在一个层内组织代码。相反，垂直则意味着一个请求是如何从外层处理到内层并返回的。</p>\\n<p>一些更常见的架构模式包括<strong>MVC</strong>、<strong>MVP</strong>和<strong>MVVM</strong>。</p>","autoDesc":true}');export{v as comp,u as data};
