import{_ as n}from"./plugin-vue_export-helper-DlAUqK2U.js";import{c as a,o as s,a as e}from"./app-BTwZI-W8.js";const t={},i=e(`<hr><h1 id="jpa-实体和-serializable-接口" tabindex="-1"><a class="header-anchor" href="#jpa-实体和-serializable-接口"><span>JPA 实体和 Serializable 接口</span></a></h1><p>在本教程中，我们将讨论 JPA 实体和 Java Serializable 接口是如何结合的。首先，我们将看看 java.io.Serializable 接口是什么以及为什么我们需要它。之后，我们将看看 JPA 规范以及 Hibernate 作为其最流行的实现。</p><h3 id="_2-serializable-接口是什么" tabindex="-1"><a class="header-anchor" href="#_2-serializable-接口是什么"><span>2. Serializable 接口是什么？</span></a></h3><p>Serializable 是 Java 核心库中少数几个标记接口之一。标记接口是特殊情况的接口，没有方法或常量。</p><p><strong>对象序列化是将 Java 对象转换为字节流的过程</strong>。然后，我们可以将这些字节流通过线路传输或存储在持久性内存中。<strong>反序列化是相反的过程</strong>，我们从字节流中转换回 Java 对象。要允许对象序列化（或反序列化），一个类必须实现 Serializable 接口。否则，我们将遇到 java.io.NotSerializableException。<strong>序列化在 RMI、JPA 和 EJB 等技术中广泛使用</strong>。</p><p>让我们看看 JPA 规范对 Serializable 的说法以及它与 Hibernate 的关系。</p><h3 id="_3-1-jpa-规范" tabindex="-1"><a class="header-anchor" href="#_3-1-jpa-规范"><span>3.1. JPA 规范</span></a></h3><p>JPA 的一个核心部分是实体类。我们用 <em>@Entity</em> 注解或 XML 描述符将这样的类标记为实体。我们的实体类必须满足几个要求，根据 JPA 规范，我们最关心的是：</p><blockquote><p>如果实体实例要以脱离值的形式传递（例如，通过远程接口），实体类必须实现 Serializable 接口。</p></blockquote><p>在实践中，<strong>如果我们的对象要离开 JVM 的领域，它将需要序列化</strong>。</p><p>每个实体类由持久字段和属性组成。规范要求实体的字段可以是 Java 原语、Java 可序列化类型或用户定义的可序列化类型。</p><p>一个实体类还必须有一个主键。主键可以是原语（单个持久字段）或复合的。复合键的多个规则之一是，<strong>复合键需要是可序列化的</strong>。</p><p>让我们使用 Hibernate、H2 内存数据库和 <em>User</em> 领域对象以及 <em>UserId</em> 作为复合键创建一个简单的示例：</p><div class="language-java line-numbers-mode" data-ext="java" data-title="java"><pre class="language-java"><code><span class="token annotation punctuation">@Entity</span>
<span class="token keyword">public</span> <span class="token keyword">class</span> <span class="token class-name">User</span> <span class="token punctuation">{</span>
    <span class="token annotation punctuation">@EmbeddedId</span> <span class="token class-name">UserId</span> userId<span class="token punctuation">;</span>
    <span class="token class-name">String</span> email<span class="token punctuation">;</span>

    <span class="token comment">// 构造函数，getter 和 setter</span>
<span class="token punctuation">}</span>

<span class="token annotation punctuation">@Embeddable</span>
<span class="token keyword">public</span> <span class="token keyword">class</span> <span class="token class-name">UserId</span> <span class="token keyword">implements</span> <span class="token class-name">Serializable</span> <span class="token punctuation">{</span>
    <span class="token keyword">private</span> <span class="token class-name">String</span> name<span class="token punctuation">;</span>
    <span class="token keyword">private</span> <span class="token class-name">String</span> lastName<span class="token punctuation">;</span>

    <span class="token comment">// getter 和 setter</span>
<span class="token punctuation">}</span>
</code></pre><div class="line-numbers" aria-hidden="true"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><p>我们可以使用集成测试来测试我们的领域定义：</p><div class="language-java line-numbers-mode" data-ext="java" data-title="java"><pre class="language-java"><code><span class="token annotation punctuation">@Test</span>
<span class="token keyword">public</span> <span class="token keyword">void</span> <span class="token function">givenUser_whenPersisted_thenOperationSuccessful</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>
    <span class="token class-name">UserId</span> userId <span class="token operator">=</span> <span class="token keyword">new</span> <span class="token class-name">UserId</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
    userId<span class="token punctuation">.</span><span class="token function">setName</span><span class="token punctuation">(</span><span class="token string">&quot;John&quot;</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
    userId<span class="token punctuation">.</span><span class="token function">setLastName</span><span class="token punctuation">(</span><span class="token string">&quot;Doe&quot;</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
    <span class="token class-name">User</span> user <span class="token operator">=</span> <span class="token keyword">new</span> <span class="token class-name">User</span><span class="token punctuation">(</span>userId<span class="token punctuation">,</span> <span class="token string">&quot;johndoe@gmail.com&quot;</span><span class="token punctuation">)</span><span class="token punctuation">;</span>

    entityManager<span class="token punctuation">.</span><span class="token function">persist</span><span class="token punctuation">(</span>user<span class="token punctuation">)</span><span class="token punctuation">;</span>

    <span class="token class-name">User</span> userDb <span class="token operator">=</span> entityManager<span class="token punctuation">.</span><span class="token function">find</span><span class="token punctuation">(</span><span class="token class-name">User</span><span class="token punctuation">.</span><span class="token keyword">class</span><span class="token punctuation">,</span> userId<span class="token punctuation">)</span><span class="token punctuation">;</span>
    <span class="token function">assertEquals</span><span class="token punctuation">(</span>userDb<span class="token punctuation">.</span>email<span class="token punctuation">,</span> <span class="token string">&quot;johndoe@gmail.com&quot;</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
<span class="token punctuation">}</span>
</code></pre><div class="line-numbers" aria-hidden="true"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><p>如果我们的 <em>UserId</em> 类没有实现 <em>Serializable</em> 接口，我们将得到一个 <em>MappingException</em>，具体消息是我们的复合键必须实现该接口。</p><h3 id="_3-2-hibernate-joincolumn-注解" tabindex="-1"><a class="header-anchor" href="#_3-2-hibernate-joincolumn-注解"><span>3.2. Hibernate @JoinColumn 注解</span></a></h3><p>Hibernate 官方文档在描述 Hibernate 中的映射时指出，当我们使用 @JoinColumn 注解中的 <em>referencedColumnName</em> 时，<strong>被引用的字段必须是可序列化的</strong>。通常，这个字段是另一个实体的主键。在复杂实体类的罕见情况下，我们的引用必须是可序列化的。</p><p>让我们扩展前面的 <em>User</em> 类，其中 <em>email</em> 字段不再是 <em>String</em> 而是一个独立的实体。我们还将添加一个 <em>Account</em> 类，它将引用一个用户并有一个 <em>type</em> 字段。每个 <em>User</em> 可以有多个不同类型的账户。我们将通过 <em>email</em> 映射 <em>Account</em> ，因为按电子邮件地址搜索更自然：</p><div class="language-java line-numbers-mode" data-ext="java" data-title="java"><pre class="language-java"><code><span class="token annotation punctuation">@Entity</span>
<span class="token keyword">public</span> <span class="token keyword">class</span> <span class="token class-name">User</span> <span class="token punctuation">{</span>
    <span class="token annotation punctuation">@EmbeddedId</span> <span class="token keyword">private</span> <span class="token class-name">UserId</span> userId<span class="token punctuation">;</span>
    <span class="token keyword">private</span> <span class="token class-name">Email</span> email<span class="token punctuation">;</span>
<span class="token punctuation">}</span>

<span class="token annotation punctuation">@Entity</span>
<span class="token keyword">public</span> <span class="token keyword">class</span> <span class="token class-name">Email</span> <span class="token keyword">implements</span> <span class="token class-name">Serializable</span> <span class="token punctuation">{</span>
    <span class="token annotation punctuation">@Id</span>
    <span class="token keyword">private</span> <span class="token keyword">long</span> id<span class="token punctuation">;</span>
    <span class="token keyword">private</span> <span class="token class-name">String</span> name<span class="token punctuation">;</span>
    <span class="token keyword">private</span> <span class="token class-name">String</span> domain<span class="token punctuation">;</span>
<span class="token punctuation">}</span>

<span class="token annotation punctuation">@Entity</span>
<span class="token keyword">public</span> <span class="token keyword">class</span> <span class="token class-name">Account</span> <span class="token punctuation">{</span>
    <span class="token annotation punctuation">@Id</span>
    <span class="token keyword">private</span> <span class="token keyword">long</span> id<span class="token punctuation">;</span>
    <span class="token keyword">private</span> <span class="token class-name">String</span> type<span class="token punctuation">;</span>
    <span class="token annotation punctuation">@ManyToOne</span>
    <span class="token annotation punctuation">@JoinColumn</span><span class="token punctuation">(</span>referencedColumnName <span class="token operator">=</span> <span class="token string">&quot;email&quot;</span><span class="token punctuation">)</span>
    <span class="token keyword">private</span> <span class="token class-name">User</span> user<span class="token punctuation">;</span>
<span class="token punctuation">}</span>
</code></pre><div class="line-numbers" aria-hidden="true"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><p>为了测试我们的模型，我们将编写一个测试，其中我们为一个用户创建两个账户，并通过电子邮件对象查询：</p><div class="language-java line-numbers-mode" data-ext="java" data-title="java"><pre class="language-java"><code><span class="token annotation punctuation">@Test</span>
<span class="token keyword">public</span> <span class="token keyword">void</span> <span class="token function">givenAssociation_whenPersisted_thenMultipleAccountsWillBeFoundByEmail</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>
    <span class="token comment">// 对象创建</span>

    entityManager<span class="token punctuation">.</span><span class="token function">persist</span><span class="token punctuation">(</span>user<span class="token punctuation">)</span><span class="token punctuation">;</span>
    entityManager<span class="token punctuation">.</span><span class="token function">persist</span><span class="token punctuation">(</span>account<span class="token punctuation">)</span><span class="token punctuation">;</span>
    entityManager<span class="token punctuation">.</span><span class="token function">persist</span><span class="token punctuation">(</span>account2<span class="token punctuation">)</span><span class="token punctuation">;</span>

    <span class="token class-name">List</span>\`<span class="token generics"><span class="token punctuation">&lt;</span><span class="token class-name">Account</span><span class="token punctuation">&gt;</span></span>\` userAccounts <span class="token operator">=</span> entityManager<span class="token punctuation">.</span><span class="token function">createQuery</span><span class="token punctuation">(</span><span class="token string">&quot;select a from Account a join fetch a.user where a.user.email = :email&quot;</span><span class="token punctuation">,</span> <span class="token class-name">Account</span><span class="token punctuation">.</span><span class="token keyword">class</span><span class="token punctuation">)</span>
      <span class="token punctuation">.</span><span class="token function">setParameter</span><span class="token punctuation">(</span><span class="token string">&quot;email&quot;</span><span class="token punctuation">,</span> email<span class="token punctuation">)</span>
      <span class="token punctuation">.</span><span class="token function">getResultList</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>

    <span class="token function">assertEquals</span><span class="token punctuation">(</span>userAccounts<span class="token punctuation">.</span><span class="token function">size</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">,</span> <span class="token number">2</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
<span class="token punctuation">}</span>
</code></pre><div class="line-numbers" aria-hidden="true"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><p><strong>注意：user</strong> 是 H2 数据库中的保留字，不能用作实体的名称。</p><p>如果 <em>Email</em> 类没有实现 <em>Serializable</em> 接口，我们将再次得到 <em>MappingException</em>，但这次的消息有些难以理解：“Could not determine type”。</p><h3 id="_3-3-将实体暴露给表示层" tabindex="-1"><a class="header-anchor" href="#_3-3-将实体暴露给表示层"><span>3.3. 将实体暴露给表示层</span></a></h3><p>当我们使用 HTTP 通过线路发送对象时，我们通常会为此目的创建特定的 DTO（数据传输对象）。通过创建 DTO，我们将内部领域对象与外部服务解耦。<strong>如果我们想直接将实体暴露给表示层而不使用 DTO，那么实体必须是可序列化的</strong>。</p><p>我们使用 <em>HttpSession</em> 对象来存储有助于我们在网站访问期间识别用户的相关数据。当 web 服务器在优雅地关闭或在集群环境中将会话数据传输到另一个 web 服务器时，可以存储会话数据到磁盘上。如果实体是这个过程的一部分，那么它必须是可序列化的。否则，我们将遇到 <em>NotSerializableException</em>。</p><h2 id="结论" tabindex="-1"><a class="header-anchor" href="#结论"><span>结论</span></a></h2><p>在本文中，我们介绍了 Java 序列化的基础，并看到了它如何在 JPA 中发挥作用。首先，我们回顾了 JPA 规范对 Serializable 的要求。之后，我们研了作为 JPA 最流行实现的 Hibernate。最后，我们涵盖了 JPA 实体如何与 web 服务器一起工作。</p><p>像往常一样，本文中介绍的所有代码都可以在 GitHub 上找到。</p>`,32),p=[i];function l(o,c){return s(),a("div",null,p)}const d=n(t,[["render",l],["__file","2024-07-28-JPA Entities and the Serializable Interface.html.vue"]]),k=JSON.parse('{"path":"/posts/baeldung/2024-07-28/2024-07-28-JPA%20Entities%20and%20the%20Serializable%20Interface.html","title":"JPA 实体和 Serializable 接口","lang":"zh-CN","frontmatter":{"date":"2022-04-01T00:00:00.000Z","category":["JPA","Hibernate"],"tag":["JPA Entities","Serializable"],"head":[["meta",{"name":"keywords","content":"JPA, Hibernate, Serializable, Java, Entity, JPA Specification, Mapping"}],["meta",{"property":"og:url","content":"https://www.kahen.xyz/posts/baeldung/2024-07-28/2024-07-28-JPA%20Entities%20and%20the%20Serializable%20Interface.html"}],["meta",{"property":"og:site_name","content":"Baeldung 中文网"}],["meta",{"property":"og:title","content":"JPA 实体和 Serializable 接口"}],["meta",{"property":"og:description","content":"JPA 实体和 Serializable 接口 在本教程中，我们将讨论 JPA 实体和 Java Serializable 接口是如何结合的。首先，我们将看看 java.io.Serializable 接口是什么以及为什么我们需要它。之后，我们将看看 JPA 规范以及 Hibernate 作为其最流行的实现。 2. Serializable 接口是什么..."}],["meta",{"property":"og:type","content":"article"}],["meta",{"property":"og:locale","content":"zh-CN"}],["meta",{"property":"og:updated_time","content":"2024-07-28T07:02:09.000Z"}],["meta",{"property":"article:author","content":"Kahen"}],["meta",{"property":"article:tag","content":"JPA Entities"}],["meta",{"property":"article:tag","content":"Serializable"}],["meta",{"property":"article:published_time","content":"2022-04-01T00:00:00.000Z"}],["meta",{"property":"article:modified_time","content":"2024-07-28T07:02:09.000Z"}],["script",{"type":"application/ld+json"},"{\\"@context\\":\\"https://schema.org\\",\\"@type\\":\\"Article\\",\\"headline\\":\\"JPA 实体和 Serializable 接口\\",\\"image\\":[\\"\\"],\\"datePublished\\":\\"2022-04-01T00:00:00.000Z\\",\\"dateModified\\":\\"2024-07-28T07:02:09.000Z\\",\\"author\\":[{\\"@type\\":\\"Person\\",\\"name\\":\\"Kahen\\",\\"url\\":\\"https://www.kahen.xyz\\"}]}"]],"description":"JPA 实体和 Serializable 接口 在本教程中，我们将讨论 JPA 实体和 Java Serializable 接口是如何结合的。首先，我们将看看 java.io.Serializable 接口是什么以及为什么我们需要它。之后，我们将看看 JPA 规范以及 Hibernate 作为其最流行的实现。 2. Serializable 接口是什么..."},"headers":[{"level":3,"title":"2. Serializable 接口是什么？","slug":"_2-serializable-接口是什么","link":"#_2-serializable-接口是什么","children":[]},{"level":3,"title":"3.1. JPA 规范","slug":"_3-1-jpa-规范","link":"#_3-1-jpa-规范","children":[]},{"level":3,"title":"3.2. Hibernate @JoinColumn 注解","slug":"_3-2-hibernate-joincolumn-注解","link":"#_3-2-hibernate-joincolumn-注解","children":[]},{"level":3,"title":"3.3. 将实体暴露给表示层","slug":"_3-3-将实体暴露给表示层","link":"#_3-3-将实体暴露给表示层","children":[]},{"level":2,"title":"结论","slug":"结论","link":"#结论","children":[]}],"git":{"createdTime":1722150129000,"updatedTime":1722150129000,"contributors":[{"name":"Kahen","email":"Kahen@users.noreply.github.com","commits":1}]},"readingTime":{"minutes":4.47,"words":1342},"filePathRelative":"posts/baeldung/2024-07-28/2024-07-28-JPA Entities and the Serializable Interface.md","localizedDate":"2022年4月1日","excerpt":"<hr>\\n<h1>JPA 实体和 Serializable 接口</h1>\\n<p>在本教程中，我们将讨论 JPA 实体和 Java Serializable 接口是如何结合的。首先，我们将看看 java.io.Serializable 接口是什么以及为什么我们需要它。之后，我们将看看 JPA 规范以及 Hibernate 作为其最流行的实现。</p>\\n<h3>2. Serializable 接口是什么？</h3>\\n<p>Serializable 是 Java 核心库中少数几个标记接口之一。标记接口是特殊情况的接口，没有方法或常量。</p>\\n<p><strong>对象序列化是将 Java 对象转换为字节流的过程</strong>。然后，我们可以将这些字节流通过线路传输或存储在持久性内存中。<strong>反序列化是相反的过程</strong>，我们从字节流中转换回 Java 对象。要允许对象序列化（或反序列化），一个类必须实现 Serializable 接口。否则，我们将遇到 java.io.NotSerializableException。<strong>序列化在 RMI、JPA 和 EJB 等技术中广泛使用</strong>。</p>","autoDesc":true}');export{d as comp,k as data};
