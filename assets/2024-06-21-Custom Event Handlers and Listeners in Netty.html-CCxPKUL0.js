import{_ as n}from"./plugin-vue_export-helper-DlAUqK2U.js";import{c as s,o as a,a as t}from"./app-DpDzgwdT.js";const e={},p=t(`<h1 id="netty中自定义事件处理器和监听器" tabindex="-1"><a class="header-anchor" href="#netty中自定义事件处理器和监听器"><span>Netty中自定义事件处理器和监听器</span></a></h1><p>在本教程中，我们将使用Netty来创建一个聊天室应用程序。在网络编程中，Netty以其强大的框架脱颖而出，简化了异步I/O操作的复杂性。我们将探索如何构建一个基本的聊天服务器，允许多个客户端连接并进行实时对话。</p><h2 id="场景" tabindex="-1"><a class="header-anchor" href="#场景"><span>场景</span></a></h2><p>发送到服务器的消息将被转发给所有连接的客户端。它还将保留最后几条消息的列表，以便新客户端在连接时可以从当前对话中获得上下文。为此，我们只需要几个事件处理器来维护通道之间的通信：</p><p>在Netty中，通信是通过通道完成的，这抽象了任何协议上的异步I/O操作。这使我们能够专注于应用逻辑而不是网络代码。我们的应用程序将通过命令行工作。我们将编写服务器和客户端应用程序。</p><h2 id="创建自定义事件处理器" tabindex="-1"><a class="header-anchor" href="#创建自定义事件处理器"><span>创建自定义事件处理器</span></a></h2><p>为了通道之间的通信，我们将实现一个_GenericChannelInboundHandler<code>&lt;String&gt;</code><em>，这是_GenericChannelInboundHandlerAdapter_的泛型实现。这个适配器允许我们只关注我们关心的事件。在这种情况下，它是_channelRead0()</em>，当从服务器接收到消息时会被调用。我们将使用这个来简化我们的用例，因为我们只交换_String_消息。</p><h3 id="_3-1-客户端事件处理器" tabindex="-1"><a class="header-anchor" href="#_3-1-客户端事件处理器"><span>3.1. 客户端事件处理器</span></a></h3><p>让我们从处理客户端消息的处理器开始，它将打印服务器接收到的任何内容到控制台，不做任何修改：</p><div class="language-java line-numbers-mode" data-ext="java" data-title="java"><pre class="language-java"><code><span class="token keyword">public</span> <span class="token keyword">class</span> <span class="token class-name">ClientEventHandler</span> <span class="token keyword">extends</span> <span class="token class-name">SimpleChannelInboundHandler</span>\`\`\`\`<span class="token generics"><span class="token punctuation">&lt;</span><span class="token class-name">String</span><span class="token punctuation">&gt;</span></span>\`\`\`\` <span class="token punctuation">{</span>
    <span class="token annotation punctuation">@Override</span>
    <span class="token keyword">protected</span> <span class="token keyword">void</span> <span class="token function">channelRead0</span><span class="token punctuation">(</span><span class="token class-name">ChannelHandlerContext</span> ctx<span class="token punctuation">,</span> <span class="token class-name">String</span> msg<span class="token punctuation">)</span> <span class="token punctuation">{</span>
        <span class="token class-name">System</span><span class="token punctuation">.</span>out<span class="token punctuation">.</span><span class="token function">println</span><span class="token punctuation">(</span>msg<span class="token punctuation">)</span><span class="token punctuation">;</span>
    <span class="token punctuation">}</span>
<span class="token punctuation">}</span>
</code></pre><div class="line-numbers" aria-hidden="true"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><p>稍后，我们将通过直接写入通道来处理消息发送。</p><h3 id="_3-2-消息对象" tabindex="-1"><a class="header-anchor" href="#_3-2-消息对象"><span>3.2. 消息对象</span></a></h3><p>在我们继续服务器事件之前，让我们编写一个POJO来表示发送到服务器的每条消息。我们将注册发送日期以及用户名和消息：</p><div class="language-java line-numbers-mode" data-ext="java" data-title="java"><pre class="language-java"><code><span class="token keyword">public</span> <span class="token keyword">class</span> <span class="token class-name">Message</span> <span class="token punctuation">{</span>
    <span class="token keyword">private</span> <span class="token keyword">final</span> <span class="token class-name">Instant</span> time<span class="token punctuation">;</span>
    <span class="token keyword">private</span> <span class="token keyword">final</span> <span class="token class-name">String</span> user<span class="token punctuation">;</span>
    <span class="token keyword">private</span> <span class="token keyword">final</span> <span class="token class-name">String</span> message<span class="token punctuation">;</span>

    <span class="token keyword">public</span> <span class="token class-name">Message</span><span class="token punctuation">(</span><span class="token class-name">String</span> user<span class="token punctuation">,</span> <span class="token class-name">String</span> message<span class="token punctuation">)</span> <span class="token punctuation">{</span>
        <span class="token keyword">this</span><span class="token punctuation">.</span>time <span class="token operator">=</span> <span class="token class-name">Instant</span><span class="token punctuation">.</span><span class="token function">now</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
        <span class="token keyword">this</span><span class="token punctuation">.</span>user <span class="token operator">=</span> user<span class="token punctuation">;</span>
        <span class="token keyword">this</span><span class="token punctuation">.</span>message <span class="token operator">=</span> message<span class="token punctuation">;</span>
    <span class="token punctuation">}</span>

    <span class="token comment">// 标准getter...</span>
<span class="token punctuation">}</span>
</code></pre><div class="line-numbers" aria-hidden="true"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><p>然后，我们将包括一些助手，首先是消息在控制台显示的方式，当由服务器发送时：</p><div class="language-java line-numbers-mode" data-ext="java" data-title="java"><pre class="language-java"><code><span class="token annotation punctuation">@Override</span>
<span class="token keyword">public</span> <span class="token class-name">String</span> <span class="token function">toString</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>
    <span class="token keyword">return</span> time <span class="token operator">+</span> <span class="token string">&quot; - &quot;</span> <span class="token operator">+</span> user <span class="token operator">+</span> <span class="token string">&quot;: &quot;</span> <span class="token operator">+</span> message<span class="token punctuation">;</span>
<span class="token punctuation">}</span>
</code></pre><div class="line-numbers" aria-hidden="true"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><p>然后，对于解析客户端接收到的消息，我们将使用CSV格式。我们将看到客户端在创建客户端应用程序时以这种格式发送消息：</p><div class="language-java line-numbers-mode" data-ext="java" data-title="java"><pre class="language-java"><code><span class="token keyword">public</span> <span class="token keyword">static</span> <span class="token class-name">Message</span> <span class="token function">parse</span><span class="token punctuation">(</span><span class="token class-name">String</span> string<span class="token punctuation">)</span> <span class="token punctuation">{</span>
    <span class="token class-name">String</span><span class="token punctuation">[</span><span class="token punctuation">]</span> arr <span class="token operator">=</span> string<span class="token punctuation">.</span><span class="token function">split</span><span class="token punctuation">(</span><span class="token string">&quot;;&quot;</span><span class="token punctuation">,</span> <span class="token number">2</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
    <span class="token keyword">return</span> <span class="token keyword">new</span> <span class="token class-name">Message</span><span class="token punctuation">(</span>arr<span class="token punctuation">[</span><span class="token number">0</span><span class="token punctuation">]</span><span class="token punctuation">,</span> arr<span class="token punctuation">[</span><span class="token number">1</span><span class="token punctuation">]</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
<span class="token punctuation">}</span>
</code></pre><div class="line-numbers" aria-hidden="true"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><p>限制分割为2很重要，因为消息部分可能包含分号。</p><h3 id="_3-3-服务器事件处理器" tabindex="-1"><a class="header-anchor" href="#_3-3-服务器事件处理器"><span>3.3. 服务器事件处理器</span></a></h3><p>在我们的服务器事件处理器中，我们首先为我们将覆盖的其他事件创建一个辅助方法。我们还需要一个连接客户端的映射和一个_Queue_，以保持最多_MAX_HISTORY_元素：</p><div class="language-java line-numbers-mode" data-ext="java" data-title="java"><pre class="language-java"><code><span class="token keyword">public</span> <span class="token keyword">class</span> <span class="token class-name">ServerEventHandler</span> <span class="token keyword">extends</span> <span class="token class-name">SimpleChannelInboundHandler</span>\`\`\`\`<span class="token generics"><span class="token punctuation">&lt;</span><span class="token class-name">String</span><span class="token punctuation">&gt;</span></span>\`\`\`\` <span class="token punctuation">{</span>
    <span class="token keyword">static</span> <span class="token keyword">final</span> <span class="token class-name">Map</span>\`<span class="token generics"><span class="token punctuation">&lt;</span><span class="token class-name">String</span><span class="token punctuation">,</span> <span class="token class-name">Channel</span><span class="token punctuation">&gt;</span></span>\` clients <span class="token operator">=</span> <span class="token keyword">new</span> <span class="token class-name">HashMap</span><span class="token generics"><span class="token punctuation">&lt;</span><span class="token punctuation">&gt;</span></span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
    <span class="token keyword">static</span> <span class="token keyword">final</span> <span class="token class-name">Queue</span>\`\`\`\`<span class="token generics"><span class="token punctuation">&lt;</span><span class="token class-name">String</span><span class="token punctuation">&gt;</span></span>\`\`\`\` history <span class="token operator">=</span> <span class="token keyword">new</span> <span class="token class-name">LinkedList</span><span class="token generics"><span class="token punctuation">&lt;</span><span class="token punctuation">&gt;</span></span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
    <span class="token keyword">static</span> <span class="token keyword">final</span> <span class="token keyword">int</span> <span class="token constant">MAX_HISTORY</span> <span class="token operator">=</span> <span class="token number">5</span><span class="token punctuation">;</span>

    <span class="token keyword">private</span> <span class="token keyword">void</span> <span class="token function">handleBroadcast</span><span class="token punctuation">(</span><span class="token class-name">Message</span> message<span class="token punctuation">,</span> <span class="token class-name">ChannelHandlerContext</span> context<span class="token punctuation">)</span> <span class="token punctuation">{</span>
        <span class="token class-name">String</span> channelId <span class="token operator">=</span> context<span class="token punctuation">.</span><span class="token function">channel</span><span class="token punctuation">(</span><span class="token punctuation">)</span>
          <span class="token punctuation">.</span><span class="token function">id</span><span class="token punctuation">(</span><span class="token punctuation">)</span>
          <span class="token punctuation">.</span><span class="token function">asShortText</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>

        clients<span class="token punctuation">.</span><span class="token function">forEach</span><span class="token punctuation">(</span><span class="token punctuation">(</span>id<span class="token punctuation">,</span> channel<span class="token punctuation">)</span> <span class="token operator">-&gt;</span> <span class="token punctuation">{</span>
            <span class="token keyword">if</span> <span class="token punctuation">(</span><span class="token operator">!</span>id<span class="token punctuation">.</span><span class="token function">equals</span><span class="token punctuation">(</span>channelId<span class="token punctuation">)</span><span class="token punctuation">)</span>
                channel<span class="token punctuation">.</span><span class="token function">writeAndFlush</span><span class="token punctuation">(</span>message<span class="token punctuation">.</span><span class="token function">toString</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
        <span class="token punctuation">}</span><span class="token punctuation">)</span><span class="token punctuation">;</span>

        <span class="token comment">// 历史控制代码...</span>
    <span class="token punctuation">}</span>

    <span class="token comment">// ...</span>
<span class="token punctuation">}</span>
</code></pre><div class="line-numbers" aria-hidden="true"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><p>首先，我们以通道ID作为我们映射的键。然后，对于广播，对于每个连接的客户端，除了发送者，我们转发他们的消息。</p><p>重要的是要注意_writeAndFlush()<em>接收一个_Object</em>。并且，由于我们的处理器只能处理字符串，因此必须调用_toString()_以便客户端可以正确接收它。</p><p>最后，我们进行历史控制。每次我们添加一条新消息时，如果我们的列表超过_MAX_HISTORY_项目，我们就会移除最旧的一个：</p><div class="language-java line-numbers-mode" data-ext="java" data-title="java"><pre class="language-java"><code>history<span class="token punctuation">.</span><span class="token function">add</span><span class="token punctuation">(</span>message<span class="token punctuation">.</span><span class="token function">toString</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
<span class="token keyword">if</span> <span class="token punctuation">(</span>history<span class="token punctuation">.</span><span class="token function">size</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token operator">&gt;</span> <span class="token constant">MAX_HISTORY</span><span class="token punctuation">)</span>
    history<span class="token punctuation">.</span><span class="token function">poll</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
</code></pre><div class="line-numbers" aria-hidden="true"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><p>现在，我们可以覆盖_channelRead0()_并解析来自客户端的消息：</p><div class="language-java line-numbers-mode" data-ext="java" data-title="java"><pre class="language-java"><code><span class="token annotation punctuation">@Override</span>
<span class="token keyword">public</span> <span class="token keyword">void</span> <span class="token function">channelRead0</span><span class="token punctuation">(</span><span class="token class-name">ChannelHandlerContext</span> context<span class="token punctuation">,</span> <span class="token class-name">String</span> msg<span class="token punctuation">)</span> <span class="token punctuation">{</span>
    <span class="token function">handleBroadcast</span><span class="token punctuation">(</span><span class="token class-name">Message</span><span class="token punctuation">.</span><span class="token function">parse</span><span class="token punctuation">(</span>msg<span class="token punctuation">)</span><span class="token punctuation">,</span> context<span class="token punctuation">)</span><span class="token punctuation">;</span>
<span class="token punctuation">}</span>
</code></pre><div class="line-numbers" aria-hidden="true"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><p>然后，对于每个上线的客户端，我们将其添加到我们的_clients_列表中，转发旧消息以获取上下文，并发送一个系统消息宣布新客户端：</p><div class="language-java line-numbers-mode" data-ext="java" data-title="java"><pre class="language-java"><code><span class="token annotation punctuation">@Override</span>
<span class="token keyword">public</span> <span class="token keyword">void</span> <span class="token function">channelActive</span><span class="token punctuation">(</span><span class="token keyword">final</span> <span class="token class-name">ChannelHandlerContext</span> context<span class="token punctuation">)</span> <span class="token punctuation">{</span>
    <span class="token class-name">Channel</span> channel <span class="token operator">=</span> context<span class="token punctuation">.</span><span class="token function">channel</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
    clients<span class="token punctuation">.</span><span class="token function">put</span><span class="token punctuation">(</span>channel<span class="token punctuation">.</span><span class="token function">id</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">.</span><span class="token function">asShortText</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">,</span> channel<span class="token punctuation">)</span><span class="token punctuation">;</span>

    history<span class="token punctuation">.</span><span class="token function">forEach</span><span class="token punctuation">(</span>channel<span class="token operator">::</span><span class="token function">writeAndFlush</span><span class="token punctuation">)</span><span class="token punctuation">;</span>

    <span class="token function">handleBroadcast</span><span class="token punctuation">(</span><span class="token keyword">new</span> <span class="token class-name">Message</span><span class="token punctuation">(</span><span class="token string">&quot;system&quot;</span><span class="token punctuation">,</span> <span class="token string">&quot;client online&quot;</span><span class="token punctuation">)</span><span class="token punctuation">,</span> context<span class="token punctuation">)</span><span class="token punctuation">;</span>
<span class="token punctuation">}</span>
</code></pre><div class="line-numbers" aria-hidden="true"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><p>最后，我们覆盖_channelInactive()_，在客户端下线时调用。这次，我们只需要从列表中移除客户端并发送系统消息：</p><div class="language-java line-numbers-mode" data-ext="java" data-title="java"><pre class="language-java"><code><span class="token annotation punctuation">@Override</span>
<span class="token keyword">public</span> <span class="token keyword">void</span> <span class="token function">channelInactive</span><span class="token punctuation">(</span><span class="token class-name">ChannelHandlerContext</span> context<span class="token punctuation">)</span> <span class="token punctuation">{</span>
    <span class="token class-name">Channel</span> channel <span class="token operator">=</span> context<span class="token punctuation">.</span><span class="token function">channel</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
    clients<span class="token punctuation">.</span><span class="token function">remove</span><span class="token punctuation">(</span>channel<span class="token punctuation">.</span><span class="token function">id</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">.</span><span class="token function">asShortText</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">;</span>

    <span class="token function">handleBroadcast</span><span class="token punctuation">(</span><span class="token keyword">new</span> <span class="token class-name">Message</span><span class="token punctuation">(</span><span class="token string">&quot;system&quot;</span><span class="token punctuation">,</span> <span class="token string">&quot;client offline&quot;</span><span class="token punctuation">)</span><span class="token punctuation">,</span> context<span class="token punctuation">)</span><span class="token punctuation">;</span>
<span class="token punctuation">}</span>
</code></pre><div class="line-numbers" aria-hidden="true"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><h2 id="服务器引导应用程序" tabindex="-1"><a class="header-anchor" href="#服务器引导应用程序"><span>服务器引导应用程序</span></a></h2><p>我们的处理器不能独立工作，所以我们需要一个应用程序来引导并运行它，这是一个常见的模板。</p><h3 id="_4-1-在-channelpipeline-中注册自定义组件" tabindex="-1"><a class="header-anchor" href="#_4-1-在-channelpipeline-中注册自定义组件"><span>4.1. 在_ChannelPipeline_中注册自定义组件</span></a></h3><p>为了准备引导，我们选择一个通道实现并实现一个子处理器，该处理器为通道提供请求服务：</p><div class="language-java line-numbers-mode" data-ext="java" data-title="java"><pre class="language-java"><code>bootstrap<span class="token punctuation">.</span><span class="token function">group</span><span class="token punctuation">(</span>serverGroup<span class="token punctuation">,</span> clientGroup<span class="token punctuation">)</span>
  <span class="token punctuation">.</span><span class="token function">channel</span><span class="token punctuation">(</span><span class="token class-name">NioServerSocketChannel</span><span class="token punctuation">.</span><span class="token keyword">class</span><span class="token punctuation">)</span>
  <span class="token punctuation">.</span><span class="token function">childHandler</span><span class="token punctuation">(</span><span class="token keyword">new</span> <span class="token class-name">ChannelInitializer</span>\`<span class="token generics"><span class="token punctuation">&lt;</span><span class="token class-name">SocketChannel</span><span class="token punctuation">&gt;</span></span>\`<span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>
      <span class="token annotation punctuation">@Override</span>
      <span class="token keyword">public</span> <span class="token keyword">void</span> <span class="token function">initChannel</span><span class="token punctuation">(</span><span class="token class-name">SocketChannel</span> channel<span class="token punctuation">)</span> <span class="token punctuation">{</span>
          channel<span class="token punctuation">.</span><span class="token function">pipeline</span><span class="token punctuation">(</span><span class="token punctuation">)</span>
            <span class="token punctuation">.</span><span class="token function">addFirst</span><span class="token punctuation">(</span>
              <span class="token keyword">new</span> <span class="token class-name">StringDecoder</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">,</span>
              <span class="token keyword">new</span> <span class="token class-name">ServerEventHandler</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">,</span>
              <span class="token keyword">new</span> <span class="token class-name">StringEncoder</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
      <span class="token punctuation">}</span>
  <span class="token punctuation">}</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
</code></pre><div class="line-numbers" aria-hidden="true"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><p>在子处理器中，我们定义了我们的处理管道。由于我们只关心_String_消息，我们将使用内置的_String_编码器和解码器，这为我们节省了时间，因为我们不必自己编码/解码交换的字节缓冲区。</p><p>最后，由于顺序很重要，我们添加了解码器，我们的_ServerEventHandler_和编码器。这是因为事件从入站流到出站。</p><p>我们将绑定我们的服务器到一个主机/端口来完成我们的应用程序，这将返回一个_ChannelFuture_。我们将使用这个来等待我们的异步套接字关闭_with sync()_:</p><div class="language-java line-numbers-mode" data-ext="java" data-title="java"><pre class="language-java"><code><span class="token class-name">ChannelFuture</span> future <span class="token operator">=</span> bootstrap<span class="token punctuation">.</span><span class="token function">bind</span><span class="token punctuation">(</span><span class="token constant">HOST</span><span class="token punctuation">,</span> <span class="token constant">PORT</span><span class="token punctuation">)</span><span class="token punctuation">.</span><span class="token function">sync</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
<span class="token class-name">System</span><span class="token punctuation">.</span>out<span class="token punctuation">.</span><span class="token function">println</span><span class="token punctuation">(</span><span class="token string">&quot;server started. accepting clients.&quot;</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
future<span class="token punctuation">.</span><span class="token function">channel</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">.</span><span class="token function">closeFuture</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">.</span><span class="token function">sync</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
</code></pre><div class="line-numbers" aria-hidden="true"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><h2 id="客户端引导应用程序" tabindex="-1"><a class="header-anchor" href="#客户端引导应用程序"><span>客户端引导应用程序</span></a></h2><p>最后，我们的客户端应用程序遵循一个常见的客户端模板进行引导。最重要的是，在调用_handler()<em>时，我们将使用我们的_ClientEventHandler</em>:</p><div class="language-java line-numbers-mode" data-ext="java" data-title="java"><pre class="language-java"><code>channel<span class="token punctuation">.</span><span class="token function">pipeline</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">.</span><span class="token function">addFirst</span><span class="token punctuation">(</span>
  <span class="token keyword">new</span> <span class="token class-name">StringDecoder</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">,</span>
  <span class="token keyword">new</span> <span class="token class-name">ClientEventHandler</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">,</span>
  <span class="token keyword">new</span> <span class="token class-name">StringEncoder</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
</code></pre><div class="line-numbers" aria-hidden="true"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><h3 id="_5-1-处理消息输入" tabindex="-1"><a class="header-anchor" href="#_5-1-处理消息输入"><span>5.1. 处理消息输入</span></a></h3><p>最后，为了处理用户输入，在连接到服务器后，我们将使用_Scanner_循环，直到我们收到一个用户名，然后，直到消息等于“exit”。最重要的是，我们必须使用_writeAndFlush()_来发送我们的消息。我们以_Message.parse()_预期的格式发送消息：</p><div class="language-java line-numbers-mode" data-ext="java" data-title="java"><pre class="language-java"><code><span class="token keyword">private</span> <span class="token keyword">static</span> <span class="token keyword">void</span> <span class="token function">messageLoop</span><span class="token punctuation">(</span><span class="token class-name">Scanner</span> scanner<span class="token punctuation">,</span> <span class="token class-name">Channel</span> channel<span class="token punctuation">)</span> <span class="token punctuation">{</span>
    <span class="token keyword">while</span> <span class="token punctuation">(</span>user<span class="token punctuation">.</span><span class="token function">isEmpty</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>
        <span class="token class-name">System</span><span class="token punctuation">.</span>out<span class="token punctuation">.</span><span class="token function">print</span><span class="token punctuation">(</span><span class="token string">&quot;your name: &quot;</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
        user <span class="token operator">=</span> scanner<span class="token punctuation">.</span><span class="token function">nextLine</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
    <span class="token punctuation">}</span>

    <span class="token keyword">while</span> <span class="token punctuation">(</span>scanner<span class="token punctuation">.</span><span class="token function">hasNext</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>
        <span class="token class-name">System</span><span class="token punctuation">.</span>out<span class="token punctuation">.</span><span class="token function">print</span><span class="token punctuation">(</span><span class="token string">&quot;&gt; &quot;</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
        <span class="token class-name">String</span> message <span class="token operator">=</span> scanner<span class="token punctuation">.</span><span class="token function">nextLine</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
        <span class="token keyword">if</span> <span class="token punctuation">(</span>message<span class="token punctuation">.</span><span class="token function">equals</span><span class="token punctuation">(</span><span class="token string">&quot;exit&quot;</span><span class="token punctuation">)</span><span class="token punctuation">)</span>
            <span class="token keyword">break</span><span class="token punctuation">;</span>

        channel<span class="token punctuation">.</span><span class="token function">writeAndFlush</span><span class="token punctuation">(</span>user <span class="token operator">+</span> <span class="token string">&quot;;&quot;</span> <span class="token operator">+</span> message<span class="token punctuation">)</span><span class="token punctuation">;</span>
    <span class="token punctuation">}</span>
<span class="token punctuation">}</span>
</code></pre><div class="line-numbers" aria-hidden="true"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><h2 id="创建自定义事件监听器" tabindex="-1"><a class="header-anchor" href="#创建自定义事件监听器"><span>创建自定义事件监听器</span></a></h2><p>在Netty中，事件监听器在处理通道生命周期中的异步事件中起着至关重要的作用。事件监听器本质上是一个回调机制，我们可以使用它来响应返回_ChannelFuture_的任何操作的完成。</p><p>我们实现_ChannelFutureListener_接口以在完成后自定义行为。_ChannelFuture_代表异步操作的结果，例如连接尝试或I/O操作。</p><p><em>ChannelFutureListener_很有用，因为它定义了像_CLOSE_ON_FAILURE_或_FIRE_EXCEPTION_ON_FAILURE_这样的默认实现。但是，由于我们不会使用这些，让我们实现一个_GenericFutureListener</em>，我们将用于操作确认。</p><p><strong>我们将持有一个自定义事件名称用于上下文，我们将检查我们的future是否成功完成。否则，我们将在记录之前将状态标记为“FAILED”</strong>:</p><div class="language-java line-numbers-mode" data-ext="java" data-title="java"><pre class="language-java"><code><span class="token keyword">public</span> <span class="token keyword">class</span> <span class="token class-name">ChannelInfoListener</span> <span class="token keyword">implements</span> <span class="token class-name">GenericFutureListener</span>\`<span class="token generics"><span class="token punctuation">&lt;</span><span class="token class-name">ChannelFuture</span><span class="token punctuation">&gt;</span></span>\` <span class="token punctuation">{</span>

    <span class="token keyword">private</span> <span class="token keyword">final</span> <span class="token class-name">String</span> event<span class="token punctuation">;</span>

    <span class="token keyword">public</span> <span class="token class-name">ChannelInfoListener</span><span class="token punctuation">(</span><span class="token class-name">String</span> event<span class="token punctuation">)</span> <span class="token punctuation">{</span>
        <span class="token keyword">this</span><span class="token punctuation">.</span>event <span class="token operator">=</span> event<span class="token punctuation">;</span>
    <span class="token punctuation">}</span>

    <span class="token annotation punctuation">@Override</span>
    <span class="token keyword">public</span> <span class="token keyword">void</span> <span class="token function">operationComplete</span><span class="token punctuation">(</span><span class="token class-name">ChannelFuture</span> future<span class="token punctuation">)</span> <span class="token keyword">throws</span> <span class="token class-name">Exception</span> <span class="token punctuation">{</span>
        <span class="token class-name">Channel</span> channel <span class="token operator">=</span> future<span class="token punctuation">.</span><span class="token function">channel</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
        <span class="token class-name">String</span> status <span class="token operator">=</span> <span class="token string">&quot;OK&quot;</span><span class="token punctuation">;</span>

        <span class="token keyword">if</span> <span class="token punctuation">(</span><span class="token operator">!</span>future<span class="token punctuation">.</span><span class="token function">isSuccess</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>
            status <span class="token operator">=</span> <span class="token string">&quot;FAILED&quot;</span><span class="token punctuation">;</span>
            future<span class="token punctuation">.</span><span class="token function">cause</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">.</span><span class="token function">printStackTrace</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
        <span class="token punctuation">}</span>

        <span class="token class-name">System</span><span class="token punctuation">.</span>out<span class="token punctuation">.</span><span class="token function">printf</span><span class="token punctuation">(</span>
          <span class="token string">&quot;%s - channel#%s %s: %s%n&quot;</span><span class="token punctuation">,</span> <span class="token class-name">Instant</span><span class="token punctuation">.</span><span class="token function">now</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">,</span> channel<span class="token punctuation">.</span><span class="token function">idasShortText</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">,</span> status<span class="token punctuation">,</span> event<span class="token punctuation">)</span><span class="token punctuation">;</span>
    <span class="token punctuation">}</span>
<span class="token punctuation">}</span>
</code></pre><div class="line-numbers" aria-hidden="true"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><h3 id="_6-1-事件收据" tabindex="-1"><a class="header-anchor" href="#_6-1-事件收据"><span>6.1. 事件收据</span></a></h3><p>让我们回到代码的某些部分，包括监听器。首先，对于客户端，让我们包括一个“已连接到服务器”的确认：</p><div class="language-java line-numbers-mode" data-ext="java" data-title="java"><pre class="language-java"><code>future<span class="token punctuation">.</span><span class="token function">addListener</span><span class="token punctuation">(</span><span class="token keyword">new</span> <span class="token class-name">ChannelInfoListener</span><span class="token punctuation">(</span><span class="token string">&quot;connected to server&quot;</span><span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
</code></pre><div class="line-numbers" aria-hidden="true"><div class="line-number"></div></div></div><p>然后，让我们在消息循环中包括一个“消息已发送”的确认：</p><div class="language-java line-numbers-mode" data-ext="java" data-title="java"><pre class="language-java"><code><span class="token class-name">ChannelFuture</span> sent <span class="token operator">=</span> channel<span class="token punctuation">.</span><span class="token function">writeAndFlush</span><span class="token punctuation">(</span>user <span class="token operator">+</span> <span class="token string">&quot;;&quot;</span> <span class="token operator">+</span> message<span class="token punctuation">)</span><span class="token punctuation">;</span>
sent<span class="token punctuation">.</span><span class="token function">addListener</span><span class="token punctuation">(</span><span class="token keyword">new</span> <span class="token class-name">ChannelInfoListener</span><span class="token punctuation">(</span><span class="token string">&quot;message sent&quot;</span><span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
</code></pre><div class="line-numbers" aria-hidden="true"><div class="line-number"></div><div class="line-number"></div></div></div><p>这使我们能够确保在发送消息时仍然连接到服务器。最后，对于服务器处理器，在广播期间让我们发送一个“消息已转发”的确认：</p><div class="language-java line-numbers-mode" data-ext="java" data-title="java"><pre class="language-java"><code>clients<span class="token punctuation">.</span><span class="token function">forEach</span><span class="token punctuation">(</span><span class="token punctuation">(</span>id<span class="token punctuation">,</span> channel<span class="token punctuation">)</span> <span class="token operator">-&gt;</span> <span class="token punctuation">{</span>
    <span class="token keyword">if</span> <span class="token punctuation">(</span><span class="token operator">!</span>id<span class="token punctuation">.</span><span class="token function">equals</span><span class="token punctuation">(</span>channelId<span class="token punctuation">)</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>
        <span class="token class-name">ChannelFuture</span> relay <span class="token operator">=</span> channel<span class="token punctuation">.</span><span class="token function">writeAndFlush</span><span class="token punctuation">(</span>message<span class="token punctuation">.</span><span class="token function">toString</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
        relay<span class="token punctuation">.</span><span class="token function">addListener</span><span class="token punctuation">(</span><span class="token keyword">new</span> <span class="token class-name">ChannelInfoListener</span><span class="token punctuation">(</span><span class="token string">&quot;message relayed to &quot;</span> <span class="token operator">+</span> id<span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
    <span class="token punctuation">}</span>
<span class="token punctuation">}</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
</code></pre><div class="line-numbers" aria-hidden="true"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><h2 id="_7-实际操作" tabindex="-1"><a class="header-anchor" href="#_7-实际操作"><span>7. 实际操作</span></a></h2><p>Netty允许我们使用_EmbeddedChannel_测试管道，但是对于客户端/服务器交互，让我们看看从终端运行时它是什么样子。让我们启动服务器（为了可读性，我们将省略包名）：</p><div class="language-bash line-numbers-mode" data-ext="sh" data-title="sh"><pre class="language-bash"><code>$ mvn exec:java <span class="token parameter variable">-Dexec.mainClass</span><span class="token operator">=</span>ChatServerMain
chat server started. ready to accept clients.
</code></pre><div class="line-numbers" aria-hidden="true"><div class="line-number"></div><div class="line-number"></div></div></div><p>然后，让我们启动第一个客户端，输入一个名字，并发送两条消息：</p><div class="language-bash line-numbers-mode" data-ext="sh" data-title="sh"><pre class="language-bash"><code>$ mvn exec:java <span class="token parameter variable">-Dexec.mainClass</span><span class="token operator">=</span>ChatClientMain
<span class="token number">2024</span>-01-12 <span class="token number">3</span>:47:02 - channel<span class="token comment">#03c40ad4 OK: connected to server</span>
your name: Bob
<span class="token operator">&gt;</span> Hello
<span class="token number">2024</span>-01-12 <span class="token number">3</span>:47:02 - channel<span class="token comment">#03c40ad4 OK: message sent</span>
<span class="token operator">&gt;</span> Anyone there?<span class="token operator">!</span>
<span class="token number">2024</span>-01-12 <span class="token number">3</span>:47:03 - channel<span class="token comment">#03c40ad4 OK: message sent</span>
</code></pre><div class="line-numbers" aria-hidden="true"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><p><strong>当我们用第二个客户端连接时，我们将在输入名字之前获得消息历史记录</strong>：</p><div class="language-bash line-numbers-mode" data-ext="sh" data-title="sh"><pre class="language-bash"><code>$ mvn exec:java <span class="token parameter variable">-Dexec.mainClass</span><span class="token operator">=</span>ChatClientMain
<span class="token number">2024</span>-01-12 <span class="token number">3</span>:49:33 - channel<span class="token comment">#daa64476 OK: connected to server</span>
<span class="token number">2024</span>-01-12 <span class="token number">3</span>:46:55 - system: client online: 03c40ad4
<span class="token number">2024</span>-01-12 <span class="token number">3</span>:47:03 - Bob: Hello
<span class="token number">2024</span>-01-12 <span class="token number">3</span>:48:40 - Bob: Anyone there?<span class="token operator">!</span>
</code></pre><div class="line-numbers" aria-hidden="true"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><p>自然，在选择了名字并发送了一条消息之后：</p><div class="language-bash line-numbers-mode" data-ext="sh" data-title="sh"><pre class="language-bash"><code>your name: Alice
<span class="token operator">&gt;</span> Hi, Bob<span class="token operator">!</span>
<span class="token number">2024</span>-01-12 <span class="token number">3</span>:51:05 - channel<span class="token comment">#daa64476 OK: message sent</span>
</code></pre><div class="line-numbers" aria-hidden="true"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><p>第一个客户端将收到它：</p><div class="language-bash line-numbers-mode" data-ext="sh" data-title="sh"><pre class="language-bash"><code><span class="token number">2024</span>-01-12 <span class="token number">3</span>:49:33 - system: client online: daa64476
<span class="token number">2024</span>-01-12 <span class="token number">3</span>:51:05 - Alice: Hi, Bob<span class="token operator">!</span>
</code></pre><div class="line-numbers" aria-hidden="true"><div class="line-number"></div><div class="line-number"></div></div></div><h2 id="_8-结论" tabindex="-1"><a class="header-anchor" href="#_8-结论"><span>8. 结论</span></a></h2><p>在本文中，我们成功地使用Netty构建了一个功能齐全的聊天服务器，展示了这个框架在处理异步通信方面的强大和简单性。通过实现事件处理器，我们能够转发连接客户端之间的消息并维护上下文历史。</p><p>如常，源代码可在GitHub上获得。</p><p>OK</p>`,75),c=[p];function o(l,i){return a(),s("div",null,c)}const k=n(e,[["render",o],["__file","2024-06-21-Custom Event Handlers and Listeners in Netty.html.vue"]]),d=JSON.parse('{"path":"/posts/baeldung/2024-06-21/2024-06-21-Custom%20Event%20Handlers%20and%20Listeners%20in%20Netty.html","title":"Netty中自定义事件处理器和监听器","lang":"zh-CN","frontmatter":{"date":"2024-01-12T00:00:00.000Z","category":["Netty","编程"],"tag":["Netty","事件处理器","监听器"],"head":[["meta",{"name":"keywords","content":"Netty, 事件处理器, 监听器, 聊天室"}],["meta",{"property":"og:url","content":"https://www.kahen.xyz/posts/baeldung/2024-06-21/2024-06-21-Custom%20Event%20Handlers%20and%20Listeners%20in%20Netty.html"}],["meta",{"property":"og:site_name","content":"Baeldung 中文网"}],["meta",{"property":"og:title","content":"Netty中自定义事件处理器和监听器"}],["meta",{"property":"og:description","content":"Netty中自定义事件处理器和监听器 在本教程中，我们将使用Netty来创建一个聊天室应用程序。在网络编程中，Netty以其强大的框架脱颖而出，简化了异步I/O操作的复杂性。我们将探索如何构建一个基本的聊天服务器，允许多个客户端连接并进行实时对话。 场景 发送到服务器的消息将被转发给所有连接的客户端。它还将保留最后几条消息的列表，以便新客户端在连接时可..."}],["meta",{"property":"og:type","content":"article"}],["meta",{"property":"og:locale","content":"zh-CN"}],["meta",{"property":"og:updated_time","content":"2024-06-21T16:50:05.000Z"}],["meta",{"property":"article:author","content":"Kahen"}],["meta",{"property":"article:tag","content":"Netty"}],["meta",{"property":"article:tag","content":"事件处理器"}],["meta",{"property":"article:tag","content":"监听器"}],["meta",{"property":"article:published_time","content":"2024-01-12T00:00:00.000Z"}],["meta",{"property":"article:modified_time","content":"2024-06-21T16:50:05.000Z"}],["script",{"type":"application/ld+json"},"{\\"@context\\":\\"https://schema.org\\",\\"@type\\":\\"Article\\",\\"headline\\":\\"Netty中自定义事件处理器和监听器\\",\\"image\\":[\\"\\"],\\"datePublished\\":\\"2024-01-12T00:00:00.000Z\\",\\"dateModified\\":\\"2024-06-21T16:50:05.000Z\\",\\"author\\":[{\\"@type\\":\\"Person\\",\\"name\\":\\"Kahen\\",\\"url\\":\\"https://www.kahen.xyz\\"}]}"]],"description":"Netty中自定义事件处理器和监听器 在本教程中，我们将使用Netty来创建一个聊天室应用程序。在网络编程中，Netty以其强大的框架脱颖而出，简化了异步I/O操作的复杂性。我们将探索如何构建一个基本的聊天服务器，允许多个客户端连接并进行实时对话。 场景 发送到服务器的消息将被转发给所有连接的客户端。它还将保留最后几条消息的列表，以便新客户端在连接时可..."},"headers":[{"level":2,"title":"场景","slug":"场景","link":"#场景","children":[]},{"level":2,"title":"创建自定义事件处理器","slug":"创建自定义事件处理器","link":"#创建自定义事件处理器","children":[{"level":3,"title":"3.1. 客户端事件处理器","slug":"_3-1-客户端事件处理器","link":"#_3-1-客户端事件处理器","children":[]},{"level":3,"title":"3.2. 消息对象","slug":"_3-2-消息对象","link":"#_3-2-消息对象","children":[]},{"level":3,"title":"3.3. 服务器事件处理器","slug":"_3-3-服务器事件处理器","link":"#_3-3-服务器事件处理器","children":[]}]},{"level":2,"title":"服务器引导应用程序","slug":"服务器引导应用程序","link":"#服务器引导应用程序","children":[{"level":3,"title":"4.1. 在_ChannelPipeline_中注册自定义组件","slug":"_4-1-在-channelpipeline-中注册自定义组件","link":"#_4-1-在-channelpipeline-中注册自定义组件","children":[]}]},{"level":2,"title":"客户端引导应用程序","slug":"客户端引导应用程序","link":"#客户端引导应用程序","children":[{"level":3,"title":"5.1. 处理消息输入","slug":"_5-1-处理消息输入","link":"#_5-1-处理消息输入","children":[]}]},{"level":2,"title":"创建自定义事件监听器","slug":"创建自定义事件监听器","link":"#创建自定义事件监听器","children":[{"level":3,"title":"6.1. 事件收据","slug":"_6-1-事件收据","link":"#_6-1-事件收据","children":[]}]},{"level":2,"title":"7. 实际操作","slug":"_7-实际操作","link":"#_7-实际操作","children":[]},{"level":2,"title":"8. 结论","slug":"_8-结论","link":"#_8-结论","children":[]}],"git":{"createdTime":1718988605000,"updatedTime":1718988605000,"contributors":[{"name":"Kahen","email":"Kahen@users.noreply.github.com","commits":1}]},"readingTime":{"minutes":8.23,"words":2468},"filePathRelative":"posts/baeldung/2024-06-21/2024-06-21-Custom Event Handlers and Listeners in Netty.md","localizedDate":"2024年1月12日","excerpt":"\\n<p>在本教程中，我们将使用Netty来创建一个聊天室应用程序。在网络编程中，Netty以其强大的框架脱颖而出，简化了异步I/O操作的复杂性。我们将探索如何构建一个基本的聊天服务器，允许多个客户端连接并进行实时对话。</p>\\n<h2>场景</h2>\\n<p>发送到服务器的消息将被转发给所有连接的客户端。它还将保留最后几条消息的列表，以便新客户端在连接时可以从当前对话中获得上下文。为此，我们只需要几个事件处理器来维护通道之间的通信：</p>\\n<p>在Netty中，通信是通过通道完成的，这抽象了任何协议上的异步I/O操作。这使我们能够专注于应用逻辑而不是网络代码。我们的应用程序将通过命令行工作。我们将编写服务器和客户端应用程序。</p>","autoDesc":true}');export{k as comp,d as data};
