import{_ as n}from"./plugin-vue_export-helper-DlAUqK2U.js";import{c as a,o as s,a as t}from"./app-C5QtKXnb.js";const e={},p=t(`<h1 id="java中模拟inputstream对象" tabindex="-1"><a class="header-anchor" href="#java中模拟inputstream对象"><span>Java中模拟InputStream对象</span></a></h1><ol><li>引言</li></ol><p><code>InputStream</code>是一个常用的抽象类，用于处理数据。数据可能来自非常不同的来源，但使用这个类可以让我们抽象化来源，并独立于特定来源处理数据。</p><p>然而，当我们编写测试时，我们实际上需要提供一些坚实的实现。在本教程中，我们将学习应该选择哪些可用的实现，或者何时更好地编写我们自己的实现。</p><ol start="2"><li><code>InputStream</code>接口基础</li></ol><p>在我们开始编写自己的代码之前，了解<code>InputStream</code>接口是如何构建的对我们来说是个好主意。幸运的是，它非常简单。<strong>要实现一个简单的<code>InputStream</code>，我们只需要考虑一个方法——</strong> <code>read</code>。它不接受任何参数，并以<code>int</code>的形式返回流的下一个字节。如果<code>InputStream</code>已经结束，它返回-1，提示我们停止处理。</p><h3 id="_2-1-测试案例" tabindex="-1"><a class="header-anchor" href="#_2-1-测试案例"><span>2.1. 测试案例</span></a></h3><p>在本教程中，我们将测试一个以<code>InputStream</code>形式处理文本消息并返回处理的字节数的方法。然后我们将断言读取了正确数量的字节：</p><div class="language-text line-numbers-mode" data-ext="text" data-title="text"><pre class="language-text"><code>int bytesCount = processInputStream(someInputStream);
assertThat(bytesCount).isEqualTo(expectedNumberOfBytes);
</code></pre><div class="line-numbers" aria-hidden="true"><div class="line-number"></div><div class="line-number"></div></div></div><p>这里<code>processInputStream()</code>方法的内部实现不太相关，所以我们只是使用一个非常简单的实现：</p><div class="language-java line-numbers-mode" data-ext="java" data-title="java"><pre class="language-java"><code><span class="token keyword">public</span> <span class="token keyword">class</span> <span class="token class-name">MockingInputStreamUnitTest</span> <span class="token punctuation">{</span>
    <span class="token keyword">int</span> <span class="token function">processInputStream</span><span class="token punctuation">(</span><span class="token class-name">InputStream</span> inputStream<span class="token punctuation">)</span> <span class="token keyword">throws</span> <span class="token class-name">IOException</span> <span class="token punctuation">{</span>
        <span class="token keyword">int</span> count <span class="token operator">=</span> <span class="token number">0</span><span class="token punctuation">;</span>
        <span class="token keyword">while</span><span class="token punctuation">(</span>inputStream<span class="token punctuation">.</span><span class="token function">read</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token operator">!=</span> <span class="token operator">-</span><span class="token number">1</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>
            count<span class="token operator">++</span><span class="token punctuation">;</span>
        <span class="token punctuation">}</span>
        <span class="token keyword">return</span> count<span class="token punctuation">;</span>
    <span class="token punctuation">}</span>
<span class="token punctuation">}</span>
</code></pre><div class="line-numbers" aria-hidden="true"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><h3 id="_2-2-使用简单实现" tabindex="-1"><a class="header-anchor" href="#_2-2-使用简单实现"><span>2.2. 使用简单实现</span></a></h3><p>为了更好地理解<code>InputStream</code>的工作原理，我们将编写一个简单的实现，其中包含一个硬编码的消息。除了消息之外，我们的实现将有一个索引，指向我们应该读取消息的下一个字节。每次调用<code>read</code>方法时，我们将从消息中获取一个字节，然后增加索引。</p><p>在我们这样做之前，我们还需要检查我们是否已经读取了消息中的所有字节。如果是这样，我们需要返回-1：</p><div class="language-java line-numbers-mode" data-ext="java" data-title="java"><pre class="language-java"><code><span class="token keyword">public</span> <span class="token keyword">class</span> <span class="token class-name">MockingInputStreamUnitTest</span> <span class="token punctuation">{</span>

<span class="token annotation punctuation">@Test</span>
<span class="token keyword">public</span> <span class="token keyword">void</span> <span class="token function">givenSimpleImplementation_shouldProcessInputStream</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token keyword">throws</span> <span class="token class-name">IOException</span> <span class="token punctuation">{</span>
    <span class="token keyword">int</span> byteCount <span class="token operator">=</span> <span class="token function">processInputStream</span><span class="token punctuation">(</span><span class="token keyword">new</span> <span class="token class-name">InputStream</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>
        <span class="token keyword">private</span> <span class="token keyword">final</span> <span class="token keyword">byte</span><span class="token punctuation">[</span><span class="token punctuation">]</span> msg <span class="token operator">=</span> <span class="token string">&quot;Hello World&quot;</span><span class="token punctuation">.</span><span class="token function">getBytes</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
        <span class="token keyword">private</span> <span class="token keyword">int</span> index <span class="token operator">=</span> <span class="token number">0</span><span class="token punctuation">;</span>
        <span class="token annotation punctuation">@Override</span>
        <span class="token keyword">public</span> <span class="token keyword">int</span> <span class="token function">read</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>
            <span class="token keyword">if</span> <span class="token punctuation">(</span>index <span class="token operator">&gt;=</span> msg<span class="token punctuation">.</span>length<span class="token punctuation">)</span> <span class="token punctuation">{</span>
                <span class="token keyword">return</span> <span class="token operator">-</span><span class="token number">1</span><span class="token punctuation">;</span>
            <span class="token punctuation">}</span>
            <span class="token keyword">return</span> msg<span class="token punctuation">[</span>index<span class="token operator">++</span><span class="token punctuation">]</span><span class="token punctuation">;</span>
        <span class="token punctuation">}</span>
    <span class="token punctuation">}</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
    <span class="token function">assertThat</span><span class="token punctuation">(</span>byteCount<span class="token punctuation">)</span><span class="token punctuation">.</span><span class="token function">isEqualTo</span><span class="token punctuation">(</span><span class="token number">11</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
<span class="token punctuation">}</span>
</code></pre><div class="line-numbers" aria-hidden="true"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><ol start="3"><li>使用<code>ByteArrayInputStream</code></li></ol><p><strong>如果我们完全确定整个数据负载可以适应内存，最简单的选择是<code>ByteArrayInputStream</code>。</strong> 我们向构造函数提供一个字节数组，然后流逐字节地迭代它，类似于前一节中的例子：</p><div class="language-java line-numbers-mode" data-ext="java" data-title="java"><pre class="language-java"><code><span class="token class-name">String</span> msg <span class="token operator">=</span> <span class="token string">&quot;Hello World&quot;</span><span class="token punctuation">;</span>
<span class="token keyword">int</span> bytesCount <span class="token operator">=</span> <span class="token function">processInputStream</span><span class="token punctuation">(</span><span class="token keyword">new</span> <span class="token class-name">ByteArrayInputStream</span><span class="token punctuation">(</span>msg<span class="token punctuation">.</span><span class="token function">getBytes</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
<span class="token function">assertThat</span><span class="token punctuation">(</span>bytesCount<span class="token punctuation">)</span><span class="token punctuation">.</span><span class="token function">isEqualTo</span><span class="token punctuation">(</span><span class="token number">11</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
</code></pre><div class="line-numbers" aria-hidden="true"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><ol start="4"><li>使用<code>FileInputStream</code></li></ol><p>如果我们可以将数据保存为文件，我们也可以将文件加载为<code>FileInputStream</code>。<strong>这种方法的优点是数据不会整个加载到内存中，而是在需要时从磁盘读取。</strong> 如果我们将文件放在资源文件夹中，我们可以使用方便的<code>getResourceAsStream</code>方法直接从路径创建<code>InputStream</code>，只需一行代码：</p><div class="language-java line-numbers-mode" data-ext="java" data-title="java"><pre class="language-java"><code><span class="token class-name">InputStream</span> inputStream <span class="token operator">=</span> <span class="token class-name">MockingInputStreamUnitTest</span><span class="token punctuation">.</span><span class="token keyword">class</span><span class="token punctuation">.</span><span class="token function">getResourceAsStream</span><span class="token punctuation">(</span><span class="token string">&quot;/mockinginputstreams/msg.txt&quot;</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
<span class="token keyword">int</span> bytesCount <span class="token operator">=</span> <span class="token function">processInputStream</span><span class="token punctuation">(</span>inputStream<span class="token punctuation">)</span><span class="token punctuation">;</span>
<span class="token function">assertThat</span><span class="token punctuation">(</span>bytesCount<span class="token punctuation">)</span><span class="token punctuation">.</span><span class="token function">isEqualTo</span><span class="token punctuation">(</span><span class="token number">11</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
</code></pre><div class="line-numbers" aria-hidden="true"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><p>请注意，在这个例子中，实际的<code>InputStream</code>实现将是<code>BufferedFileInputStream</code>。顾名思义，它读取更大的数据块并将它们存储在缓冲区中。因此，它限制了从磁盘的读取次数。</p><ol start="5"><li>即时生成数据</li></ol><p>有时，我们想测试我们的系统是否能够正确处理大量数据。我们可以简单地使用从磁盘加载的大文件，但这种方法有一些严重的缺点。这不仅是潜在的空间浪费，而且像<code>git</code>这样的版本控制系统并不擅长处理大型二进制文件。幸运的是，我们不需要事先拥有所有数据。相反，我们可以即时生成它。</p><p>为了实现这一点，我们需要实现我们的<code>InputStream</code>。让我们从定义字段和构造函数开始：</p><div class="language-java line-numbers-mode" data-ext="java" data-title="java"><pre class="language-java"><code><span class="token keyword">public</span> <span class="token keyword">class</span> <span class="token class-name">GeneratingInputStream</span> <span class="token keyword">extends</span> <span class="token class-name">InputStream</span> <span class="token punctuation">{</span>
    <span class="token keyword">private</span> <span class="token keyword">final</span> <span class="token keyword">int</span> desiredSize<span class="token punctuation">;</span>
    <span class="token keyword">private</span> <span class="token keyword">final</span> <span class="token keyword">byte</span><span class="token punctuation">[</span><span class="token punctuation">]</span> seed<span class="token punctuation">;</span>
    <span class="token keyword">private</span> <span class="token keyword">int</span> actualSize <span class="token operator">=</span> <span class="token number">0</span><span class="token punctuation">;</span>

    <span class="token keyword">public</span> <span class="token class-name">GeneratingInputStream</span><span class="token punctuation">(</span><span class="token keyword">int</span> desiredSize<span class="token punctuation">,</span> <span class="token class-name">String</span> seed<span class="token punctuation">)</span> <span class="token punctuation">{</span>
        <span class="token keyword">this</span><span class="token punctuation">.</span>desiredSize <span class="token operator">=</span> desiredSize<span class="token punctuation">;</span>
        <span class="token keyword">this</span><span class="token punctuation">.</span>seed <span class="token operator">=</span> seed<span class="token punctuation">.</span><span class="token function">getBytes</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
    <span class="token punctuation">}</span>
<span class="token punctuation">}</span>
</code></pre><div class="line-numbers" aria-hidden="true"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><p>“desiredSize”变量将告诉我们何时应该停止生成数据。“seed”变量将是一小块数据，将被重复。最后，<code>actualSize</code>变量将帮助我们跟踪我们已经返回了多少字节。<strong>我们需要它，因为我们实际上没有保存任何数据。我们只返回“当前”字节。</strong></p><p>使用我们定义的变量，我们可以实现<code>read</code>方法：</p><div class="language-java line-numbers-mode" data-ext="java" data-title="java"><pre class="language-java"><code><span class="token annotation punctuation">@Override</span>
<span class="token keyword">public</span> <span class="token keyword">int</span> <span class="token function">read</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>
    <span class="token keyword">if</span> <span class="token punctuation">(</span>actualSize <span class="token operator">&gt;=</span> desiredSize<span class="token punctuation">)</span> <span class="token punctuation">{</span>
        <span class="token keyword">return</span> <span class="token operator">-</span><span class="token number">1</span><span class="token punctuation">;</span>
    <span class="token punctuation">}</span>
    <span class="token keyword">return</span> seed<span class="token punctuation">[</span>actualSize<span class="token operator">++</span> <span class="token operator">%</span> seed<span class="token punctuation">.</span>length<span class="token punctuation">]</span><span class="token punctuation">;</span>
<span class="token punctuation">}</span>
</code></pre><div class="line-numbers" aria-hidden="true"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><p>首先，我们检查是否达到了期望的大小。如果我们做到了，我们应该返回-1，以便流的消费者知道停止读取。如果我们没有，我们应该从种子中返回一个字节。为了确定应该是哪个字节，我们使用模运算符来获取生成数据的实际大小除以种子长度的余数。</p><ol start="6"><li>总结</li></ol><p>在本教程中，我们探讨了如何在测试中处理<code>InputStreams</code>。我们了解了类的构建方式以及我们可以为不同场景使用哪些实现。最后，我们学习了如何编写我们自己的实现以即时生成数据。</p><p>像往常一样，代码示例可以在GitHub上找到。</p>`,33),o=[p];function c(i,l){return s(),a("div",null,o)}const d=n(e,[["render",c],["__file","2024-07-13-Mocking Java InputStream Object.html.vue"]]),k=JSON.parse('{"path":"/posts/baeldung/2024-07-13/2024-07-13-Mocking%20Java%20InputStream%20Object.html","title":"Java中模拟InputStream对象","lang":"zh-CN","frontmatter":{"category":["Java","Testing"],"tag":["InputStream","Mocking","Unit Test"],"head":[["meta",{"name":"keywords","content":"Java, InputStream, Mocking, Unit Test, Testing"}],["meta",{"property":"og:url","content":"https://www.kahen.xyz/posts/baeldung/2024-07-13/2024-07-13-Mocking%20Java%20InputStream%20Object.html"}],["meta",{"property":"og:site_name","content":"Baeldung 中文网"}],["meta",{"property":"og:title","content":"Java中模拟InputStream对象"}],["meta",{"property":"og:description","content":"Java中模拟InputStream对象 引言 InputStream是一个常用的抽象类，用于处理数据。数据可能来自非常不同的来源，但使用这个类可以让我们抽象化来源，并独立于特定来源处理数据。 然而，当我们编写测试时，我们实际上需要提供一些坚实的实现。在本教程中，我们将学习应该选择哪些可用的实现，或者何时更好地编写我们自己的实现。 InputStrea..."}],["meta",{"property":"og:type","content":"article"}],["meta",{"property":"og:locale","content":"zh-CN"}],["meta",{"property":"og:updated_time","content":"2024-07-13T16:04:32.000Z"}],["meta",{"property":"article:author","content":"Kahen"}],["meta",{"property":"article:tag","content":"InputStream"}],["meta",{"property":"article:tag","content":"Mocking"}],["meta",{"property":"article:tag","content":"Unit Test"}],["meta",{"property":"article:modified_time","content":"2024-07-13T16:04:32.000Z"}],["script",{"type":"application/ld+json"},"{\\"@context\\":\\"https://schema.org\\",\\"@type\\":\\"Article\\",\\"headline\\":\\"Java中模拟InputStream对象\\",\\"image\\":[\\"\\"],\\"dateModified\\":\\"2024-07-13T16:04:32.000Z\\",\\"author\\":[{\\"@type\\":\\"Person\\",\\"name\\":\\"Kahen\\",\\"url\\":\\"https://www.kahen.xyz\\"}]}"]],"description":"Java中模拟InputStream对象 引言 InputStream是一个常用的抽象类，用于处理数据。数据可能来自非常不同的来源，但使用这个类可以让我们抽象化来源，并独立于特定来源处理数据。 然而，当我们编写测试时，我们实际上需要提供一些坚实的实现。在本教程中，我们将学习应该选择哪些可用的实现，或者何时更好地编写我们自己的实现。 InputStrea..."},"headers":[{"level":3,"title":"2.1. 测试案例","slug":"_2-1-测试案例","link":"#_2-1-测试案例","children":[]},{"level":3,"title":"2.2. 使用简单实现","slug":"_2-2-使用简单实现","link":"#_2-2-使用简单实现","children":[]}],"git":{"createdTime":1720886672000,"updatedTime":1720886672000,"contributors":[{"name":"Kahen","email":"Kahen@users.noreply.github.com","commits":1}]},"readingTime":{"minutes":4.4,"words":1320},"filePathRelative":"posts/baeldung/2024-07-13/2024-07-13-Mocking Java InputStream Object.md","localizedDate":"2024年7月13日","excerpt":"\\n<ol>\\n<li>引言</li>\\n</ol>\\n<p><code>InputStream</code>是一个常用的抽象类，用于处理数据。数据可能来自非常不同的来源，但使用这个类可以让我们抽象化来源，并独立于特定来源处理数据。</p>\\n<p>然而，当我们编写测试时，我们实际上需要提供一些坚实的实现。在本教程中，我们将学习应该选择哪些可用的实现，或者何时更好地编写我们自己的实现。</p>\\n<ol start=\\"2\\">\\n<li><code>InputStream</code>接口基础</li>\\n</ol>\\n<p>在我们开始编写自己的代码之前，了解<code>InputStream</code>接口是如何构建的对我们来说是个好主意。幸运的是，它非常简单。<strong>要实现一个简单的<code>InputStream</code>，我们只需要考虑一个方法——</strong> <code>read</code>。它不接受任何参数，并以<code>int</code>的形式返回流的下一个字节。如果<code>InputStream</code>已经结束，它返回-1，提示我们停止处理。</p>","autoDesc":true}');export{d as comp,k as data};
