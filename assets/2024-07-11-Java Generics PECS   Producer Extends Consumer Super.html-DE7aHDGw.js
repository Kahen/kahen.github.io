import{_ as n}from"./plugin-vue_export-helper-DlAUqK2U.js";import{c as s,o as a,a as e}from"./app-DkJLHLw-.js";const t={},p=e(`<hr><h1 id="java泛型pecs规则-生产者扩展消费者超类-baeldung" tabindex="-1"><a class="header-anchor" href="#java泛型pecs规则-生产者扩展消费者超类-baeldung"><span>Java泛型PECS规则 - 生产者扩展消费者超类 | Baeldung</span></a></h1><p>在本文中，我们将探讨在处理集合的生产和消费时Java泛型的使用。</p><p>我们还将讨论_extends_和_super_关键字，并查看几个PECS（生产者扩展消费者超类）规则的例子，以确定如何正确使用这些关键字。</p><p>对于本文中的代码示例，我们将使用一个简单的数据模型，其中有一个_User_基类和两个扩展它的类：<em>Operator_和_Customer</em>。</p><p><strong>重要的是要从集合的角度应用PECS规则。</strong> 换句话说，如果我们遍历一个_List_并处理其元素，列表将作为我们逻辑的生产者：</p><div class="language-java line-numbers-mode" data-ext="java" data-title="java"><pre class="language-java"><code><span class="token keyword">public</span> <span class="token keyword">void</span> <span class="token function">sendEmails</span><span class="token punctuation">(</span><span class="token class-name">List</span>\`\`<span class="token generics"><span class="token punctuation">&lt;</span><span class="token class-name">User</span><span class="token punctuation">&gt;</span></span>\`\` users<span class="token punctuation">)</span> <span class="token punctuation">{</span>
    <span class="token keyword">for</span> <span class="token punctuation">(</span><span class="token class-name">User</span> user <span class="token operator">:</span> users<span class="token punctuation">)</span> <span class="token punctuation">{</span>
        <span class="token class-name">System</span><span class="token punctuation">.</span>out<span class="token punctuation">.</span><span class="token function">println</span><span class="token punctuation">(</span><span class="token string">&quot;sending email to &quot;</span> <span class="token operator">+</span> user<span class="token punctuation">)</span><span class="token punctuation">;</span>
    <span class="token punctuation">}</span>
<span class="token punctuation">}</span>
</code></pre><div class="line-numbers" aria-hidden="true"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><p>现在，假设我们想使用_sendEmail_方法来处理_Operator_的_List_。<em>Operator_类扩展了_User</em>，所以我们可能期望这是一个简单直接的方法调用。但是，不幸的是，我们会得到一个编译错误：</p><figure><img src="https://www.baeldung.com/wp-content/uploads/2022/12/producer_extends_error.png" alt="img" tabindex="0" loading="lazy"><figcaption>img</figcaption></figure><p>为了解决这个问题，我们可以按照PECS规则更新_sendEmail_方法。因为用户列表是我们逻辑的_生产者_，我们将使用_extends_关键字：</p><div class="language-java line-numbers-mode" data-ext="java" data-title="java"><pre class="language-java"><code><span class="token keyword">public</span> <span class="token keyword">void</span> <span class="token function">sendEmailsFixed</span><span class="token punctuation">(</span><span class="token class-name">List</span>\`<span class="token generics"><span class="token punctuation">&lt;</span><span class="token operator">?</span> <span class="token keyword">extends</span> <span class="token class-name">User</span><span class="token punctuation">&gt;</span></span>\` users<span class="token punctuation">)</span> <span class="token punctuation">{</span>
    <span class="token keyword">for</span> <span class="token punctuation">(</span><span class="token class-name">User</span> user <span class="token operator">:</span> users<span class="token punctuation">)</span> <span class="token punctuation">{</span>
        <span class="token class-name">System</span><span class="token punctuation">.</span>out<span class="token punctuation">.</span><span class="token function">println</span><span class="token punctuation">(</span><span class="token string">&quot;sending email to &quot;</span> <span class="token operator">+</span> user<span class="token punctuation">)</span><span class="token punctuation">;</span>
    <span class="token punctuation">}</span>
<span class="token punctuation">}</span>
</code></pre><div class="line-numbers" aria-hidden="true"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><p>结果，我们现在可以轻松地调用该方法来处理任何泛型类型的列表，只要它们继承自_User_类：</p><div class="language-java line-numbers-mode" data-ext="java" data-title="java"><pre class="language-java"><code><span class="token class-name">List</span>\`\`<span class="token generics"><span class="token punctuation">&lt;</span><span class="token class-name">Operator</span><span class="token punctuation">&gt;</span></span>\`\` operators <span class="token operator">=</span> <span class="token class-name">Arrays</span><span class="token punctuation">.</span><span class="token function">asList</span><span class="token punctuation">(</span><span class="token keyword">new</span> <span class="token class-name">Operator</span><span class="token punctuation">(</span><span class="token string">&quot;sam&quot;</span><span class="token punctuation">)</span><span class="token punctuation">,</span> <span class="token keyword">new</span> <span class="token class-name">Operator</span><span class="token punctuation">(</span><span class="token string">&quot;daniel&quot;</span><span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
<span class="token class-name">List</span>\`<span class="token generics"><span class="token punctuation">&lt;</span><span class="token class-name">Customer</span><span class="token punctuation">&gt;</span></span>\` customers <span class="token operator">=</span> <span class="token class-name">Arrays</span><span class="token punctuation">.</span><span class="token function">asList</span><span class="token punctuation">(</span><span class="token keyword">new</span> <span class="token class-name">Customer</span><span class="token punctuation">(</span><span class="token string">&quot;john&quot;</span><span class="token punctuation">)</span><span class="token punctuation">,</span> <span class="token keyword">new</span> <span class="token class-name">Customer</span><span class="token punctuation">(</span><span class="token string">&quot;arys&quot;</span><span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">;</span>

<span class="token function">sendEmailsFixed</span><span class="token punctuation">(</span>operators<span class="token punctuation">)</span><span class="token punctuation">;</span>
<span class="token function">sendEmailsFixed</span><span class="token punctuation">(</span>customers<span class="token punctuation">)</span><span class="token punctuation">;</span>
</code></pre><div class="line-numbers" aria-hidden="true"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><h3 id="_3-消费者超类" tabindex="-1"><a class="header-anchor" href="#_3-消费者超类"><span>3. 消费者超类</span></a></h3><p>当我们向集合中添加元素时，我们成为生产者，列表将作为消费者。让我们编写一个方法，它接收一个_Operator_的列表并向其中添加两个元素：</p><div class="language-java line-numbers-mode" data-ext="java" data-title="java"><pre class="language-java"><code><span class="token keyword">private</span> <span class="token keyword">void</span> <span class="token function">addUsersFromMarketingDepartment</span><span class="token punctuation">(</span><span class="token class-name">List</span>\`\`<span class="token generics"><span class="token punctuation">&lt;</span><span class="token class-name">Operator</span><span class="token punctuation">&gt;</span></span>\`\` users<span class="token punctuation">)</span> <span class="token punctuation">{</span>
    users<span class="token punctuation">.</span><span class="token function">add</span><span class="token punctuation">(</span><span class="token keyword">new</span> <span class="token class-name">Operator</span><span class="token punctuation">(</span><span class="token string">&quot;john doe&quot;</span><span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
    users<span class="token punctuation">.</span><span class="token function">add</span><span class="token punctuation">(</span><span class="token keyword">new</span> <span class="token class-name">Operator</span><span class="token punctuation">(</span><span class="token string">&quot;jane doe&quot;</span><span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
<span class="token punctuation">}</span>
</code></pre><div class="line-numbers" aria-hidden="true"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><p>如果我们传递一个_Operator_的列表，这将完美工作。但是，如果我们想用它将这两个操作员添加到一个_User_的列表中，我们将再次得到一个编译错误：</p><figure><img src="https://www.baeldung.com/wp-content/uploads/2022/12/consumer_supers_error.png" alt="img" tabindex="0" loading="lazy"><figcaption>img</figcaption></figure><p>因此，我们需要更新方法，使其接受一个_Operator_的集合或其前身，使用_super_关键字：</p><div class="language-java line-numbers-mode" data-ext="java" data-title="java"><pre class="language-java"><code><span class="token keyword">private</span> <span class="token keyword">void</span> <span class="token function">addUsersFromMarketingDepartmentFixed</span><span class="token punctuation">(</span><span class="token class-name">List</span>\`<span class="token generics"><span class="token punctuation">&lt;</span><span class="token operator">?</span> <span class="token keyword">super</span> <span class="token class-name">Operator</span><span class="token punctuation">&gt;</span></span>\` users<span class="token punctuation">)</span> <span class="token punctuation">{</span>
    users<span class="token punctuation">.</span><span class="token function">add</span><span class="token punctuation">(</span><span class="token keyword">new</span> <span class="token class-name">Operator</span><span class="token punctuation">(</span><span class="token string">&quot;john doe&quot;</span><span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
    users<span class="token punctuation">.</span><span class="token function">add</span><span class="token punctuation">(</span><span class="token keyword">new</span> <span class="token class-name">Operator</span><span class="token punctuation">(</span><span class="token string">&quot;jane doe&quot;</span><span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
<span class="token punctuation">}</span>
</code></pre><div class="line-numbers" aria-hidden="true"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><h3 id="_4-生产和消费" tabindex="-1"><a class="header-anchor" href="#_4-生产和消费"><span>4. 生产和消费</span></a></h3><p>可能存在我们逻辑需要同时读取和写入集合的情况。在这种情况下，_Collection_将同时作为生产者和消费者。</p><p>处理这些场景的唯一方法是使用基类，不使用任何关键字：</p><div class="language-java line-numbers-mode" data-ext="java" data-title="java"><pre class="language-java"><code><span class="token keyword">private</span> <span class="token keyword">void</span> <span class="token function">addUsersAndSendEmails</span><span class="token punctuation">(</span><span class="token class-name">List</span>\`\`<span class="token generics"><span class="token punctuation">&lt;</span><span class="token class-name">User</span><span class="token punctuation">&gt;</span></span>\`\` users<span class="token punctuation">)</span> <span class="token punctuation">{</span>
    users<span class="token punctuation">.</span><span class="token function">add</span><span class="token punctuation">(</span><span class="token keyword">new</span> <span class="token class-name">Operator</span><span class="token punctuation">(</span><span class="token string">&quot;john doe&quot;</span><span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
    <span class="token keyword">for</span> <span class="token punctuation">(</span><span class="token class-name">User</span> user <span class="token operator">:</span> users<span class="token punctuation">)</span> <span class="token punctuation">{</span>
        <span class="token class-name">System</span><span class="token punctuation">.</span>out<span class="token punctuation">.</span><span class="token function">println</span><span class="token punctuation">(</span><span class="token string">&quot;sending email to: &quot;</span> <span class="token operator">+</span> user<span class="token punctuation">)</span><span class="token punctuation">;</span>
    <span class="token punctuation">}</span>
<span class="token punctuation">}</span>
</code></pre><div class="line-numbers" aria-hidden="true"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><p><strong>另一方面，使用同一个集合进行读写将违反命令查询分离原则，应该避免。</strong></p><h3 id="_5-结论" tabindex="-1"><a class="header-anchor" href="#_5-结论"><span>5. 结论</span></a></h3><p>在本文中，我们讨论了_生产者扩展消费者超类_规则，并学习了如何在处理Java集合时应用它。</p><p>我们探讨了集合作为我们逻辑的生产者或消费者的各种用法。之后，我们了解到如果一个集合同时做这两件事，这可能表明我们的设计中存在代码异味。</p><p>本文使用的所有代码示例都可以在GitHub上找到。</p>`,29),o=[p];function c(l,u){return a(),s("div",null,o)}const d=n(t,[["render",c],["__file","2024-07-11-Java Generics PECS   Producer Extends Consumer Super.html.vue"]]),k=JSON.parse('{"path":"/posts/baeldung/2024-07-11/2024-07-11-Java%20Generics%20PECS%20%20%20Producer%20Extends%20Consumer%20Super.html","title":"Java泛型PECS规则 - 生产者扩展消费者超类 | Baeldung","lang":"zh-CN","frontmatter":{"date":"2022-12-01T00:00:00.000Z","category":["Java"],"tag":["Java Generics","PECS"],"head":[["meta",{"name":"keywords","content":"Java, Generics, PECS, Producer, Consumer"}],["meta",{"property":"og:url","content":"https://www.kahen.xyz/posts/baeldung/2024-07-11/2024-07-11-Java%20Generics%20PECS%20%20%20Producer%20Extends%20Consumer%20Super.html"}],["meta",{"property":"og:site_name","content":"Baeldung 中文网"}],["meta",{"property":"og:title","content":"Java泛型PECS规则 - 生产者扩展消费者超类 | Baeldung"}],["meta",{"property":"og:description","content":"Java泛型PECS规则 - 生产者扩展消费者超类 | Baeldung 在本文中，我们将探讨在处理集合的生产和消费时Java泛型的使用。 我们还将讨论_extends_和_super_关键字，并查看几个PECS（生产者扩展消费者超类）规则的例子，以确定如何正确使用这些关键字。 对于本文中的代码示例，我们将使用一个简单的数据模型，其中有一个_User_..."}],["meta",{"property":"og:type","content":"article"}],["meta",{"property":"og:image","content":"https://www.baeldung.com/wp-content/uploads/2022/12/producer_extends_error.png"}],["meta",{"property":"og:locale","content":"zh-CN"}],["meta",{"property":"og:updated_time","content":"2024-07-11T18:46:03.000Z"}],["meta",{"property":"article:author","content":"Kahen"}],["meta",{"property":"article:tag","content":"Java Generics"}],["meta",{"property":"article:tag","content":"PECS"}],["meta",{"property":"article:published_time","content":"2022-12-01T00:00:00.000Z"}],["meta",{"property":"article:modified_time","content":"2024-07-11T18:46:03.000Z"}],["script",{"type":"application/ld+json"},"{\\"@context\\":\\"https://schema.org\\",\\"@type\\":\\"Article\\",\\"headline\\":\\"Java泛型PECS规则 - 生产者扩展消费者超类 | Baeldung\\",\\"image\\":[\\"https://www.baeldung.com/wp-content/uploads/2022/12/producer_extends_error.png\\",\\"https://www.baeldung.com/wp-content/uploads/2022/12/consumer_supers_error.png\\"],\\"datePublished\\":\\"2022-12-01T00:00:00.000Z\\",\\"dateModified\\":\\"2024-07-11T18:46:03.000Z\\",\\"author\\":[{\\"@type\\":\\"Person\\",\\"name\\":\\"Kahen\\",\\"url\\":\\"https://www.kahen.xyz\\"}]}"]],"description":"Java泛型PECS规则 - 生产者扩展消费者超类 | Baeldung 在本文中，我们将探讨在处理集合的生产和消费时Java泛型的使用。 我们还将讨论_extends_和_super_关键字，并查看几个PECS（生产者扩展消费者超类）规则的例子，以确定如何正确使用这些关键字。 对于本文中的代码示例，我们将使用一个简单的数据模型，其中有一个_User_..."},"headers":[{"level":3,"title":"3. 消费者超类","slug":"_3-消费者超类","link":"#_3-消费者超类","children":[]},{"level":3,"title":"4. 生产和消费","slug":"_4-生产和消费","link":"#_4-生产和消费","children":[]},{"level":3,"title":"5. 结论","slug":"_5-结论","link":"#_5-结论","children":[]}],"git":{"createdTime":1720723563000,"updatedTime":1720723563000,"contributors":[{"name":"Kahen","email":"Kahen@users.noreply.github.com","commits":1}]},"readingTime":{"minutes":2.81,"words":844},"filePathRelative":"posts/baeldung/2024-07-11/2024-07-11-Java Generics PECS   Producer Extends Consumer Super.md","localizedDate":"2022年12月1日","excerpt":"<hr>\\n<h1>Java泛型PECS规则 - 生产者扩展消费者超类 | Baeldung</h1>\\n<p>在本文中，我们将探讨在处理集合的生产和消费时Java泛型的使用。</p>\\n<p>我们还将讨论_extends_和_super_关键字，并查看几个PECS（生产者扩展消费者超类）规则的例子，以确定如何正确使用这些关键字。</p>\\n<p>对于本文中的代码示例，我们将使用一个简单的数据模型，其中有一个_User_基类和两个扩展它的类：<em>Operator_和_Customer</em>。</p>\\n<p><strong>重要的是要从集合的角度应用PECS规则。</strong> 换句话说，如果我们遍历一个_List_并处理其元素，列表将作为我们逻辑的生产者：</p>","autoDesc":true}');export{d as comp,k as data};
