import{_ as n}from"./plugin-vue_export-helper-DlAUqK2U.js";import{c as s,o as a,a as t}from"./app-Bowk68ha.js";const e={},p=t(`<h1 id="使用asyncapi和springwolf记录spring事件驱动api" tabindex="-1"><a class="header-anchor" href="#使用asyncapi和springwolf记录spring事件驱动api"><span>使用AsyncAPI和Springwolf记录Spring事件驱动API</span></a></h1><p>记录API是构建应用程序的重要部分。它是我们与客户共享的合同。此外，它详细记录了我们的集成点如何工作。文档应该易于访问、理解和实现。</p><p>在本教程中，我们将研究Springwolf，用于记录事件驱动的Spring Boot服务。Springwolf实现了AsyncAPI规范，这是OpenAPI规范的事件驱动API的适配。<strong>Springwolf是协议不可知的，涵盖了Spring Kafka、Spring RabbitMQ和Spring CloudStream实现。</strong></p><p>使用Spring Kafka作为我们的事件驱动系统，**Springwolf为我们从代码生成AsyncAPI文档。**一些消费者会自动检测到。其他信息由我们提供。</p><h2 id="_2-设置springwolf" tabindex="-1"><a class="header-anchor" href="#_2-设置springwolf"><span><strong>2. 设置Springwolf</strong></span></a></h2><p>要开始使用Springwolf，我们添加依赖项并进行配置。</p><h3 id="_2-1-添加依赖项" tabindex="-1"><a class="header-anchor" href="#_2-1-添加依赖项"><span><strong>2.1. 添加依赖项</strong></span></a></h3><p>假设我们有一个运行中的带有Spring Kafka的Spring应用程序，我们在_pom.xml_文件中将_springwolf-kafka_添加为我们的Maven项目的依赖项：</p><div class="language-xml line-numbers-mode" data-ext="xml" data-title="xml"><pre class="language-xml"><code>\`\`<span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>dependency</span><span class="token punctuation">&gt;</span></span>\`\`
    \`\`<span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>groupId</span><span class="token punctuation">&gt;</span></span>\`\`io.github.springwolf\`\`<span class="token tag"><span class="token tag"><span class="token punctuation">&lt;/</span>groupId</span><span class="token punctuation">&gt;</span></span>\`\`
    \`\`<span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>artifactId</span><span class="token punctuation">&gt;</span></span>\`\`springwolf-kafka\`\`<span class="token tag"><span class="token tag"><span class="token punctuation">&lt;/</span>artifactId</span><span class="token punctuation">&gt;</span></span>\`\`
    \`\`<span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>version</span><span class="token punctuation">&gt;</span></span>\`\`0.14.0\`\`<span class="token tag"><span class="token tag"><span class="token punctuation">&lt;/</span>version</span><span class="token punctuation">&gt;</span></span>\`\`
\`\`<span class="token tag"><span class="token tag"><span class="token punctuation">&lt;/</span>dependency</span><span class="token punctuation">&gt;</span></span>\`\`
</code></pre><div class="line-numbers" aria-hidden="true"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><p>最新版本可以在Maven Central找到，项目网站上提到了对Spring Kafka之外的其他绑定的支持。</p><h3 id="_2-2-application-properties-配置" tabindex="-1"><a class="header-anchor" href="#_2-2-application-properties-配置"><span><strong>2.2. <em>application.properties</em> 配置</strong></span></a></h3><p>在最基本的形式中，我们向我们的_application.properties_添加以下Springwolf配置：</p><div class="language-properties line-numbers-mode" data-ext="properties" data-title="properties"><pre class="language-properties"><code><span class="token comment"># Springwolf 配置</span>
<span class="token key attr-name">springwolf.docket.base-package</span><span class="token punctuation">=</span><span class="token value attr-value">com.baeldung.boot.documentation.springwolf.adapter</span>
<span class="token key attr-name">springwolf.docket.info.title</span><span class="token punctuation">=</span><span class="token value attr-value">\${spring.application.name}</span>
<span class="token key attr-name">springwolf.docket.info.version</span><span class="token punctuation">=</span><span class="token value attr-value">1.0.0</span>
<span class="token key attr-name">springwolf.docket.info.description</span><span class="token punctuation">=</span><span class="token value attr-value">Baeldung 教程应用程序，演示使用Springwolf的AsyncAPI文档</span>

<span class="token comment"># Springwolf Kafka 配置</span>
<span class="token key attr-name">springwolf.docket.servers.kafka.protocol</span><span class="token punctuation">=</span><span class="token value attr-value">kafka</span>
<span class="token key attr-name">springwolf.docket.servers.kafka.url</span><span class="token punctuation">=</span><span class="token value attr-value">localhost:9092</span>
</code></pre><div class="line-numbers" aria-hidden="true"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><p>第一部分设置了通用的Springwolf配置。**这包括_base-package_，Springwolf用它来自动检测监听器。**我们还设置了_docket_配置键下的一般信息，这些信息出现在AsyncAPI文档中。</p><p>然后，我们设置了_springwolf-kafka_特定的配置。同样，这也出现在AsyncAPI文档中。</p><h3 id="_2-3-验证" tabindex="-1"><a class="header-anchor" href="#_2-3-验证"><span><strong>2.3. 验证</strong></span></a></h3><p>现在，我们准备运行我们的应用程序。应用程序启动后，默认情况下，AsyncAPI文档可在_/springwolf/docs_路径获取：</p><div class="language-text line-numbers-mode" data-ext="text" data-title="text"><pre class="language-text"><code>http://localhost:8080/springwolf/docs
</code></pre><div class="line-numbers" aria-hidden="true"><div class="line-number"></div></div></div><h2 id="_3-asyncapi文档" tabindex="-1"><a class="header-anchor" href="#_3-asyncapi文档"><span><strong>3. AsyncAPI文档</strong></span></a></h2><p>AsyncAPI文档遵循与OpenAPI文档类似的结构。首先，我们只查看关键部分。**规范可在AsyncAPI网站上找到。**为了简洁，我们只看属性的一个子集。</p><p>在以下小节中，我们将逐步查看JSON格式的AsyncAPI文档。我们从以下结构开始：</p><div class="language-json line-numbers-mode" data-ext="json" data-title="json"><pre class="language-json"><code><span class="token punctuation">{</span>
    <span class="token property">&quot;asyncapi&quot;</span><span class="token operator">:</span> <span class="token string">&quot;2.6.0&quot;</span><span class="token punctuation">,</span>
    <span class="token property">&quot;info&quot;</span><span class="token operator">:</span> <span class="token punctuation">{</span> ... <span class="token punctuation">}</span><span class="token punctuation">,</span>
    <span class="token property">&quot;servers&quot;</span><span class="token operator">:</span> <span class="token punctuation">{</span> ... <span class="token punctuation">}</span><span class="token punctuation">,</span>
    <span class="token property">&quot;channels&quot;</span><span class="token operator">:</span> <span class="token punctuation">{</span> ... <span class="token punctuation">}</span><span class="token punctuation">,</span>
    <span class="token property">&quot;components&quot;</span><span class="token operator">:</span> <span class="token punctuation">{</span> ... <span class="token punctuation">}</span>
<span class="token punctuation">}</span>
</code></pre><div class="line-numbers" aria-hidden="true"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><h3 id="_3-1-info-部分" tabindex="-1"><a class="header-anchor" href="#_3-1-info-部分"><span><strong>3.1. <em>info</em> 部分</strong></span></a></h3><p>文档的_info_部分包含有关应用程序本身的信息。<strong>至少包括以下字段：<em>title</em>、<em>application version_和_description.</em></strong></p><p>根据我们添加到配置中的信息，创建了以下结构：</p><div class="language-json line-numbers-mode" data-ext="json" data-title="json"><pre class="language-json"><code><span class="token property">&quot;info&quot;</span><span class="token operator">:</span> <span class="token punctuation">{</span>
    <span class="token property">&quot;title&quot;</span><span class="token operator">:</span> <span class="token string">&quot;Baeldung Tutorial Springwolf Application&quot;</span><span class="token punctuation">,</span>
    <span class="token property">&quot;version&quot;</span><span class="token operator">:</span> <span class="token string">&quot;1.0.0&quot;</span><span class="token punctuation">,</span>
    <span class="token property">&quot;description&quot;</span><span class="token operator">:</span> <span class="token string">&quot;Baeldung Tutorial Application to Demonstrate AsyncAPI Documentation using Springwolf&quot;</span>
<span class="token punctuation">}</span>
</code></pre><div class="line-numbers" aria-hidden="true"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><h3 id="_3-2-servers-部分" tabindex="-1"><a class="header-anchor" href="#_3-2-servers-部分"><span><strong>3.2. <em>servers</em> 部分</strong></span></a></h3><p>类似地，_servers_部分包含有关我们的Kafka代理的信息，并基于上述_application.properties_配置：</p><div class="language-json line-numbers-mode" data-ext="json" data-title="json"><pre class="language-json"><code><span class="token property">&quot;servers&quot;</span><span class="token operator">:</span> <span class="token punctuation">{</span>
    <span class="token property">&quot;kafka&quot;</span><span class="token operator">:</span> <span class="token punctuation">{</span>
        <span class="token property">&quot;url&quot;</span><span class="token operator">:</span> <span class="token string">&quot;localhost:9092&quot;</span><span class="token punctuation">,</span>
        <span class="token property">&quot;protocol&quot;</span><span class="token operator">:</span> <span class="token string">&quot;kafka&quot;</span>
    <span class="token punctuation">}</span>
<span class="token punctuation">}</span>
</code></pre><div class="line-numbers" aria-hidden="true"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><h3 id="_3-3-channels-部分" tabindex="-1"><a class="header-anchor" href="#_3-3-channels-部分"><span><strong>3.3. <em>channels</em> 部分</strong></span></a></h3><p>此时此部分为空，因为我们尚未在应用程序中配置任何消费者或生产者。在稍后的部分配置它们之后，我们将看到以下结构：</p><div class="language-json line-numbers-mode" data-ext="json" data-title="json"><pre class="language-json"><code><span class="token property">&quot;channels&quot;</span><span class="token operator">:</span> <span class="token punctuation">{</span>
    <span class="token property">&quot;my-topic-name&quot;</span><span class="token operator">:</span> <span class="token punctuation">{</span>
        <span class="token property">&quot;publish&quot;</span><span class="token operator">:</span> <span class="token punctuation">{</span>
             <span class="token property">&quot;message&quot;</span><span class="token operator">:</span> <span class="token punctuation">{</span>
                <span class="token property">&quot;title&quot;</span><span class="token operator">:</span> <span class="token string">&quot;IncomingPayloadDto&quot;</span><span class="token punctuation">,</span>
                <span class="token property">&quot;payload&quot;</span><span class="token operator">:</span> <span class="token punctuation">{</span>
                    <span class="token property">&quot;$ref&quot;</span><span class="token operator">:</span> <span class="token string">&quot;#/components/schemas/IncomingPayloadDto&quot;</span>
                <span class="token punctuation">}</span>
            <span class="token punctuation">}</span>
        <span class="token punctuation">}</span>
    <span class="token punctuation">}</span>
<span class="token punctuation">}</span>
</code></pre><div class="line-numbers" aria-hidden="true"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><p>通用术语_channels_在Kafka术语中指的是_topics_。</p><p>每个主题可能提供两个操作：<em>publish_和/或_subscribe</em>。值得注意的是，<strong>从应用程序的角度来看，语义可能看起来有些混乱：</strong></p><ul><li><strong>_publish_消息到此通道，以便我们的应用程序可以消费它们。</strong></li><li><strong>_subscribe_订阅此通道以从我们的应用程序接收消息。</strong></li></ul><p>操作对象本身包含信息，如_description_和_message_。<em>message_对象包含信息，如_title_和_payload</em>。</p><p>为了避免在多个主题和操作中重复相同的有效载荷信息，<strong>AsyncAPI使用_$ref_符号来指示AsyncAPI文档_components_部分中的引用。</strong></p><h3 id="_3-4-components-部分" tabindex="-1"><a class="header-anchor" href="#_3-4-components-部分"><span><strong>3.4. <em>components</em> 部分</strong></span></a></h3><p>同样，此部分此时为空，但将具有以下结构：</p><div class="language-json line-numbers-mode" data-ext="json" data-title="json"><pre class="language-json"><code><span class="token property">&quot;components&quot;</span><span class="token operator">:</span> <span class="token punctuation">{</span>
    <span class="token property">&quot;schemas&quot;</span><span class="token operator">:</span> <span class="token punctuation">{</span>
        <span class="token property">&quot;IncomingPayloadDto&quot;</span><span class="token operator">:</span> <span class="token punctuation">{</span>
            <span class="token property">&quot;type&quot;</span><span class="token operator">:</span> <span class="token string">&quot;object&quot;</span><span class="token punctuation">,</span>
            <span class="token property">&quot;properties&quot;</span><span class="token operator">:</span> <span class="token punctuation">{</span>
                ...
                <span class="token property">&quot;someString&quot;</span><span class="token operator">:</span> <span class="token punctuation">{</span>
                    <span class="token property">&quot;type&quot;</span><span class="token operator">:</span> <span class="token string">&quot;string&quot;</span>
                <span class="token punctuation">}</span>
            <span class="token punctuation">}</span><span class="token punctuation">,</span>
            <span class="token property">&quot;example&quot;</span><span class="token operator">:</span> <span class="token punctuation">{</span>
                <span class="token property">&quot;someEnum&quot;</span><span class="token operator">:</span> <span class="token string">&quot;FOO2&quot;</span><span class="token punctuation">,</span>
                <span class="token property">&quot;someLong&quot;</span><span class="token operator">:</span> <span class="token number">1</span><span class="token punctuation">,</span>
                <span class="token property">&quot;someString&quot;</span><span class="token operator">:</span> <span class="token string">&quot;string&quot;</span>
            <span class="token punctuation">}</span>
        <span class="token punctuation">}</span>
    <span class="token punctuation">}</span>
<span class="token punctuation">}</span>
</code></pre><div class="line-numbers" aria-hidden="true"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><p><em>components_部分包含所有</em>$ref_引用的详细信息，包括_#/components/schemas/IncomingPayloadDto_。除了有效载荷的_type_和_properties_，模式还可以包含有效载荷的_example_（JSON）。</p><h2 id="_4-记录消费者" tabindex="-1"><a class="header-anchor" href="#_4-记录消费者"><span><strong>4. 记录消费者</strong></span></a></h2><p><strong>Springwolf自动检测所有_@KafkaListener_注释</strong>，接下来将展示。此外，我们使用_@AsyncListener_注释手动提供更多详细信息。</p><h3 id="_4-1-自动检测-kafkalistener-注释" tabindex="-1"><a class="header-anchor" href="#_4-1-自动检测-kafkalistener-注释"><span><strong>4.1. 自动检测_@KafkaListener_注释</strong></span></a></h3><p>通过在方法上使用Spring-Kafka的_@KafkaListener_注释，Springwolf在_base-package_内自动找到消费者：</p><div class="language-java line-numbers-mode" data-ext="java" data-title="java"><pre class="language-java"><code><span class="token annotation punctuation">@KafkaListener</span><span class="token punctuation">(</span>topics <span class="token operator">=</span> <span class="token constant">TOPIC_NAME</span><span class="token punctuation">)</span>
<span class="token keyword">public</span> <span class="token keyword">void</span> <span class="token function">consume</span><span class="token punctuation">(</span><span class="token class-name">IncomingPayloadDto</span> payload<span class="token punctuation">)</span> <span class="token punctuation">{</span>
    <span class="token comment">// ...</span>
<span class="token punctuation">}</span>
</code></pre><div class="line-numbers" aria-hidden="true"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><p>现在，AsyncAPI文档包含了带有_publish_操作和_IncomingPayloadDto_模式的通道_TOPIC_NAME_，正如我们之前看到的。</p><h3 id="_4-2-通过-asynclistener-注释手动记录消费者" tabindex="-1"><a class="header-anchor" href="#_4-2-通过-asynclistener-注释手动记录消费者"><span><strong>4.2. 通过_@AsyncListener_注释手动记录消费者</strong></span></a></h3><p>**使用自动检测和@ <em>AsyncListener_可能会导致重复。**为了能够手动添加更多信息，我们完全禁用</em>@KafkaListener_的自动检测，并将以下行添加到_application.properties_文件中：</p><div class="language-properties line-numbers-mode" data-ext="properties" data-title="properties"><pre class="language-properties"><code><span class="token key attr-name">springwolf.plugin.kafka.scanner.kafka-listener.enabled</span><span class="token punctuation">=</span><span class="token value attr-value">false</span>
</code></pre><div class="line-numbers" aria-hidden="true"><div class="line-number"></div></div></div><p>接下来，我们<strong>在同一方法上添加Springwolf @ _AsyncListener_注释</strong>，并为AsyncAPI文档提供额外的信息：</p><div class="language-java line-numbers-mode" data-ext="java" data-title="java"><pre class="language-java"><code><span class="token annotation punctuation">@KafkaListener</span><span class="token punctuation">(</span>topics <span class="token operator">=</span> <span class="token constant">TOPIC_NAME</span><span class="token punctuation">)</span>
<span class="token annotation punctuation">@AsyncListener</span><span class="token punctuation">(</span>
    operation <span class="token operator">=</span> <span class="token annotation punctuation">@AsyncOperation</span><span class="token punctuation">(</span>
        channelName <span class="token operator">=</span> <span class="token constant">TOPIC_NAME</span><span class="token punctuation">,</span>
        description <span class="token operator">=</span> <span class="token string">&quot;More details for the incoming topic&quot;</span>
    <span class="token punctuation">)</span>
<span class="token punctuation">)</span>
<span class="token annotation punctuation">@KafkaAsyncOperationBinding</span>
<span class="token keyword">public</span> <span class="token keyword">void</span> <span class="token function">consume</span><span class="token punctuation">(</span><span class="token class-name">IncomingPayloadDto</span> payload<span class="token punctuation">)</span> <span class="token punctuation">{</span>
    <span class="token comment">// ...</span>
<span class="token punctuation">}</span>
</code></pre><div class="line-numbers" aria-hidden="true"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><p>此外，我们<strong>添加@ _KafkaAsyncOperationBinding_注释</strong>以将通用_@AsyncOperation_注释与_servers_部分中的Kafka代理连接。Kafka协议特定的信息也使用此注释设置。</p><p>更改后，AsyncAPI文档包含了更新的文档。</p><h2 id="_5-记录生产者" tabindex="-1"><a class="header-anchor" href="#_5-记录生产者"><span><strong>5. 记录生产者</strong></span></a></h2><p>通过使用Springwolf _@AsyncPublisher_注释，手动记录生产者。</p><h3 id="_5-1-通过-asyncpublisher-注释手动记录生产者" tabindex="-1"><a class="header-anchor" href="#_5-1-通过-asyncpublisher-注释手动记录生产者"><span><strong>5.1. 通过_@AsyncPublisher_注释手动记录生产者</strong></span></a></h3><p>类似于_@AsyncListener_注释，我们<strong>添加_@AsyncPublisher_注释</strong>到发布者方法，并<strong>也添加_@KafkaAsyncOperationBinding_注释</strong>：</p><div class="language-java line-numbers-mode" data-ext="java" data-title="java"><pre class="language-java"><code><span class="token annotation punctuation">@AsyncPublisher</span><span class="token punctuation">(</span>
    operation <span class="token operator">=</span> <span class="token annotation punctuation">@AsyncOperation</span><span class="token punctuation">(</span>
        channelName <span class="token operator">=</span> <span class="token constant">TOPIC_NAME</span><span class="token punctuation">,</span>
        description <span class="token operator">=</span> <span class="token string">&quot;More details for the outgoing topic&quot;</span>
    <span class="token punctuation">)</span>
<span class="token punctuation">)</span>
<span class="token annotation punctuation">@KafkaAsyncOperationBinding</span>
<span class="token keyword">public</span> <span class="token keyword">void</span> <span class="token function">publish</span><span class="token punctuation">(</span><span class="token class-name">OutgoingPayloadDto</span> payload<span class="token punctuation">)</span> <span class="token punctuation">{</span>
    kafkaTemplate<span class="token punctuation">.</span><span class="token function">send</span><span class="token punctuation">(</span><span class="token constant">TOPIC_NAME</span><span class="token punctuation">,</span> payload<span class="token punctuation">)</span><span class="token punctuation">;</span>
<span class="token punctuation">}</span>
</code></pre><div class="line-numbers" aria-hidden="true"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><p>基于此，Springwolf为_TOPIC_NAME_通道添加了一个_channels_部分的_subscribe_操作，使用上述提供的信息。<strong>_有效载荷类型_从方法签名中提取</strong>，与_@AsyncListener_中的方式相同。</p><h2 id="_6-增强文档" tabindex="-1"><a class="header-anchor" href="#_6-增强文档"><span><strong>6. 增强文档</strong></span></a></h2><p>AsyncAPI规范涵盖了比我们上面提到的更多的特性。接下来，我们记录默认的Spring Kafka头_\\_\\<em>TypeId\\</em>\\__并改进有效载荷的文档。</p><p>当运行原生的Spring Kafka应用程序时，Spring Kafka自动添加头_\\_\\system:翻译继续</p><p>TypeId__以协助消费者中有效载荷的反序列化。</p><p>我们通过在_@AsyncOperation_的_@AsyncListener_（或_@AsyncPublisher_）注释上设置_headers_字段来<strong>将___TypeId__头添加到文档中</strong>：</p><div class="language-java line-numbers-mode" data-ext="java" data-title="java"><pre class="language-java"><code><span class="token annotation punctuation">@AsyncListener</span><span class="token punctuation">(</span>
    operation <span class="token operator">=</span> <span class="token annotation punctuation">@AsyncOperation</span><span class="token punctuation">(</span>
        <span class="token punctuation">.</span><span class="token punctuation">.</span><span class="token punctuation">.</span><span class="token punctuation">,</span>
        headers <span class="token operator">=</span> <span class="token annotation punctuation">@AsyncOperation.Headers</span><span class="token punctuation">(</span>
            schemaName <span class="token operator">=</span> <span class="token string">&quot;SpringKafkaDefaultHeadersIncomingPayloadDto&quot;</span><span class="token punctuation">,</span>
            values <span class="token operator">=</span> <span class="token punctuation">{</span>
                <span class="token comment">// 这个头是由Spring默认生成的</span>
                <span class="token annotation punctuation">@AsyncOperation.Headers.Header</span><span class="token punctuation">(</span>
                    name <span class="token operator">=</span> <span class="token constant">DEFAULT_CLASSID_FIELD_NAME</span><span class="token punctuation">,</span>
                    description <span class="token operator">=</span> <span class="token string">&quot;Spring 类型 ID 头&quot;</span><span class="token punctuation">,</span>
                    value <span class="token operator">=</span> <span class="token string">&quot;com.baeldung.boot.documentation.springwolf.dto.IncomingPayloadDto&quot;</span>
                <span class="token punctuation">)</span><span class="token punctuation">,</span>
            <span class="token punctuation">}</span>
        <span class="token punctuation">)</span>
    <span class="token punctuation">)</span>
<span class="token punctuation">)</span>
</code></pre><div class="line-numbers" aria-hidden="true"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><p>现在，AsyncAPI文档包含了作为_message_对象一部分的新字段_headers_。</p><h3 id="_6-2-添加有效载荷详细信息" tabindex="-1"><a class="header-anchor" href="#_6-2-添加有效载荷详细信息"><span><strong>6.2. 添加有效载荷详细信息</strong></span></a></h3><p>我们<strong>使用Swagger _@Schema_注释</strong>来提供有关有效载荷的额外信息。在以下代码片段中，我们设置了_description_、一个_example_值，以及字段是否是_required_：</p><div class="language-java line-numbers-mode" data-ext="java" data-title="java"><pre class="language-java"><code><span class="token annotation punctuation">@Schema</span><span class="token punctuation">(</span>description <span class="token operator">=</span> <span class="token string">&quot;出站有效载荷模型&quot;</span><span class="token punctuation">)</span>
<span class="token keyword">public</span> <span class="token keyword">class</span> <span class="token class-name">OutgoingPayloadDto</span> <span class="token punctuation">{</span>
    <span class="token annotation punctuation">@Schema</span><span class="token punctuation">(</span>description <span class="token operator">=</span> <span class="token string">&quot;Foo 字段&quot;</span><span class="token punctuation">,</span> example <span class="token operator">=</span> <span class="token string">&quot;bar&quot;</span><span class="token punctuation">,</span> requiredMode <span class="token operator">=</span> <span class="token constant">NOT_REQUIRED</span><span class="token punctuation">)</span>
    <span class="token keyword">private</span> <span class="token class-name">String</span> foo<span class="token punctuation">;</span>

    <span class="token annotation punctuation">@Schema</span><span class="token punctuation">(</span>description <span class="token operator">=</span> <span class="token string">&quot;IncomingPayload 字段&quot;</span><span class="token punctuation">,</span> requiredMode <span class="token operator">=</span> <span class="token constant">REQUIRED</span><span class="token punctuation">)</span>
    <span class="token keyword">private</span> <span class="token class-name">IncomingPayloadDto</span> incomingWrapped<span class="token punctuation">;</span>
<span class="token punctuation">}</span>
</code></pre><div class="line-numbers" aria-hidden="true"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><p>基于此，我们在AsyncAPI文档中看到了丰富的_OutgoingPayloadDto_模式：</p><div class="language-json line-numbers-mode" data-ext="json" data-title="json"><pre class="language-json"><code><span class="token property">&quot;OutgoingPayloadDto&quot;</span><span class="token operator">:</span> <span class="token punctuation">{</span>
    <span class="token property">&quot;type&quot;</span><span class="token operator">:</span> <span class="token string">&quot;object&quot;</span><span class="token punctuation">,</span>
    <span class="token property">&quot;description&quot;</span><span class="token operator">:</span> <span class="token string">&quot;出站有效载荷模型&quot;</span><span class="token punctuation">,</span>
    <span class="token property">&quot;properties&quot;</span><span class="token operator">:</span> <span class="token punctuation">{</span>
        <span class="token property">&quot;incomingWrapped&quot;</span><span class="token operator">:</span> <span class="token punctuation">{</span>
            <span class="token property">&quot;$ref&quot;</span><span class="token operator">:</span> <span class="token string">&quot;#/components/schemas/IncomingPayloadDto&quot;</span>
        <span class="token punctuation">}</span><span class="token punctuation">,</span>
        <span class="token property">&quot;foo&quot;</span><span class="token operator">:</span> <span class="token punctuation">{</span>
            <span class="token property">&quot;type&quot;</span><span class="token operator">:</span> <span class="token string">&quot;string&quot;</span><span class="token punctuation">,</span>
            <span class="token property">&quot;description&quot;</span><span class="token operator">:</span> <span class="token string">&quot;Foo 字段&quot;</span><span class="token punctuation">,</span>
            <span class="token property">&quot;example&quot;</span><span class="token operator">:</span> <span class="token string">&quot;bar&quot;</span>
        <span class="token punctuation">}</span>
    <span class="token punctuation">}</span><span class="token punctuation">,</span>
    <span class="token property">&quot;required&quot;</span><span class="token operator">:</span> <span class="token punctuation">[</span>
        <span class="token string">&quot;incomingWrapped&quot;</span>
    <span class="token punctuation">]</span><span class="token punctuation">,</span>
    <span class="token property">&quot;example&quot;</span><span class="token operator">:</span> <span class="token punctuation">{</span>
        <span class="token property">&quot;incomingWrapped&quot;</span><span class="token operator">:</span> <span class="token punctuation">{</span>
            <span class="token property">&quot;someEnum&quot;</span><span class="token operator">:</span> <span class="token string">&quot;FOO2&quot;</span><span class="token punctuation">,</span>
            <span class="token property">&quot;someLong&quot;</span><span class="token operator">:</span> <span class="token number">5</span><span class="token punctuation">,</span>
            <span class="token property">&quot;someString&quot;</span><span class="token operator">:</span> <span class="token string">&quot;some string value&quot;</span>
        <span class="token punctuation">}</span><span class="token punctuation">,</span>
        <span class="token property">&quot;foo&quot;</span><span class="token operator">:</span> <span class="token string">&quot;bar&quot;</span>
    <span class="token punctuation">}</span>
<span class="token punctuation">}</span>
</code></pre><div class="line-numbers" aria-hidden="true"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><p>我们应用程序的完整AsyncAPI文档可在链接的示例项目中找到。</p><p>Springwolf有自己的UI，尽管可以使用任何符合AsyncAPI的文档渲染器。</p><h3 id="_7-1-添加-springwolf-ui-依赖项" tabindex="-1"><a class="header-anchor" href="#_7-1-添加-springwolf-ui-依赖项"><span><strong>7.1. 添加_springwolf-ui_依赖项</strong></span></a></h3><p>要使用_springwolf-ui_，我们将依赖项添加到我们的_pom.xml_中，重新构建并重新启动应用程序：</p><div class="language-xml line-numbers-mode" data-ext="xml" data-title="xml"><pre class="language-xml"><code>\`\`<span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>dependency</span><span class="token punctuation">&gt;</span></span>\`\`
    \`\`<span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>groupId</span><span class="token punctuation">&gt;</span></span>\`\`io.github.springwolf\`\`<span class="token tag"><span class="token tag"><span class="token punctuation">&lt;/</span>groupId</span><span class="token punctuation">&gt;</span></span>\`\`
    \`\`<span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>artifactId</span><span class="token punctuation">&gt;</span></span>\`\`springwolf-ui\`\`<span class="token tag"><span class="token tag"><span class="token punctuation">&lt;/</span>artifactId</span><span class="token punctuation">&gt;</span></span>\`\`
    \`\`<span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>version</span><span class="token punctuation">&gt;</span></span>\`\`0.8.0\`\`<span class="token tag"><span class="token tag"><span class="token punctuation">&lt;/</span>version</span><span class="token punctuation">&gt;</span></span>\`\`
\`\`<span class="token tag"><span class="token tag"><span class="token punctuation">&lt;/</span>dependency</span><span class="token punctuation">&gt;</span></span>\`\`
</code></pre><div class="line-numbers" aria-hidden="true"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><h3 id="_7-2-查看asyncapi文档" tabindex="-1"><a class="header-anchor" href="#_7-2-查看asyncapi文档"><span><strong>7.2. 查看AsyncAPI文档</strong></span></a></h3><p>现在，我们通过访问_http://localhost:8080/springwolf/asyncapi-ui.html_在浏览器中打开文档。</p><p>网页与AsyncAPI文档的结构类似，并显示有关_application_、<em>server</em>、_channels_和_schemas_的信息：</p><figure><img src="https://www.baeldung.com/wp-content/uploads/2023/07/springwolf-ui.jpg" alt="img" tabindex="0" loading="lazy"><figcaption>img</figcaption></figure><h3 id="_7-3-发布消息" tabindex="-1"><a class="header-anchor" href="#_7-3-发布消息"><span><strong>7.3. 发布消息</strong></span></a></h3><p>Springwolf允许我们直接从浏览器发布消息。展开一个_channel_后，点击_Publish_按钮可以直接将消息放到Kafka上。消息绑定（包括Kafka消息键）、头和消息可以根据需要进行调整：</p><figure><img src="https://www.baeldung.com/wp-content/uploads/2023/07/springwolf-ui-publish-1.jpg" alt="img" tabindex="0" loading="lazy"><figcaption>img</figcaption></figure><p>由于安全问题，此功能默认情况下是禁用的。要启用发布，我们将以下行添加到我们的_application.properties_文件中：</p><div class="language-properties line-numbers-mode" data-ext="properties" data-title="properties"><pre class="language-properties"><code><span class="token key attr-name">springwolf.plugin.kafka.publishing.enabled</span><span class="token punctuation">=</span><span class="token value attr-value">true</span>
</code></pre><div class="line-numbers" aria-hidden="true"><div class="line-number"></div></div></div><h2 id="_8-结论" tabindex="-1"><a class="header-anchor" href="#_8-结论"><span><strong>8. 结论</strong></span></a></h2><p>在本文中，我们在现有的Spring Boot Kafka应用程序中设置了Springwolf。</p><p>使用消费者自动检测，自动生成了符合AsyncAPI的文档。我们通过手动配置进一步增强了文档。</p><p>除了通过提供的REST端点下载AsyncAPI文档外，我们还使用_springwolf-ui_在浏览器中查看文档。</p><p>如往常一样，示例的源代码可在GitHub上找到。</p><figure><img src="https://www.baeldung.com/wp-content/uploads/2022/04/announcement-icon.png" alt="img" tabindex="0" loading="lazy"><figcaption>img</figcaption></figure><p>OK</p>`,93),o=[p];function i(l,c){return a(),s("div",null,o)}const d=n(e,[["render",i],["__file","2024-07-03-Documenting Spring Event Driven API Using AsyncAPI and Springwolf.html.vue"]]),k=JSON.parse('{"path":"/posts/baeldung/2024-07-03/2024-07-03-Documenting%20Spring%20Event%20Driven%20API%20Using%20AsyncAPI%20and%20Springwolf.html","title":"使用AsyncAPI和Springwolf记录Spring事件驱动API","lang":"zh-CN","frontmatter":{"date":"2023-07-31T00:00:00.000Z","category":["Spring Boot","AsyncAPI"],"tag":["Springwolf","Event-Driven","Documentation"],"head":[["meta",{"name":"keywords","content":"Springwolf, AsyncAPI, Spring Boot, Event-Driven, Documentation"}],["meta",{"property":"og:url","content":"https://www.kahen.xyz/posts/baeldung/2024-07-03/2024-07-03-Documenting%20Spring%20Event%20Driven%20API%20Using%20AsyncAPI%20and%20Springwolf.html"}],["meta",{"property":"og:site_name","content":"Baeldung 中文网"}],["meta",{"property":"og:title","content":"使用AsyncAPI和Springwolf记录Spring事件驱动API"}],["meta",{"property":"og:description","content":"使用AsyncAPI和Springwolf记录Spring事件驱动API 记录API是构建应用程序的重要部分。它是我们与客户共享的合同。此外，它详细记录了我们的集成点如何工作。文档应该易于访问、理解和实现。 在本教程中，我们将研究Springwolf，用于记录事件驱动的Spring Boot服务。Springwolf实现了AsyncAPI规范，这是Op..."}],["meta",{"property":"og:type","content":"article"}],["meta",{"property":"og:image","content":"https://www.baeldung.com/wp-content/uploads/2023/07/springwolf-ui.jpg"}],["meta",{"property":"og:locale","content":"zh-CN"}],["meta",{"property":"og:updated_time","content":"2024-07-03T08:56:31.000Z"}],["meta",{"property":"article:author","content":"Kahen"}],["meta",{"property":"article:tag","content":"Springwolf"}],["meta",{"property":"article:tag","content":"Event-Driven"}],["meta",{"property":"article:tag","content":"Documentation"}],["meta",{"property":"article:published_time","content":"2023-07-31T00:00:00.000Z"}],["meta",{"property":"article:modified_time","content":"2024-07-03T08:56:31.000Z"}],["script",{"type":"application/ld+json"},"{\\"@context\\":\\"https://schema.org\\",\\"@type\\":\\"Article\\",\\"headline\\":\\"使用AsyncAPI和Springwolf记录Spring事件驱动API\\",\\"image\\":[\\"https://www.baeldung.com/wp-content/uploads/2023/07/springwolf-ui.jpg\\",\\"https://www.baeldung.com/wp-content/uploads/2023/07/springwolf-ui-publish-1.jpg\\",\\"https://www.baeldung.com/wp-content/uploads/2022/04/announcement-icon.png\\"],\\"datePublished\\":\\"2023-07-31T00:00:00.000Z\\",\\"dateModified\\":\\"2024-07-03T08:56:31.000Z\\",\\"author\\":[{\\"@type\\":\\"Person\\",\\"name\\":\\"Kahen\\",\\"url\\":\\"https://www.kahen.xyz\\"}]}"]],"description":"使用AsyncAPI和Springwolf记录Spring事件驱动API 记录API是构建应用程序的重要部分。它是我们与客户共享的合同。此外，它详细记录了我们的集成点如何工作。文档应该易于访问、理解和实现。 在本教程中，我们将研究Springwolf，用于记录事件驱动的Spring Boot服务。Springwolf实现了AsyncAPI规范，这是Op..."},"headers":[{"level":2,"title":"2. 设置Springwolf","slug":"_2-设置springwolf","link":"#_2-设置springwolf","children":[{"level":3,"title":"2.1. 添加依赖项","slug":"_2-1-添加依赖项","link":"#_2-1-添加依赖项","children":[]},{"level":3,"title":"2.2. application.properties 配置","slug":"_2-2-application-properties-配置","link":"#_2-2-application-properties-配置","children":[]},{"level":3,"title":"2.3. 验证","slug":"_2-3-验证","link":"#_2-3-验证","children":[]}]},{"level":2,"title":"3. AsyncAPI文档","slug":"_3-asyncapi文档","link":"#_3-asyncapi文档","children":[{"level":3,"title":"3.1. info 部分","slug":"_3-1-info-部分","link":"#_3-1-info-部分","children":[]},{"level":3,"title":"3.2. servers 部分","slug":"_3-2-servers-部分","link":"#_3-2-servers-部分","children":[]},{"level":3,"title":"3.3. channels 部分","slug":"_3-3-channels-部分","link":"#_3-3-channels-部分","children":[]},{"level":3,"title":"3.4. components 部分","slug":"_3-4-components-部分","link":"#_3-4-components-部分","children":[]}]},{"level":2,"title":"4. 记录消费者","slug":"_4-记录消费者","link":"#_4-记录消费者","children":[{"level":3,"title":"4.1. 自动检测_@KafkaListener_注释","slug":"_4-1-自动检测-kafkalistener-注释","link":"#_4-1-自动检测-kafkalistener-注释","children":[]},{"level":3,"title":"4.2. 通过_@AsyncListener_注释手动记录消费者","slug":"_4-2-通过-asynclistener-注释手动记录消费者","link":"#_4-2-通过-asynclistener-注释手动记录消费者","children":[]}]},{"level":2,"title":"5. 记录生产者","slug":"_5-记录生产者","link":"#_5-记录生产者","children":[{"level":3,"title":"5.1. 通过_@AsyncPublisher_注释手动记录生产者","slug":"_5-1-通过-asyncpublisher-注释手动记录生产者","link":"#_5-1-通过-asyncpublisher-注释手动记录生产者","children":[]}]},{"level":2,"title":"6. 增强文档","slug":"_6-增强文档","link":"#_6-增强文档","children":[{"level":3,"title":"6.2. 添加有效载荷详细信息","slug":"_6-2-添加有效载荷详细信息","link":"#_6-2-添加有效载荷详细信息","children":[]},{"level":3,"title":"7.1. 添加_springwolf-ui_依赖项","slug":"_7-1-添加-springwolf-ui-依赖项","link":"#_7-1-添加-springwolf-ui-依赖项","children":[]},{"level":3,"title":"7.2. 查看AsyncAPI文档","slug":"_7-2-查看asyncapi文档","link":"#_7-2-查看asyncapi文档","children":[]},{"level":3,"title":"7.3. 发布消息","slug":"_7-3-发布消息","link":"#_7-3-发布消息","children":[]}]},{"level":2,"title":"8. 结论","slug":"_8-结论","link":"#_8-结论","children":[]}],"git":{"createdTime":1719996991000,"updatedTime":1719996991000,"contributors":[{"name":"Kahen","email":"Kahen@users.noreply.github.com","commits":1}]},"readingTime":{"minutes":7.32,"words":2195},"filePathRelative":"posts/baeldung/2024-07-03/2024-07-03-Documenting Spring Event Driven API Using AsyncAPI and Springwolf.md","localizedDate":"2023年7月31日","excerpt":"\\n<p>记录API是构建应用程序的重要部分。它是我们与客户共享的合同。此外，它详细记录了我们的集成点如何工作。文档应该易于访问、理解和实现。</p>\\n<p>在本教程中，我们将研究Springwolf，用于记录事件驱动的Spring Boot服务。Springwolf实现了AsyncAPI规范，这是OpenAPI规范的事件驱动API的适配。<strong>Springwolf是协议不可知的，涵盖了Spring Kafka、Spring RabbitMQ和Spring CloudStream实现。</strong></p>\\n<p>使用Spring Kafka作为我们的事件驱动系统，**Springwolf为我们从代码生成AsyncAPI文档。**一些消费者会自动检测到。其他信息由我们提供。</p>","autoDesc":true}');export{d as comp,k as data};
