import{_ as n}from"./plugin-vue_export-helper-DlAUqK2U.js";import{c as a,o as s,a as t}from"./app-DNwYcgl6.js";const e={},p=t('<h1 id="completablefuture中的重试逻辑" tabindex="-1"><a class="header-anchor" href="#completablefuture中的重试逻辑"><span>CompletableFuture中的重试逻辑</span></a></h1><p>在这篇文章中，我们将学习如何对CompletableFuture对象应用重试逻辑。起初，我们将重试封装在CompletableFuture中的任务。之后，我们将利用CompletableFuture API创建多个实例的链，使我们能够在将来遇到异常完成时重新执行任务。</p><h3 id="_2-重试任务" tabindex="-1"><a class="header-anchor" href="#_2-重试任务"><span>2. 重试任务</span></a></h3><p><strong>简单重试任务的方法是利用装饰者模式，并使用传统的面向对象风格通过类和接口实现它。</strong> 另一方面，我们可以选择更简洁和函数式的方法，利用高阶函数的优势。</p><p>首先，我们将声明一个函数，它接受一个Supplier<code>&lt;T&gt;</code>和最大调用次数作为参数。然后，我们将使用while循环和try-catch块在需要时多次调用函数。最后，我们将通过返回另一个Supplier<code>&lt;T&gt;</code>来保留原始数据类型：</p><div class="language-java line-numbers-mode" data-ext="java" data-title="java"><pre class="language-java"><code><span class="token keyword">static</span> ```````````````````````````<span class="token generics"><span class="token punctuation">&lt;</span><span class="token class-name">T</span><span class="token punctuation">&gt;</span></span>``````````````````````````` <span class="token class-name">Supplier</span>```````````````````````````<span class="token generics"><span class="token punctuation">&lt;</span><span class="token class-name">T</span><span class="token punctuation">&gt;</span></span>``````````````````````````` <span class="token function">retryFunction</span><span class="token punctuation">(</span><span class="token class-name">Supplier</span>```````````````````````````<span class="token generics"><span class="token punctuation">&lt;</span><span class="token class-name">T</span><span class="token punctuation">&gt;</span></span>``````````````````````````` supplier<span class="token punctuation">,</span> <span class="token keyword">int</span> maxRetries<span class="token punctuation">)</span> <span class="token punctuation">{</span>\n    <span class="token keyword">return</span> <span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token operator">-&gt;</span> <span class="token punctuation">{</span>\n        <span class="token keyword">int</span> retries <span class="token operator">=</span> <span class="token number">0</span><span class="token punctuation">;</span>\n        <span class="token keyword">while</span> <span class="token punctuation">(</span>retries <span class="token operator">&lt;</span> maxRetries<span class="token punctuation">)</span> <span class="token punctuation">{</span>\n            <span class="token keyword">try</span> <span class="token punctuation">{</span>\n                <span class="token keyword">return</span> supplier<span class="token punctuation">.</span><span class="token function">get</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>\n            <span class="token punctuation">}</span> <span class="token keyword">catch</span> <span class="token punctuation">(</span><span class="token class-name">Exception</span> e<span class="token punctuation">)</span> <span class="token punctuation">{</span>\n                retries<span class="token operator">++</span><span class="token punctuation">;</span>\n            <span class="token punctuation">}</span>\n        <span class="token punctuation">}</span>\n        <span class="token keyword">throw</span> <span class="token keyword">new</span> <span class="token class-name">IllegalStateException</span><span class="token punctuation">(</span><span class="token class-name">String</span><span class="token punctuation">.</span><span class="token function">format</span><span class="token punctuation">(</span><span class="token string">&quot;任务在%s次尝试后失败&quot;</span><span class="token punctuation">,</span> maxRetries<span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">;</span>\n    <span class="token punctuation">}</span><span class="token punctuation">;</span>\n<span class="token punctuation">}</span>\n</code></pre><div class="line-numbers" aria-hidden="true"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><p>我们可以进一步改进这个装饰器，允许定义特定的异常进行重试，或者引入调用之间的延迟。但是，为了简单起见，让我们继续创建基于此函数装饰器的CompletableFuture：</p><div class="language-java line-numbers-mode" data-ext="java" data-title="java"><pre class="language-java"><code><span class="token keyword">static</span> ```````````````````````````<span class="token generics"><span class="token punctuation">&lt;</span><span class="token class-name">T</span><span class="token punctuation">&gt;</span></span>``````````````````````````` <span class="token class-name">CompletableFuture</span>```````````````````````````<span class="token generics"><span class="token punctuation">&lt;</span><span class="token class-name">T</span><span class="token punctuation">&gt;</span></span>``````````````````````````` <span class="token function">retryTask</span><span class="token punctuation">(</span><span class="token class-name">Supplier</span>```````````````````````````<span class="token generics"><span class="token punctuation">&lt;</span><span class="token class-name">T</span><span class="token punctuation">&gt;</span></span>``````````````````````````` supplier<span class="token punctuation">,</span> <span class="token keyword">int</span> maxRetries<span class="token punctuation">)</span> <span class="token punctuation">{</span>\n    <span class="token class-name">Supplier</span>```````````````````````````<span class="token generics"><span class="token punctuation">&lt;</span><span class="token class-name">T</span><span class="token punctuation">&gt;</span></span>``````````````````````````` retryableSupplier <span class="token operator">=</span> <span class="token function">retryFunction</span><span class="token punctuation">(</span>supplier<span class="token punctuation">,</span> maxRetries<span class="token punctuation">)</span><span class="token punctuation">;</span>\n    <span class="token keyword">return</span> <span class="token class-name">CompletableFuture</span><span class="token punctuation">.</span><span class="token function">supplyAsync</span><span class="token punctuation">(</span>retryableSupplier<span class="token punctuation">)</span><span class="token punctuation">;</span>\n<span class="token punctuation">}</span>\n</code></pre><div class="line-numbers" aria-hidden="true"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><p>现在，让我们继续编写此功能的测试。首先，我们需要一个将被我们的CompletableFuture重试的方法。为此，我们将设计一个方法，该方法通过抛出RuntimeExceptions失败四次，并在第五次尝试时成功完成，返回一个整数值：</p><div class="language-java line-numbers-mode" data-ext="java" data-title="java"><pre class="language-java"><code><span class="token class-name">AtomicInteger</span> retriesCounter <span class="token operator">=</span> <span class="token keyword">new</span> <span class="token class-name">AtomicInteger</span><span class="token punctuation">(</span><span class="token number">0</span><span class="token punctuation">)</span><span class="token punctuation">;</span>\n\n<span class="token annotation punctuation">@BeforeEach</span>\n<span class="token keyword">void</span> <span class="token function">beforeEach</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>\n    retriesCounter<span class="token punctuation">.</span><span class="token function">set</span><span class="token punctuation">(</span><span class="token number">0</span><span class="token punctuation">)</span><span class="token punctuation">;</span>\n<span class="token punctuation">}</span>\n\n<span class="token keyword">int</span> <span class="token function">failFourTimesThenReturn</span><span class="token punctuation">(</span><span class="token keyword">int</span> returnValue<span class="token punctuation">)</span> <span class="token punctuation">{</span>\n    <span class="token keyword">int</span> retryNr <span class="token operator">=</span> retriesCounter<span class="token punctuation">.</span><span class="token function">get</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>\n    <span class="token keyword">if</span> <span class="token punctuation">(</span>retryNr `<span class="token operator">&lt;</span> <span class="token number">4</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>\n        retriesCounter<span class="token punctuation">.</span><span class="token function">set</span><span class="token punctuation">(</span>retryNr <span class="token operator">+</span> <span class="token number">1</span><span class="token punctuation">)</span><span class="token punctuation">;</span>\n        <span class="token keyword">throw</span> <span class="token keyword">new</span> <span class="token class-name">RuntimeException</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>\n    <span class="token punctuation">}</span>\n    <span class="token keyword">return</span> returnValue<span class="token punctuation">;</span>\n<span class="token punctuation">}</span>\n</code></pre><div class="line-numbers" aria-hidden="true"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><p>现在，我们终于可以测试我们的retryTask()函数，并断言返回了预期的值。此外，我们可以通过查询retriesCounter来检查调用次数：</p><div class="language-java line-numbers-mode" data-ext="java" data-title="java"><pre class="language-java"><code><span class="token annotation punctuation">@Test</span>\n<span class="token keyword">void</span> <span class="token function">whenRetryingTask_thenReturnsCorrectlyAfterFourInvocations</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>\n    <span class="token class-name">Supplier</span>```<span class="token generics"><span class="token punctuation">&lt;</span><span class="token class-name">Integer</span><span class="token punctuation">&gt;</span></span>```` codeToRun <span class="token operator">=</span> <span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token operator">-&gt;</span> <span class="token function">failFourTimesThenReturn</span><span class="token punctuation">(</span><span class="token number">100</span><span class="token punctuation">)</span><span class="token punctuation">;</span>\n\n    <span class="token class-name">CompletableFuture</span>```<span class="token generics"><span class="token punctuation">&lt;</span><span class="token class-name">Integer</span><span class="token punctuation">&gt;</span></span>``` result <span class="token operator">=</span> <span class="token function">retryTask</span><span class="token punctuation">(</span>codeToRun<span class="token punctuation">,</span> <span class="token number">10</span><span class="token punctuation">)</span><span class="token punctuation">;</span>\n\n    <span class="token function">assertThat</span><span class="token punctuation">(</span>result<span class="token punctuation">.</span><span class="token function">join</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">.</span><span class="token function">isEqualTo</span><span class="token punctuation">(</span><span class="token number">100</span><span class="token punctuation">)</span><span class="token punctuation">;</span>\n    <span class="token function">assertThat</span><span class="token punctuation">(</span>retriesCounter<span class="token punctuation">)</span><span class="token punctuation">.</span><span class="token function">hasValue</span><span class="token punctuation">(</span><span class="token number">4</span><span class="token punctuation">)</span><span class="token punctuation">;</span>\n<span class="token punctuation">}</span>\n</code></pre><div class="line-numbers" aria-hidden="true"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><p>此外，如果我们使用较小的值调用同一个函数的maxRetires参数，我们将期望Future异常完成。原始的IllegalStateException应该被包装在CompletionException中，但原始的错误消息应该被保留：</p><div class="language-java line-numbers-mode" data-ext="java" data-title="java"><pre class="language-java"><code><span class="token annotation punctuation">@Test</span>\n<span class="token keyword">void</span> <span class="token function">whenRetryingTask_thenThrowsExceptionAfterThreeInvocations</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>\n    <span class="token class-name">Supplier</span>```<span class="token generics"><span class="token punctuation">&lt;</span><span class="token class-name">Integer</span><span class="token punctuation">&gt;</span></span>``` codeToRun <span class="token operator">=</span> <span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token operator">-&gt;</span> <span class="token function">failFourTimesThenReturn</span><span class="token punctuation">(</span><span class="token number">100</span><span class="token punctuation">)</span><span class="token punctuation">;</span>\n\n    <span class="token class-name">CompletableFuture</span>```<span class="token generics"><span class="token punctuation">&lt;</span><span class="token class-name">Integer</span><span class="token punctuation">&gt;</span></span>``` result <span class="token operator">=</span> <span class="token function">retryTask</span><span class="token punctuation">(</span>codeToRun<span class="token punctuation">,</span> <span class="token number">3</span><span class="token punctuation">)</span><span class="token punctuation">;</span>\n\n    <span class="token function">assertThatThrownBy</span><span class="token punctuation">(</span>result<span class="token operator">::</span><span class="token function">join</span><span class="token punctuation">)</span>\n        <span class="token punctuation">.</span><span class="token function">isInstanceOf</span><span class="token punctuation">(</span><span class="token class-name">CompletionException</span><span class="token punctuation">.</span><span class="token keyword">class</span><span class="token punctuation">)</span>\n        <span class="token punctuation">.</span><span class="token function">hasMessageContaining</span><span class="token punctuation">(</span><span class="token string">&quot;IllegalStateException: Task failed after 3 attempts&quot;</span><span class="token punctuation">)</span><span class="token punctuation">;</span>\n<span class="token punctuation">}</span>\n</code></pre><div class="line-numbers" aria-hidden="true"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><h3 id="_3-重试completablefuture" tabindex="-1"><a class="header-anchor" href="#_3-重试completablefuture"><span>3. 重试CompletableFuture</span></a></h3><p><strong>CompletableFuture API提供了处理异常的选项，因为它们出现。因此，我们可以利用exceptionally()等方法，而不是创建我们自己的函数装饰器。</strong></p><h4 id="_3-1-不安全的重试" tabindex="-1"><a class="header-anchor" href="#_3-1-不安全的重试"><span>3.1. 不安全的重试</span></a></h4><p>exceptionally()方法使我们能够指定一个备选函数，当初始调用因异常而完成时，将调用此函数。例如，如果我们打算重试两次调用，我们可以利用流畅的API添加这两个回退：</p><div class="language-java line-numbers-mode" data-ext="java" data-title="java"><pre class="language-java"><code><span class="token keyword">static</span> ```````````````````````````<span class="token generics"><span class="token punctuation">&lt;</span><span class="token class-name">T</span><span class="token punctuation">&gt;</span></span>``````````````````````````` <span class="token class-name">CompletableFuture</span>```````````````````````````<span class="token generics"><span class="token punctuation">&lt;</span><span class="token class-name">T</span><span class="token punctuation">&gt;</span></span>``````````````````````````` <span class="token function">retryTwice</span><span class="token punctuation">(</span><span class="token class-name">Supplier</span>```````````````````````````<span class="token generics"><span class="token punctuation">&lt;</span><span class="token class-name">T</span><span class="token punctuation">&gt;</span></span>``````````````````````````` supplier<span class="token punctuation">)</span> <span class="token punctuation">{</span>\n    <span class="token keyword">return</span> <span class="token class-name">CompletableFuture</span><span class="token punctuation">.</span><span class="token function">supplyAsync</span><span class="token punctuation">(</span>supplier<span class="token punctuation">)</span>\n      <span class="token punctuation">.</span><span class="token function">exceptionally</span><span class="token punctuation">(</span>__ <span class="token operator">-&gt;</span> supplier<span class="token punctuation">.</span><span class="token function">get</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">)</span>\n      <span class="token punctuation">.</span><span class="token function">exceptionally</span><span class="token punctuation">(</span>__ <span class="token operator">-&gt;</span> supplier<span class="token punctuation">.</span><span class="token function">get</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">;</span>\n<span class="token punctuation">}</span>\n</code></pre><div class="line-numbers" aria-hidden="true"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><p>由于我们需要可变的重试次数，让我们重构代码，改用for循环：</p><div class="language-java line-numbers-mode" data-ext="java" data-title="java"><pre class="language-java"><code><span class="token keyword">static</span> ```````````````````````````<span class="token generics"><span class="token punctuation">&lt;</span><span class="token class-name">T</span><span class="token punctuation">&gt;</span></span>``````````````````````````` <span class="token class-name">CompletableFuture</span>```````````````````````````<span class="token generics"><span class="token punctuation">&lt;</span><span class="token class-name">T</span><span class="token punctuation">&gt;</span></span>``````````````````````````` <span class="token function">retryUnsafe</span><span class="token punctuation">(</span><span class="token class-name">Supplier</span>```````````````````````````<span class="token generics"><span class="token punctuation">&lt;</span><span class="token class-name">T</span><span class="token punctuation">&gt;</span></span>``````````````````````````` supplier<span class="token punctuation">,</span> <span class="token keyword">int</span> maxRetries<span class="token punctuation">)</span> <span class="token punctuation">{</span>\n    <span class="token class-name">CompletableFuture</span>```````````````````````````<span class="token generics"><span class="token punctuation">&lt;</span><span class="token class-name">T</span><span class="token punctuation">&gt;</span></span>``````````````````````````` cf <span class="token operator">=</span> <span class="token class-name">CompletableFuture</span><span class="token punctuation">.</span><span class="token function">supplyAsync</span><span class="token punctuation">(</span>supplier<span class="token punctuation">)</span><span class="token punctuation">;</span>\n    <span class="token keyword">for</span> <span class="token punctuation">(</span><span class="token keyword">int</span> i <span class="token operator">=</span> <span class="token number">0</span><span class="token punctuation">;</span> i ``<span class="token operator">&lt;</span> maxRetries<span class="token punctuation">;</span> i<span class="token operator">++</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>\n        cf <span class="token operator">=</span> cf<span class="token punctuation">.</span><span class="token function">exceptionally</span><span class="token punctuation">(</span>__ <span class="token operator">-&gt;</span>`` supplier<span class="token punctuation">.</span><span class="token function">get</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">;</span>\n    <span class="token punctuation">}</span>\n    <span class="token keyword">return</span> cf<span class="token punctuation">;</span>\n<span class="token punctuation">}</span>\n</code></pre><div class="line-numbers" aria-hidden="true"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><p>我们可以使用相同的测试助手测试retryUnsafe()，并预期类似的结果。然而，如果初始供应商在创建具有所有exceptionally()回退的最终CompletableFuture之前完成，将会有一个微妙的区别。在这种情况下，函数确实会被重试指定的次数。但是，这个重试过程将在主线程上进行，导致异步性的丧失。</p><p>为了说明这一点，我们可以在for循环之前插入一个100毫秒的暂停，该循环依次调用exceptionally()方法。</p><div class="language-java line-numbers-mode" data-ext="java" data-title="java"><pre class="language-java"><code><span class="token keyword">static</span> ```````````````````````````<span class="token generics"><span class="token punctuation">&lt;</span><span class="token class-name">T</span><span class="token punctuation">&gt;</span></span>``````````````````````````` <span class="token class-name">CompletableFuture</span>```````````````````````````<span class="token generics"><span class="token punctuation">&lt;</span><span class="token class-name">T</span><span class="token punctuation">&gt;</span></span>``````````````````````````` <span class="token function">retryUnsafe</span><span class="token punctuation">(</span><span class="token class-name">Supplier</span>```````````````````````````<span class="token generics"><span class="token punctuation">&lt;</span><span class="token class-name">T</span><span class="token punctuation">&gt;</span></span>``````````````````````````` supplier<span class="token punctuation">,</span> <span class="token keyword">int</span> maxRetries<span class="token punctuation">)</span> <span class="token punctuation">{</span>\n    <span class="token class-name">CompletableFuture</span>```````````````````````````<span class="token generics"><span class="token punctuation">&lt;</span><span class="token class-name">T</span><span class="token punctuation">&gt;</span></span>``````````````````````````` cf <span class="token operator">=</span> <span class="token class-name">CompletableFuture</span><span class="token punctuation">.</span><span class="token function">supplyAsync</span><span class="token punctuation">(</span>supplier<span class="token punctuation">)</span><span class="token punctuation">;</span>\n    <span class="token function">sleep</span><span class="token punctuation">(</span><span class="token number">100l</span><span class="token punctuation">)</span><span class="token punctuation">;</span>\n    <span class="token keyword">for</span> <span class="token punctuation">(</span><span class="token keyword">int</span> i <span class="token operator">=</span> <span class="token number">0</span><span class="token punctuation">;</span> i ``<span class="token operator">&lt;</span> maxRetries<span class="token punctuation">;</span> i<span class="token operator">++</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>\n        cf <span class="token operator">=</span> cf<span class="token punctuation">.</span><span class="token function">exceptionally</span><span class="token punctuation">(</span>__ <span class="token operator">-&gt;</span>`` supplier<span class="token punctuation">.</span><span class="token function">get</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">;</span>\n    <span class="token punctuation">}</span>\n    <span class="token keyword">return</span> cf<span class="token punctuation">;</span>\n<span class="token punctuation">}</span>\n</code></pre><div class="line-numbers" aria-hidden="true"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><p>接下来，我们将修改failFourTimesThenReturn()测试方法，以记录每次调用此方法时的尝试次数和当前线程名称。现在，让我们重新运行测试并检查控制台：</p><div class="language-plaintext line-numbers-mode" data-ext="plaintext" data-title="plaintext"><pre class="language-plaintext"><code>invocation: 0, thread: ForkJoinPool.commonPool-worker-1\ninvocation: 1, thread: main\ninvocation: 2, thread: main\ninvocation: 3, thread: main\ninvocation: 4, thread: main\n</code></pre><div class="line-numbers" aria-hidden="true"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><p>正如预期的那样，后续调用是由主线程执行的。如果初始调用很快，但随后的调用预计会更慢，这可能会成为问题。</p><h4 id="_3-2-异步重试" tabindex="-1"><a class="header-anchor" href="#_3-2-异步重试"><span>3.2. 异步重试</span></a></h4><p>我们可以通过确保后续调用异步执行来解决这个问题。为此，从Java 12开始，API中引入了一个专用方法。<strong>通过使用exceptionallyAsync()，我们将确保所有重试都将异步执行，无论初始CompletableFuture完成的速度如何</strong>：</p><div class="language-java line-numbers-mode" data-ext="java" data-title="java"><pre class="language-java"><code><span class="token keyword">static</span> ```````````````````````````<span class="token generics"><span class="token punctuation">&lt;</span><span class="token class-name">T</span><span class="token punctuation">&gt;</span></span>``````````````````````````` <span class="token class-name">CompletableFuture</span>```````````````````````````<span class="token generics"><span class="token punctuation">&lt;</span><span class="token class-name">T</span><span class="token punctuation">&gt;</span></span>``````````````````````````` <span class="token function">retryExceptionallyAsync</span><span class="token punctuation">(</span><span class="token class-name">Supplier</span>```````````````````````````<span class="token generics"><span class="token punctuation">&lt;</span><span class="token class-name">T</span><span class="token punctuation">&gt;</span></span>``````````````````````````` supplier<span class="token punctuation">,</span> <span class="token keyword">int</span> maxRetries<span class="token punctuation">)</span> <span class="token punctuation">{</span>\n   <span class="token class-name">CompletableFuture</span>```````````````````````````<span class="token generics"><span class="token punctuation">&lt;</span><span class="token class-name">T</span><span class="token punctuation">&gt;</span></span>``````````````````````````` cf <span class="token operator">=</span> <span class="token class-name">CompletableFuture</span><span class="token punctuation">.</span><span class="token function">supplyAsync</span><span class="token punctuation">(</span>supplier<span class="token punctuation">)</span><span class="token punctuation">;</span>\n   <span class="token keyword">for</span> <span class="token punctuation">(</span><span class="token keyword">int</span> i <span class="token operator">=</span> <span class="token number">0</span><span class="token punctuation">;</span> i `<span class="token operator">&lt;</span> maxRetries<span class="token punctuation">;</span> i<span class="token operator">++</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>\n      cf <span class="token operator">=</span> cf<span class="token punctuation">.</span><span class="token function">exceptionallyAsync</span><span class="token punctuation">(</span>__ <span class="token operator">-&gt;</span>` supplier<span class="token punctuation">.</span><span class="token function">get</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">;</span>\n   <span class="token punctuation">}</span>\n   <span class="token keyword">return</span> cf<span class="token punctuation">;</span>\n<span class="token punctuation">}</span>\n</code></pre><div class="line-numbers" aria-hidden="true"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><p>让我们快速运行测试并检查日志：</p><div class="language-plaintext line-numbers-mode" data-ext="plaintext" data-title="plaintext"><pre class="language-plaintext"><code>invocation: 0, thread: ForkJoinPool.commonPool-worker-1\ninvocation: 1, thread: ForkJoinPool.commonPool-worker-1\ninvocation: 2, thread: ForkJoinPool.commonPool-worker-1\ninvocation: 3, thread: ForkJoinPool.commonPool-worker-2\ninvocation: 4, thread: ForkJoinPool.commonPool-worker-2\n</code></pre><div class="line-numbers" aria-hidden="true"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><p>正如预期的那样，没有调用是由主线程执行的。</p><h4 id="_3-3-嵌套completablefutures" tabindex="-1"><a class="header-anchor" href="#_3-3-嵌套completablefutures"><span>3.3. 嵌套CompletableFutures</span></a></h4><p><strong>如果我们需要一个与Java 12之前的版本兼的解决方案，我们可以手动增强第一个示例以实现完全的异步性。</strong> 为了实现这一点，我们必须确保回退在新的CompletableFuture内异步执行：</p><div class="language-java line-numbers-mode" data-ext="java" data-title="java"><pre class="language-java"><code>cf<span class="token punctuation">.</span><span class="token function">exceptionally</span><span class="token punctuation">(</span>__ <span class="token operator">-&gt;</span> <span class="token class-name">CompletableFuture</span><span class="token punctuation">.</span><span class="token function">supplyAsync</span><span class="token punctuation">(</span>supplier<span class="token punctuation">)</span><span class="token punctuation">)</span>\n</code></pre><div class="line-numbers" aria-hidden="true"><div class="line-number"></div></div></div><p>然而，上述代码将无法编译，因为数据类型不匹配，但我们可以通过三个步骤来解决它。首先，我们需要双重嵌套初始的Future。我们可以通过completedFuture()轻松实现这一点：</p><div class="language-java line-numbers-mode" data-ext="java" data-title="java"><pre class="language-java"><code><span class="token class-name">CompletableFuture</span><span class="token operator">&lt;</span><span class="token class-name">CompletableFuture</span>```````````````````````````<span class="token generics"><span class="token punctuation">&lt;</span><span class="token class-name">T</span><span class="token punctuation">&gt;</span></span>```````````````````````````<span class="token operator">&gt;</span> temp <span class="token operator">=</span> cf<span class="token punctuation">.</span><span class="token function">thenApply</span><span class="token punctuation">(</span>value <span class="token operator">-&gt;</span> <span class="token class-name">CompletableFuture</span><span class="token punctuation">.</span><span class="token function">completedFuture</span><span class="token punctuation">(</span>value<span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">;</span>\n\n</code></pre><div class="line-numbers" aria-hidden="true"><div class="line-number"></div><div class="line-number"></div></div></div><p>现在类型匹配了，所以我们可以安全地应用exceptionally()回退：</p><div class="language-java line-numbers-mode" data-ext="java" data-title="java"><pre class="language-java"><code>temp <span class="token operator">=</span> temp<span class="token punctuation">.</span><span class="token function">exceptionally</span><span class="token punctuation">(</span>__ <span class="token operator">-&gt;</span> <span class="token class-name">CompletableFuture</span><span class="token punctuation">.</span><span class="token function">supplyAsync</span><span class="token punctuation">(</span>supplier<span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">;</span>\n\n</code></pre><div class="line-numbers" aria-hidden="true"><div class="line-number"></div><div class="line-number"></div></div></div><p>最后，我们将使用thenCompose()来展平对象并返回到原始类型：</p><div class="language-java line-numbers-mode" data-ext="java" data-title="java"><pre class="language-java"><code>cf <span class="token operator">=</span> temp<span class="token punctuation">.</span><span class="token function">thenCompose</span><span class="token punctuation">(</span>t <span class="token operator">-&gt;</span> t<span class="token punctuation">)</span><span class="token punctuation">;</span>\n</code></pre><div class="line-numbers" aria-hidden="true"><div class="line-number"></div></div></div><p>最后，让我们将所有内容结合起来，创建一个具有可变数量的异步回退的CompletableFuture。此外，让我们利用流畅的API、方法引用和实用函数来保持代码简洁：</p><div class="language-java line-numbers-mode" data-ext="java" data-title="java"><pre class="language-java"><code><span class="token keyword">static</span> ```````````````````````````<span class="token generics"><span class="token punctuation">&lt;</span><span class="token class-name">T</span><span class="token punctuation">&gt;</span></span>``````````````````````````` <span class="token class-name">CompletableFuture</span>```````````````````````````<span class="token generics"><span class="token punctuation">&lt;</span><span class="token class-name">T</span><span class="token punctuation">&gt;</span></span>``````````````````````````` <span class="token function">retryNesting</span><span class="token punctuation">(</span><span class="token class-name">Supplier</span>```````````````````````````<span class="token generics"><span class="token punctuation">&lt;</span><span class="token class-name">T</span><span class="token punctuation">&gt;</span></span>``````````````````````````` supplier<span class="token punctuation">,</span> <span class="token keyword">int</span> maxRetries<span class="token punctuation">)</span> <span class="token punctuation">{</span>\n    <span class="token class-name">CompletableFuture</span>```````````````````````````<span class="token generics"><span class="token punctuation">&lt;</span><span class="token class-name">T</span><span class="token punctuation">&gt;</span></span>``````````````````````````` cf <span class="token operator">=</span> <span class="token class-name">CompletableFuture</span><span class="token punctuation">.</span><span class="token function">supplyAsync</span><span class="token punctuation">(</span>supplier<span class="token punctuation">)</span><span class="token punctuation">;</span>\n    <span class="token keyword">for</span> <span class="token punctuation">(</span><span class="token keyword">int</span> i <span class="token operator">=</span> <span class="token number">0</span><span class="token punctuation">;</span> i `<span class="token operator">&lt;</span> maxRetries<span class="token punctuation">;</span> i<span class="token operator">++</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>\n        cf <span class="token operator">=</span> cf<span class="token punctuation">.</span><span class="token function">thenApply</span><span class="token punctuation">(</span><span class="token class-name">CompletableFuture</span><span class="token operator">::</span><span class="token function">completedFuture</span><span class="token punctuation">)</span>\n        <span class="token punctuation">.</span><span class="token function">exceptionally</span><span class="token punctuation">(</span>__ <span class="token operator">-&gt;</span>` <span class="token class-name">CompletableFuture</span><span class="token punctuation">.</span><span class="token function">supplyAsync</span><span class="token punctuation">(</span>supplier<span class="token punctuation">)</span><span class="token punctuation">)</span>\n        <span class="token punctuation">.</span><span class="token function">thenCompose</span><span class="token punctuation">(</span><span class="token class-name">Function</span><span class="token punctuation">.</span><span class="token function">identity</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">;</span>\n    <span class="token punctuation">}</span>\n    <span class="token keyword">return</span> cf<span class="token punctuation">;</span>\n<span class="token punctuation">}</span>\n</code></pre><div class="line-numbers" aria-hidden="true"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><h2 id="_4-结论" tabindex="-1"><a class="header-anchor" href="#_4-结论"><span>4. 结论</span></a></h2><p>在这篇文章中，我们探讨了在CompletableFuture内重试函数调用的概念。我们首先深入研究了以函数风格实现装饰者模式的实现，允许我们重试函数本身。</p><p>接着，我们利用CompletableFuture API来完成相同的任务，同时保持了异步流程。我们的发现包括Java 12中引入的exceptionallyAsync()方法，这非常适合这个目的。最后，我们展示了一种仅依赖原始Java 8 API的方法。</p><p>正如往常一样，我们可以在GitHub上找到工作的代码示例。</p><p><a href="https://www.baeldung.com/wp-content/themes/baeldung/icon/logo.svg" target="_blank" rel="noopener noreferrer">Baeldung Logo</a><a href="https://secure.gravatar.com/avatar/475d4408e78071b2289e763a5887e617?s=50&amp;r=g" target="_blank" rel="noopener noreferrer">Gravatar Logo</a><a href="https://www.baeldung.com/wp-content/uploads/custom_avatars/david-martinez-150x150.png" target="_blank" rel="noopener noreferrer">David Martinez Avatar</a><a href="https://www.baeldung.com/wp-content/uploads/2022/04/announcement-icon.png" target="_blank" rel="noopener noreferrer">Announcement Icon</a><a href="https://www.baeldung.com/wp-content/uploads/2016/05/baeldung-rest-post-footer-main-1.2.0.jpg" target="_blank" rel="noopener noreferrer">REST API Post Footer Icon</a><a href="https://www.baeldung.com/wp-content/uploads/2016/05/baeldung-rest-post-footer-icn-1.0.0.png" target="_blank" rel="noopener noreferrer">Article Footer Icon</a></p><p>OK</p>',50),o=[p];function c(l,u){return s(),a("div",null,o)}const k=n(e,[["render",c],["__file","2024-06-28-Retry Logic with CompletableFuture.html.vue"]]),d=JSON.parse('{"path":"/posts/baeldung/2024-06-28/2024-06-28-Retry%20Logic%20with%20CompletableFuture.html","title":"CompletableFuture中的重试逻辑","lang":"zh-CN","frontmatter":{"date":"2022-04-01T00:00:00.000Z","category":["Java","CompletableFuture"],"tag":["CompletableFuture","重试逻辑","Java"],"head":[["meta",{"name":"keywords","content":"Java, CompletableFuture, 重试逻辑, 异步编程"}],["meta",{"property":"og:url","content":"https://www.kahen.xyz/posts/baeldung/2024-06-28/2024-06-28-Retry%20Logic%20with%20CompletableFuture.html"}],["meta",{"property":"og:site_name","content":"Baeldung 中文网"}],["meta",{"property":"og:title","content":"CompletableFuture中的重试逻辑"}],["meta",{"property":"og:description","content":"CompletableFuture中的重试逻辑 在这篇文章中，我们将学习如何对CompletableFuture对象应用重试逻辑。起初，我们将重试封装在CompletableFuture中的任务。之后，我们将利用CompletableFuture API创建多个实例的链，使我们能够在将来遇到异常完成时重新执行任务。 2. 重试任务 简单重试任务的方法是..."}],["meta",{"property":"og:type","content":"article"}],["meta",{"property":"og:locale","content":"zh-CN"}],["meta",{"property":"og:updated_time","content":"2024-06-28T15:30:48.000Z"}],["meta",{"property":"article:author","content":"Kahen"}],["meta",{"property":"article:tag","content":"CompletableFuture"}],["meta",{"property":"article:tag","content":"重试逻辑"}],["meta",{"property":"article:tag","content":"Java"}],["meta",{"property":"article:published_time","content":"2022-04-01T00:00:00.000Z"}],["meta",{"property":"article:modified_time","content":"2024-06-28T15:30:48.000Z"}],["script",{"type":"application/ld+json"},"{\\"@context\\":\\"https://schema.org\\",\\"@type\\":\\"Article\\",\\"headline\\":\\"CompletableFuture中的重试逻辑\\",\\"image\\":[\\"\\"],\\"datePublished\\":\\"2022-04-01T00:00:00.000Z\\",\\"dateModified\\":\\"2024-06-28T15:30:48.000Z\\",\\"author\\":[{\\"@type\\":\\"Person\\",\\"name\\":\\"Kahen\\",\\"url\\":\\"https://www.kahen.xyz\\"}]}"]],"description":"CompletableFuture中的重试逻辑 在这篇文章中，我们将学习如何对CompletableFuture对象应用重试逻辑。起初，我们将重试封装在CompletableFuture中的任务。之后，我们将利用CompletableFuture API创建多个实例的链，使我们能够在将来遇到异常完成时重新执行任务。 2. 重试任务 简单重试任务的方法是..."},"headers":[{"level":3,"title":"2. 重试任务","slug":"_2-重试任务","link":"#_2-重试任务","children":[]},{"level":3,"title":"3. 重试CompletableFuture","slug":"_3-重试completablefuture","link":"#_3-重试completablefuture","children":[]},{"level":2,"title":"4. 结论","slug":"_4-结论","link":"#_4-结论","children":[]}],"git":{"createdTime":1719588648000,"updatedTime":1719588648000,"contributors":[{"name":"Kahen","email":"Kahen@users.noreply.github.com","commits":1}]},"readingTime":{"minutes":5.99,"words":1797},"filePathRelative":"posts/baeldung/2024-06-28/2024-06-28-Retry Logic with CompletableFuture.md","localizedDate":"2022年4月1日","excerpt":"\\n<p>在这篇文章中，我们将学习如何对CompletableFuture对象应用重试逻辑。起初，我们将重试封装在CompletableFuture中的任务。之后，我们将利用CompletableFuture API创建多个实例的链，使我们能够在将来遇到异常完成时重新执行任务。</p>\\n<h3>2. 重试任务</h3>\\n<p><strong>简单重试任务的方法是利用装饰者模式，并使用传统的面向对象风格通过类和接口实现它。</strong> 另一方面，我们可以选择更简洁和函数式的方法，利用高阶函数的优势。</p>\\n<p>首先，我们将声明一个函数，它接受一个Supplier<code>&lt;T&gt;</code>和最大调用次数作为参数。然后，我们将使用while循环和try-catch块在需要时多次调用函数。最后，我们将通过返回另一个Supplier<code>&lt;T&gt;</code>来保留原始数据类型：</p>","autoDesc":true}');export{k as comp,d as data};
