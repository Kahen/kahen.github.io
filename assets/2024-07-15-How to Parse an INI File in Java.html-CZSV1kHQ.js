import{_ as e}from"./plugin-vue_export-helper-DlAUqK2U.js";import{c as i,o as n,a as t}from"./app-rX0WKH_9.js";const a={},s=t('<h1 id="如何在java中解析ini文件" tabindex="-1"><a class="header-anchor" href="#如何在java中解析ini文件"><span>如何在Java中解析INI文件</span></a></h1><p>INI文件是Windows或MS-DOS的初始化或配置文件。它们具有纯文本内容，由节中的键值对组成。虽然我们可能更倾向于使用Java的原生.properties文件或其他格式来配置我们的应用程序，但有时我们可能需要从现有的INI文件中获取数据。</p><p>在本教程中，我们将查看一些可以帮助我们的库。我们还将查看如何使用INI文件中的数据来填充POJO。</p><h2 id="_2-创建一个示例ini文件" tabindex="-1"><a class="header-anchor" href="#_2-创建一个示例ini文件"><span>2. 创建一个示例INI文件</span></a></h2><p>让我们从一个示例INI文件开始，<em>sample.ini</em>：</p><div class="language-text line-numbers-mode" data-ext="text" data-title="text"><pre class="language-text"><code>; 16位应用程序支持\n[fonts]\nletter=bold\ntext-size=28\n\n[background]\ncolor=white\n\n[RequestResult]\nRequestCode=1\n\n[ResponseResult]\nResultCode=0\n</code></pre><div class="line-numbers" aria-hidden="true"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><p>此文件有四个节，命名使用了小写、短横线命名法和大驼峰命名法的混合。它的值要么是字符串，要么是数字。</p><h2 id="_3-使用-ini4j-解析ini文件" tabindex="-1"><a class="header-anchor" href="#_3-使用-ini4j-解析ini文件"><span>3. 使用_ini4j_解析INI文件</span></a></h2><p>_ini4j_是一个用于从INI文件中读取配置的轻量级库。自2015年以来它没有更新过。</p><h3 id="_3-1-安装-ini4j" tabindex="-1"><a class="header-anchor" href="#_3-1-安装-ini4j"><span>3.1. 安装_ini4j_</span></a></h3><p>要使用_ini4j_库，首先，我们应该在_pom.xml_中添加它的依赖项：</p><div class="language-text line-numbers-mode" data-ext="text" data-title="text"><pre class="language-text"><code>`````&lt;dependency&gt;`````\n    `````&lt;groupId&gt;`````org.ini4j`````&lt;/groupId&gt;`````\n    `````&lt;artifactId&gt;`````ini4j`````&lt;/artifactId&gt;`````\n    `````&lt;version&gt;`````0.5.4`````&lt;/version&gt;`````\n`````&lt;/dependency&gt;`````\n</code></pre><div class="line-numbers" aria-hidden="true"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><h3 id="_3-2-在-ini4j-中打开ini文件" tabindex="-1"><a class="header-anchor" href="#_3-2-在-ini4j-中打开ini文件"><span>3.2. 在_ini4j_中打开INI文件</span></a></h3><p><strong>我们可以通过构造一个_Ini_对象来在_ini4j_中打开INI文件</strong>：</p><div class="language-text line-numbers-mode" data-ext="text" data-title="text"><pre class="language-text"><code>File fileToParse = new File(&quot;sample.ini&quot;);\nIni ini = new Ini(fileToParse);\n</code></pre><div class="line-numbers" aria-hidden="true"><div class="line-number"></div><div class="line-number"></div></div></div><p>这个对象现在包含了节和键。</p><h3 id="_3-3-读取节中的键" tabindex="-1"><a class="header-anchor" href="#_3-3-读取节中的键"><span>3.3. 读取节中的键</span></a></h3><p>我们可以使用_Ini_类的_get()_函数从INI文件中读取节中的键：</p><div class="language-text line-numbers-mode" data-ext="text" data-title="text"><pre class="language-text"><code>assertThat(ini.get(&quot;fonts&quot;, &quot;letter&quot;))\n  .isEqualTo(&quot;bold&quot;);\n</code></pre><div class="line-numbers" aria-hidden="true"><div class="line-number"></div><div class="line-number"></div></div></div><h3 id="_3-4-转换为map" tabindex="-1"><a class="header-anchor" href="#_3-4-转换为map"><span>3.4. 转换为Map</span></a></h3><p>让我们看看将整个INI文件转换为_Map<code>&lt;String, Map</code>&lt;String, String&gt;````&gt;_有多容易，这是Java的本地数据结构，代表了INI文件的层次结构：</p><div class="language-text line-numbers-mode" data-ext="text" data-title="text"><pre class="language-text"><code>public static Map``&lt;String, Map``&lt;String, String&gt;````&gt; parseIniFile(File fileToParse)\n  throws IOException {\n    Ini ini = new Ini(fileToParse);\n    return ini.entrySet().stream()\n      .collect(toMap(Map.Entry::getKey, Map.Entry::getValue));\n}\n</code></pre><div class="line-numbers" aria-hidden="true"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><p>在这里，_Ini_对象的_entrySet_本质上是_String_和_Map<code>&lt;String, String&gt;</code>_的键值对。<em>Ini_的内部表示几乎是一个_Map</em>，所以它很容易通过使用_stream()_和_toMap()<em>收集器转换为一个简单的_Map</em>。</p><p>我们现在可以使用_get()_从这个映射中读取节：</p><div class="language-text line-numbers-mode" data-ext="text" data-title="text"><pre class="language-text"><code>assertThat(result.get(&quot;fonts&quot;).get(&quot;letter&quot;))\n  .isEqualTo(&quot;bold&quot;);\n</code></pre><div class="line-numbers" aria-hidden="true"><div class="line-number"></div><div class="line-number"></div></div></div><p>_Ini_类开箱即用非常简单，转换为_Map_可能不是必需的，尽管我们稍后会找到它的用途。</p><p>然而，_ini4j_是一个旧的库，看起来维护得不是很好。让我们考虑另一个选项。</p><h2 id="_4-使用apache-commons解析ini文件" tabindex="-1"><a class="header-anchor" href="#_4-使用apache-commons解析ini文件"><span>4. 使用Apache Commons解析INI文件</span></a></h2><p>Apache Commons提供了一个更复杂的工具来处理INI文件。这个工具能够对整个文件进行读写建模，尽管我们只关注它的解析能力。</p><h3 id="_4-1-安装commons-configuration" tabindex="-1"><a class="header-anchor" href="#_4-1-安装commons-configuration"><span>4.1. 安装Commons Configuration</span></a></h3><p>让我们从在_pom.xml_中添加所需的依赖项开始：</p><div class="language-text line-numbers-mode" data-ext="text" data-title="text"><pre class="language-text"><code>`````&lt;dependency&gt;`````\n    `````&lt;groupId&gt;`````org.apache.commons`````&lt;/groupId&gt;`````\n    `````&lt;artifactId&gt;`````commons-configuration2`````&lt;/artifactId&gt;`````\n    `````&lt;version&gt;`````2.8.0`````&lt;/version&gt;`````\n`````&lt;/dependency&gt;`````\n</code></pre><div class="line-numbers" aria-hidden="true"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><p>2.8.0版本在2022年更新，比_ini4j_更新。</p><h3 id="_4-2-打开ini文件" tabindex="-1"><a class="header-anchor" href="#_4-2-打开ini文件"><span>4.2. 打开INI文件</span></a></h3><p>我们可以通过声明一个_INIConfiguration_对象并传递一个_Reader_来打开INI文件：</p><div class="language-text line-numbers-mode" data-ext="text" data-title="text"><pre class="language-text"><code>INIConfiguration iniConfiguration = new INIConfiguration();\ntry (FileReader fileReader = new FileReader(fileToParse)) {\n    iniConfiguration.read(fileReader);\n}\n</code></pre><div class="line-numbers" aria-hidden="true"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><p>这里我们使用了try-with-resources模式来打开一个_FileReader_，然后要求_INIConfiguration_对象使用_read_函数读取它。</p><h3 id="_4-3-读取节中的键" tabindex="-1"><a class="header-anchor" href="#_4-3-读取节中的键"><span>4.3. 读取节中的键</span></a></h3><p>_INIConfiguration_类有一个_getSection()_函数来读取一个节，以及返回对象上的_getProperty()_函数来读取一个键：</p><div class="language-text line-numbers-mode" data-ext="text" data-title="text"><pre class="language-text"><code>String value = iniConfiguration.getSection(&quot;fonts&quot;)\n  .getProperty(&quot;letter&quot;)\n  .toString();\nassertThat(value)\n  .isEqualTo(&quot;bold&quot;);\n</code></pre><div class="line-numbers" aria-hidden="true"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><p>我们应该注意_getProperty()<em>返回的是_Object_而不是_String</em>，所以需要转换为_String_。</p><h3 id="_4-4-转换为map" tabindex="-1"><a class="header-anchor" href="#_4-4-转换为map"><span>4.4. 转换为Map</span></a></h3><p>我们也可以像以前一样将_INIConfiguration_转换为_Map_。这比使用_ini4j_要复杂一些：</p><div class="language-text line-numbers-mode" data-ext="text" data-title="text"><pre class="language-text"><code>Map``&lt;String, Map``&lt;String, String&gt;````&gt; iniFileContents = new HashMap&lt;&gt;();\nfor (String section : iniConfiguration.getSections()) {\n    Map``&lt;String, String&gt;`` subSectionMap = new HashMap&lt;&gt;();\n    SubnodeConfiguration confSection = iniConfiguration.getSection(section);\n    Iterator`&lt;String&gt;` keyIterator = confSection.getKeys();\n    while (keyIterator.hasNext()) {\n        String key = keyIterator.next();\n        String value = confSection.getProperty(key).toString();\n        subSectionMap.put(key, value);\n    }\n    iniFileContents.put(section, subSectionMap);\n}\n</code></pre><div class="line-numbers" aria-hidden="true"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><p>要获取所有节，我们需要使用_getSections()_来找到它们的名称。然后_getSection()_可以给我们每个节。</p><p>然后我们可以使用提供节的所有键的_Iterator_，并使用每个_getProperty()_来获取键值对。</p><p>虽然在这里生成_Map_更困难，但更简单的数据结构的优势是我们可以隐藏INI文件解析系统其他部分的解析。或者，我们可以将配置转换为POJO。</p><h2 id="_5-将ini文件转换为pojo" tabindex="-1"><a class="header-anchor" href="#_5-将ini文件转换为pojo"><span>5. 将INI文件转换为POJO</span></a></h2><p>我们可以使用Jackson将我们的_Map_结构转换为POJO。我们可以用反序列化注释装饰我们的POJO，以帮助Jackson理解原始INI文件中各种命名约定。</p><h3 id="_5-1-导入jackson" tabindex="-1"><a class="header-anchor" href="#_5-1-导入jackson"><span>5.1. 导入Jackson</span></a></h3><p>我们需要在_pom.xml_中添加Jackson：</p><div class="language-text line-numbers-mode" data-ext="text" data-title="text"><pre class="language-text"><code>`````&lt;dependency&gt;`````\n    `````&lt;groupId&gt;`````com.fasterxml.jackson.core`````&lt;/groupId&gt;`````\n    `````&lt;artifactId&gt;`````jackson-annotations`````&lt;/artifactId&gt;`````\n    `````&lt;version&gt;`````2.13.1`````&lt;/version&gt;`````\n`````&lt;/dependency&gt;`````\n`````&lt;dependency&gt;`````\n    `````&lt;groupId&gt;`````com.fasterxml.jackson.core`````&lt;/groupId&gt;`````\n    `````&lt;artifactId&gt;`````jackson-core`````&lt;/artifactId&gt;`````\n    `````&lt;version&gt;`````2.13.1`````&lt;/version&gt;`````\n`````&lt;/dependency&gt;`````\n`````&lt;dependency&gt;`````\n    `````&lt;groupId&gt;`````com.fasterxml.jackson.core`````&lt;/groupId&gt;`````\n    `````&lt;artifactId&gt;`````jackson-databind`````&lt;/artifactId&gt;`````\n    `````&lt;version&gt;`````2.13.1`````&lt;/version&gt;`````\n`````&lt;/dependency&gt;`````\n</code></pre><div class="line-numbers" aria-hidden="true"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><h3 id="_5-2-定义一些pojos" tabindex="-1"><a class="header-anchor" href="#_5-2-定义一些pojos"><span>5.2. 定义一些POJOs</span></a></h3><p>我们的示例文件的_fonts_节使用kebab-case为其属性。让我们定义一个类来表示该节：</p><div class="language-text line-numbers-mode" data-ext="text" data-title="text"><pre class="language-text"><code>@JsonNaming(PropertyNamingStrategies.KebabCaseStrategy.class)\npublic static class Fonts {\n    private String letter;\n    private int textSize;\n\n    // getters and setters\n}\n</code></pre><div class="line-numbers" aria-hidden="true"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><p>这里我们使用了_JsonNaming_注解来描述属性中使用的案例。</p><p>类似地，_RequestResult_节的属性使用大驼峰命名法：</p><div class="language-text line-numbers-mode" data-ext="text" data-title="text"><pre class="language-text"><code>@JsonNaming(PropertyNamingStrategies.UpperCamelCaseStrategy.class)\npublic static class RequestResult {\n    private int requestCode;\n\n    // getters and setters\n}\n</code></pre><div class="line-numbers" aria-hidden="true"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><p>节名本身是各种情况，所以我们可以在父对象中声明每个节，使用_JsonProperty_注释来显示与默认小驼峰命名法的偏差：</p><div class="language-text line-numbers-mode" data-ext="text" data-title="text"><pre class="language-text"><code>public class MyConfiguration {\n    private Fonts fonts;\n    private Background background;\n\n    @JsonProperty(&quot;RequestResult&quot;)\n    private RequestResult requestResult;\n\n    @JsonProperty(&quot;ResponseResult&quot;)\n    private ResponseResult responseResult;\n\n    // getters and setters\n}\n</code></pre><div class="line-numbers" aria-hidden="true"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><h3 id="_5-3-从map转换为pojo" tabindex="-1"><a class="header-anchor" href="#_5-3-从map转换为pojo"><span>5.3. 从Map转换为POJO</span></a></h3><p>现在我们有能力使用我们的库之一将INI文件读取为_Map_，并且能够将文件内容建模为POJO，我们可以使用Jackson的_ObjectMapper_来执行转换：</p><div class="language-text line-numbers-mode" data-ext="text" data-title="text"><pre class="language-text"><code>ObjectMapper objectMapper = new ObjectMapper();\nMap``&lt;String, Map``&lt;String, String&gt;````&gt; iniKeys = parseIniFile(TEST_FILE);\nMyConfiguration config = objectMapper.convertValue(iniKeys, MyConfiguration.class);\n</code></pre><div class="line-numbers" aria-hidden="true"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><p>让我们检查整个文件是否正确加载：</p><div class="language-text line-numbers-mode" data-ext="text" data-title="text"><pre class="language-text"><code>assertThat(config.getFonts().getLetter()).isEqualTo(&quot;bold&quot;);\nassertThat(config.getFonts().getTextSize()).isEqualTo(28);\nassertThat(config.getBackground().getColor()).isEqualTo(&quot;white&quot;);\nassertThat(config.getRequestResult().getRequestCode()).isEqualTo(1);\nassertThat(config.getResponseResult().getResultCode()).isZero();\n</code></pre><div class="line-numbers" aria-hidden="true"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><p>我们应该注意，数字属性，如_textSize_和_requestCode_已加载到我们的POJO中作为数字属性，例如_textSize_和_requestCode_，已经被加载到我们的POJO中为数字。</p><h2 id="_6-库和方法的比较" tabindex="-1"><a class="header-anchor" href="#_6-库和方法的比较"><span>6. 库和方法的比较</span></a></h2><p>_ini4j_库非常容易使用，本质上是一个简单的_Map_结构。然而，这是一个没有定期更新的旧库。</p><p>Apache Commons解决方案功能更全面，并且有定期更新，但使用起来需要更多的工作。</p><h2 id="_7-结论" tabindex="-1"><a class="header-anchor" href="#_7-结论"><span>7. 结论</span></a></h2><p>在本文中，我们看到了如何使用几个开源库来读取INI文件。我们看到了如何读取单个键以及如何遍历整个文件以生成_Map_。</p><p>然后我们看到了如何使用Jackson将_Map_转换为POJO。</p><p>像往常一样，示例代码可以在GitHub上找到。</p><p><a href="kimi://action?name=cheer-on-kimi">给Kimi加油</a></p><p>OK</p>',75),l=[s];function d(r,o){return n(),i("div",null,l)}const u=e(a,[["render",d],["__file","2024-07-15-How to Parse an INI File in Java.html.vue"]]),v=JSON.parse('{"path":"/posts/baeldung/2024-07-15/2024-07-15-How%20to%20Parse%20an%20INI%20File%20in%20Java.html","title":"如何在Java中解析INI文件","lang":"zh-CN","frontmatter":{"date":"2022-04-01T00:00:00.000Z","category":["Java","INI文件解析"],"tag":["INI文件","Java解析","库","Apache Commons","ini4j"],"head":[["meta",{"name":"keywords","content":"Java, INI文件解析, 配置文件, Apache Commons, ini4j"}],["meta",{"property":"og:url","content":"https://www.kahen.xyz/posts/baeldung/2024-07-15/2024-07-15-How%20to%20Parse%20an%20INI%20File%20in%20Java.html"}],["meta",{"property":"og:site_name","content":"Baeldung 中文网"}],["meta",{"property":"og:title","content":"如何在Java中解析INI文件"}],["meta",{"property":"og:description","content":"如何在Java中解析INI文件 INI文件是Windows或MS-DOS的初始化或配置文件。它们具有纯文本内容，由节中的键值对组成。虽然我们可能更倾向于使用Java的原生.properties文件或其他格式来配置我们的应用程序，但有时我们可能需要从现有的INI文件中获取数据。 在本教程中，我们将查看一些可以帮助我们的库。我们还将查看如何使用INI文件中..."}],["meta",{"property":"og:type","content":"article"}],["meta",{"property":"og:locale","content":"zh-CN"}],["meta",{"property":"og:updated_time","content":"2024-07-15T10:07:24.000Z"}],["meta",{"property":"article:author","content":"Kahen"}],["meta",{"property":"article:tag","content":"INI文件"}],["meta",{"property":"article:tag","content":"Java解析"}],["meta",{"property":"article:tag","content":"库"}],["meta",{"property":"article:tag","content":"Apache Commons"}],["meta",{"property":"article:tag","content":"ini4j"}],["meta",{"property":"article:published_time","content":"2022-04-01T00:00:00.000Z"}],["meta",{"property":"article:modified_time","content":"2024-07-15T10:07:24.000Z"}],["script",{"type":"application/ld+json"},"{\\"@context\\":\\"https://schema.org\\",\\"@type\\":\\"Article\\",\\"headline\\":\\"如何在Java中解析INI文件\\",\\"image\\":[\\"\\"],\\"datePublished\\":\\"2022-04-01T00:00:00.000Z\\",\\"dateModified\\":\\"2024-07-15T10:07:24.000Z\\",\\"author\\":[{\\"@type\\":\\"Person\\",\\"name\\":\\"Kahen\\",\\"url\\":\\"https://www.kahen.xyz\\"}]}"]],"description":"如何在Java中解析INI文件 INI文件是Windows或MS-DOS的初始化或配置文件。它们具有纯文本内容，由节中的键值对组成。虽然我们可能更倾向于使用Java的原生.properties文件或其他格式来配置我们的应用程序，但有时我们可能需要从现有的INI文件中获取数据。 在本教程中，我们将查看一些可以帮助我们的库。我们还将查看如何使用INI文件中..."},"headers":[{"level":2,"title":"2. 创建一个示例INI文件","slug":"_2-创建一个示例ini文件","link":"#_2-创建一个示例ini文件","children":[]},{"level":2,"title":"3. 使用_ini4j_解析INI文件","slug":"_3-使用-ini4j-解析ini文件","link":"#_3-使用-ini4j-解析ini文件","children":[{"level":3,"title":"3.1. 安装_ini4j_","slug":"_3-1-安装-ini4j","link":"#_3-1-安装-ini4j","children":[]},{"level":3,"title":"3.2. 在_ini4j_中打开INI文件","slug":"_3-2-在-ini4j-中打开ini文件","link":"#_3-2-在-ini4j-中打开ini文件","children":[]},{"level":3,"title":"3.3. 读取节中的键","slug":"_3-3-读取节中的键","link":"#_3-3-读取节中的键","children":[]},{"level":3,"title":"3.4. 转换为Map","slug":"_3-4-转换为map","link":"#_3-4-转换为map","children":[]}]},{"level":2,"title":"4. 使用Apache Commons解析INI文件","slug":"_4-使用apache-commons解析ini文件","link":"#_4-使用apache-commons解析ini文件","children":[{"level":3,"title":"4.1. 安装Commons Configuration","slug":"_4-1-安装commons-configuration","link":"#_4-1-安装commons-configuration","children":[]},{"level":3,"title":"4.2. 打开INI文件","slug":"_4-2-打开ini文件","link":"#_4-2-打开ini文件","children":[]},{"level":3,"title":"4.3. 读取节中的键","slug":"_4-3-读取节中的键","link":"#_4-3-读取节中的键","children":[]},{"level":3,"title":"4.4. 转换为Map","slug":"_4-4-转换为map","link":"#_4-4-转换为map","children":[]}]},{"level":2,"title":"5. 将INI文件转换为POJO","slug":"_5-将ini文件转换为pojo","link":"#_5-将ini文件转换为pojo","children":[{"level":3,"title":"5.1. 导入Jackson","slug":"_5-1-导入jackson","link":"#_5-1-导入jackson","children":[]},{"level":3,"title":"5.2. 定义一些POJOs","slug":"_5-2-定义一些pojos","link":"#_5-2-定义一些pojos","children":[]},{"level":3,"title":"5.3. 从Map转换为POJO","slug":"_5-3-从map转换为pojo","link":"#_5-3-从map转换为pojo","children":[]}]},{"level":2,"title":"6. 库和方法的比较","slug":"_6-库和方法的比较","link":"#_6-库和方法的比较","children":[]},{"level":2,"title":"7. 结论","slug":"_7-结论","link":"#_7-结论","children":[]}],"git":{"createdTime":1721038044000,"updatedTime":1721038044000,"contributors":[{"name":"Kahen","email":"Kahen@users.noreply.github.com","commits":1}]},"readingTime":{"minutes":5.77,"words":1730},"filePathRelative":"posts/baeldung/2024-07-15/2024-07-15-How to Parse an INI File in Java.md","localizedDate":"2022年4月1日","excerpt":"\\n<p>INI文件是Windows或MS-DOS的初始化或配置文件。它们具有纯文本内容，由节中的键值对组成。虽然我们可能更倾向于使用Java的原生.properties文件或其他格式来配置我们的应用程序，但有时我们可能需要从现有的INI文件中获取数据。</p>\\n<p>在本教程中，我们将查看一些可以帮助我们的库。我们还将查看如何使用INI文件中的数据来填充POJO。</p>\\n<h2>2. 创建一个示例INI文件</h2>\\n<p>让我们从一个示例INI文件开始，<em>sample.ini</em>：</p>\\n<div class=\\"language-text\\" data-ext=\\"text\\" data-title=\\"text\\"><pre class=\\"language-text\\"><code>; 16位应用程序支持\\n[fonts]\\nletter=bold\\ntext-size=28\\n\\n[background]\\ncolor=white\\n\\n[RequestResult]\\nRequestCode=1\\n\\n[ResponseResult]\\nResultCode=0\\n</code></pre></div>","autoDesc":true}');export{u as comp,v as data};
