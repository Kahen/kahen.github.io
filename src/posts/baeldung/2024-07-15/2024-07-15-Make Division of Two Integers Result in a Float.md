---
date: 2022-04-01
category:
  - Java
tag:
  - Java
  - 整数除法
  - 浮点数结果
head:
  - - meta
    - name: keywords
      content: Java, 整数除法, 浮点数结果, 编程技巧
---
# Java中整数除法得到浮点数结果

## 1. 概述

在Java中，我们可以使用除法运算符（/）来将左侧的值除以右侧的值。例如，`int number = 10 / 5`。

在这个快速教程中，我们将探讨如何从整数除法操作中得到一个浮点数结果。

## 2. 问题的介绍

首先，为了简单起见，我们将在这个教程中使用单元测试断言来验证计算结果。

我们可能已经意识到，当我们像`a/b`这样对两个整数应用除法运算符时，即使`a`不能被`b`整除，它总是返回一个整数，例如：

```java
int i = 10 / 4;
assertEquals(2, i);

```

如果我们运行测试，它会通过。所以，`10 / 4`产生的是2而不是2.5。而且，即使我们将计算结果赋值给一个浮点变量，结果仍然是两个：

```java
float x = 10 / 4;
assertEquals(2, x);

```

那么接下来，我们首先理解为什么会这样，然后找出如何得到我们想要的浮点结果，例如在这种情况下的2.5。

## 3. 为什么Java中两个整数的除法总是得到一个整数？

为了理解为什么`10 / 4 = 2`在Java中，我们需要查看JLS（Java语言规范）中的除法运算符部分，了解除法运算符的行为是如何定义的。

首先，规范指出整数除法是向零舍入的。换句话说，两个整数的除法操作的结果只包括商值，不包括余数。

因此，当我们计算`10 / 4`时，我们得到2而不是2.5。

接下来，让我们看看如果两个整数不能整除，如何得到预期的浮点结果。

现在我们已经了解了两个整数的除法运算符是如何工作的。JLS还在二元数值提升中定义了原始操作数转换规则。

**二元数值提升在`*`、`/`和`%`运算符上执行**。因此，除法操作遵循操作数转换规则。

那么接下来，让我们仔细看看操作数转换规则。

根据JLS，当我们计算`a/b`时：

- 如果任一操作数是`double`类型，另一个将被转换为`double`。
- 否则，如果任一操作数是`float`类型，另一个将被转换为`float`。
- 否则，如果任一操作数是`long`类型，另一个将被转换为`long`。
- 否则，两个操作数都被转换为`int`类型。

根据上述规则，如果我们想要使`a/b`操作的结果是一个浮点数，至少一个操作数应该是`float`类型。

那么接下来，让我们看看当我们将一个操作数强制转换为`float`时，我们是否可以得到预期的结果：

```java
float x = (float) 10 / 4;
assertEquals(2.5, x);

float y = 10 / (float) 8;
assertEquals(1.25, y);

```

如果我们运行上述测试，它会通过。因此，**将任何操作数强制转换为`float`可以使除法产生浮点结果**。

## 5. 结论

在这篇文章中，我们讨论了为什么Java中整数的除法总是得到整数。

此外，我们解决了如何从整数除法中得到预期的浮点结果。这在不可整除的情况下特别有用。

像往常一样，文章中展示的所有代码片段都可以在GitHub上找到。---
date: 2022-04-01
category:
  - Java
tag:
  - Java
  - 整数除法
  - 浮点数结果
head:
  - - meta
    - name: keywords
      content: Java, 整数除法, 浮点数结果, 编程技巧
---
# Java中整数除法得到浮点数结果

## 1. 概述

在Java中，我们可以使用除法运算符（/）来将左侧的值除以右侧的值。例如，`int number = 10 / 5`。

在这个快速教程中，我们将探讨如何从整数除法操作中得到一个浮点数结果。

## 2. 问题的介绍

首先，为了简单起见，我们将在这个教程中使用单元测试断言来验证计算结果。

我们可能已经意识到，当我们像`a/b`这样对两个整数应用除法运算符时，即使`a`不能被`b`整除，它总是返回一个整数，例如：

```java
int i = 10 / 4;
assertEquals(2, i);
```

如果我们运行测试，它会通过。所以，`10 / 4`产生的是2而不是2.5。而且，即使我们将计算结果赋值给一个浮点变量，结果仍然是两个：

```java
float x = 10 / 4;
assertEquals(2, x);
```

那么接下来，我们首先理解为什么会这样，然后找出如何得到我们想要的浮点结果，例如在这种情况下的2.5。

## 3. 为什么Java中两个整数的除法总是得到一个整数？

为了理解为什么`10 / 4 = 2`在Java中，我们需要查看JLS（Java语言规范）中的除法运算符部分，了解除法运算符的行为是如何定义的。

首先，规范指出整数除法是向零舍入的。换句话说，两个整数的除法操作的结果只包括商值，不包括余数。

因此，当我们计算`10 / 4`时，我们得到2而不是2.5。

接下来，让我们看看如果两个整数不能整除，如何得到预期的浮点结果。

现在我们已经了解了两个整数的除法运算符是如何工作的。JLS还在二元数值提升中定义了原始操作数转换规则。

**二元数值提升在`*`、`/`和`%`运算符上执行**。因此，除法操作遵循操作数转换规则。

那么接下来，让我们仔细看看操作数转换规则。

根据JLS，当我们计算`a/b`时：

- 如果任一操作数是`double`类型，另一个将被转换为`double`。
- 否则，如果任一操作数是`float`类型，另一个将被转换为`float`。
- 否则，如果任一操作数是`long`类型，另一个将被转换为`long`。
- 否则，两个操作数都被转换为`int`类型。

根据上述规则，如果我们想要使`a/b`操作的结果是一个浮点数，至少一个操作数应该是`float`类型。

那么接下来，让我们看看当我们将一个操作数强制转换为`float`时，我们是否可以得到预期的结果：

```java
float x = (float) 10 / 4;
assertEquals(2.5, x);

float y = 10 / (float) 8;
assertEquals(1.25, y);
```

如果我们运行上述测试，它会通过。因此，**将任何操作数强制转换为`float`可以使除法产生浮点结果**。

## 5. 结论

在这篇文章中，我们讨论了为什么Java中整数的除法总是得到整数。

此外，我们解决了如何从整数除法中得到预期的浮点结果。这在不可整除的情况下特别有用。

像往常一样，文章中展示的所有代码片段都可以在GitHub上找到。

OK