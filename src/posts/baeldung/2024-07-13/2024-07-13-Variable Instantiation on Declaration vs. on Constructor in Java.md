---
date: 2024-07-14
category:
  - Java
  - Programming
tag:
  - Java
  - Constructor
  - Variable Initialization
head:
  - - meta
    - name: keywords
      content: Java, Constructor, Variable Initialization, Dependency Injection
---
# Java中声明时变量实例化与构造函数中的比较 | Baeldung

## 1. 引言

Java开发者之间存在不确定性，不确定是在声明时初始化变量还是在构造函数中初始化。

在本教程中，我们将看看在声明时或在构造函数中初始化变量时会发生什么。我们将尝试指出它们之间是否存在差异和相似之处。

## 2. 字段声明初始化

我们需要知道Java编译器会取出所有字段声明初始化，并按它们在类中的出现顺序将它们作为代码移动到构造函数中。从这一点，我们可以推断出在声明时或在构造函数中初始化变量并没有太大区别，因为编译后它们最终都会出现在构造函数中：

```java
public class A {
    private B b = new B();
}
```

## 3. 构造函数字段初始化

根据我们上面的代码，编译后我们得到这个构造函数：

```java
public class A {
    private B b;

    public A() {
        this.b = new B();
    }
}
```

那么，我们在哪里初始化数据真的重要吗？

在了解了编译后会发生什么之后，这并不是那么重要。这更多是我们基于经验形成的偏好。

## 4. 指南

在决定是在字段声明还是在构造函数中初始化数据时，我们可以查看一些指南。

这是一个依赖注入构造函数：

```java
public A(B b) {
    this.b = b;
}
```

使用这种方式初始化变量是推荐的方式。通过使用这种方式初始化对象，我们遵循了不同的原则。

### 4.1. 可读性

为了更好的可读性，可能重要的是在字段声明或构造函数中初始化数据，而不是两者都做。当然，我们应该将这视为指南，而不是规则，因为你可以在两者中都有。

将所有初始化放在一个地方，可以更容易地知道在哪里查找初始化代码。这将使任何未来的开发者更容易地在一个地方查看初始化，而不是分散在多个地方。

### 4.2. 单一职责

通过使用依赖注入构造函，我们从A类中移除了实例化B对象的责任。尽可能遵循**单一职责**原则总是更可取的。

这也意味着我们将拥有**类之间的低耦合**，这是另一个值得遵循的很棒的指南。

### 4.3. 可测试性

使用这个构造函数倾向于有更容易的方法来测试我们的代码，因为我们可以很容易地模拟我们的B对象，然后使用这个构造函数将其注入到我们的A对象中：

```java
B b = mock(B.class);
A a = new A(b);
```

### 4.4. 可维护性

拥有低耦合的类也为我们带来了**更好的代码可维护性**。因此，我们将能够更容易地修改代码。

## 5. 结论

在本文中，我们看到了使用字段声明或构造函数初始化更多的是个人偏好，它们之间的一些差异可能是我们想要遵循的设计原则。

使用构造函数初始化和**依赖注入**可以给我们带来一些设计原则的优势。

如常，示例的源代码可在GitHub上找到。