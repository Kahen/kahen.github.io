---
date: 2022-04-01
category:
  - Java
  - Programming
tag:
  - Java
  - Bitwise Operators
  - Operator Precedence
head:
  - - meta
    - name: keywords
      content: Java, Bitwise Operators, Operator Precedence
------
# Java 位运算符类型不匹配问题解析

## 1. 概述

Java 提供了一组位运算符。这些运算符允许我们方便地操作数字的单个位。

然而，当我们比较位运算的结果时，可能会遇到一个常见的陷阱。

在这个快速教程中，我们将讨论为什么我们可能会遇到 Java 编译时错误 “bad operand types for binary operator”（二元运算符的运算数类型不匹配），以及如何解决这个问题。

## 2. 问题介绍

像往常一样，我们将通过一个示例来理解这个问题。但首先，让我们看看一个简单的方法：

```java
public void checkNumber() {
    List`<Integer>` intList = Arrays.asList(1, 2, 3, 4, 5, 6, 7);
    intList.forEach(i -> {
        if (i & 1 == 1) {
            System.out.println(i + " is odd.");
        } else {
            System.out.println(i + " is even.");
        }
    });
}

```

正如我们所看到的，_checkNumber_ 方法遍历 _intList_，并检查并输出每个数字是偶数还是奇数。

我们应该注意到，该方法中的奇数检查逻辑并没有以常见的方式实现：_i % 2 == 1_。相反，**我们对一个 _Integer_ 类型的数字（_i_）和 1 执行位与（&）操作**。如果结果为 1，则我们知道整数 _i_ 是一个奇数：_i & 1 == 1_。

然而，当我们尝试测试上述方法时，代码意外地无法编译：

```java
java: bad operand types for binary operator '&'
  first type:  java.lang.Integer
  second type: boolean
```

接下来，让我们理解问题的原因以及如何解决它。

## 3. 理解 Java 运算符优先级

首先，错误消息非常直接。它说我们试图对一个 _boolean_ 类型和一个 _Integer_ 类型进行位与操作。

然而，这很奇怪，因为我们在代码中明确写了 “_i & 1_”。为什么编译器认为一个 _boolean_ 类型参与了位与操作？

这是因为 **“==” 运算符的优先级高于 “&” 运算符**。也就是说表达式 “_i & 1 == 1_” 等同于 “_i & (1 == 1)_”。因此，我们有 “_i & true (boolean)_”。

现在，我们可能会问：“好的，== 的优先级高于 &。但为什么 ‘_i % 2 == 1_‘ 按预期工作？”

为了回答这个问题，我们需要更仔细地查看 Java 运算符的优先级规则。

Java 提供了很多运算符。在实践中，我们经常一起使用不同的运算符。因此，了解 Java 运算符的优先级是至关重要的。否则，我们可能会得到一个意想不到的结果。

接下来，让我们看看 Java 运算符优先级规则（表中运算符出现的越高，优先级越高）：

| 运算符 | 优先级 |
| --- | --- |
| 后缀 | _expr++ expr–_ |
| 一元 | _++expr –expr +expr -expr ~ !_ |
| 乘法 | _\* / %_ |
| 加法 | _+ –_ |
| 位移 | _`<`< >``>>_ |
| 关系 | _`< >` `<= >`= instanceof_ |
| 相等 | _== !=_ |
| 位与 | _&_ |
| 位异或 | _^_ |
| 位或 | _\|_ |
| 逻辑与 | _&&_ |
| 逻辑或 | _\|\|_ |
| 三元 | _? :_ |
| 赋值 | _= += -= *= /= %= &= ^= \|= <`<= >`>= >>>=_ |

正如我们在上面的列表中看到的，**取模运算符（%）的优先级高于等式运算符（==）**。另一方面，**位与运算符（&）在表中的优先级低于等式运算符（==）**。

这就是为什么 “_i % 2 == 1_” 按预期工作，但 “_i & 1 == 1_” 不工作的原因。

我们在示例中遇到了编译时错误。因此，我们可以相对早地发现问题。然而，想象一下一些实现中存在运算符优先级错误的代码编译通过但产生了错误的结果。找出问题的真实原因可能会不必要地花费我们很多时间。

因此，记住 Java 运算符的优先级规则是值得的。

## 4. 修复问题

现在我们理解了问题的原因，修复问题并不难。我们只需要在位与操作中添加括号：

```java
if (i & 1 == 1)  --->  if ((i & 1) == 1)
```

修复后，如果我们再次运行该方法，我们将看到编译器不再抱怨，我们收到了预期的输出：

```
1 is odd.
2 is even.
3 is odd.
4 is even.
5 is odd.
6 is even.
7 is odd.
```

## 5. 结论

在这篇文章中，我们通过一个位与操作的示例分析了编译错误 “bad operand types for binary operator”。

此外，我们讨论了 Java 运算符的优先级规则。

最后，我们修复了问题。