---
date: 2024-07-06
category:
  - JPA
  - Java
tag:
  - JPA
  - 持久化
  - List```````````````<String>```````````````
head:
  - - meta
    - name: keywords
      content: JPA, 持久化, List```````````````<String>```````````````, Java
---
# 如何在JPA中持久化字符串列表？

在本教程中，我们将讨论如何在JPA中持久化类型为List```````````````<String>```````````````的属性。我们将查看实现此目的的可能性，它们之间的区别，并通过示例解释它们的优势。

## 2. 示例

我们将使用一个名为library的实体作为模型，该实体具有自动生成的ID、一个名称、一个包含地址的List```````````````<String>```````````````，以及一个包含书名的List```````````````<String>```````````````：

```java
@Entity(name = "library")
public class Library {

    @Id
    @GeneratedValue(strategy = GenerationType.IDENTITY)
    private Long id;

    private String name;

    private List```````````````<String>``````````````` addresses = new ArrayList<>();
    private List```````````````<String>``````````````` books = new ArrayList<>();

    // getter, setter, 和构造函数
}
```

对于List```````````````<String>```````````````，**我们可以创建一个带有id和字符串的第二个实体，然后使用OneToMany关系进行注解**。我们将探讨JPA中的另外两种可能性，这些可能性简化了这种行为。

## 3. @ElementCollection

第一个选项是使用@ElementCollection。此注解允许我们指定集合的目标类。在我们的例子中，这是String。此外，我们可以指定列表是否应该以延迟或即时的方式加载。默认值是延迟。但是，为了示例的简单性，我们将值设置为即时：

```java
@ElementCollection(targetClass = String.class, fetch = FetchType.EAGER)
@CollectionTable(name = "books", joinColumns = @JoinColumn(name = "library_id"))
@Column(name = "book", nullable = false)
private List```````````````<String>``````````````` books = new ArrayList<>();
```

我们还可以使用@Transactional注解访问列表的方法，或者使用@Query("SELECT l FROM library l JOIN FETCH l.books WHERE l.id = (:id)")注解仓库方法，以避免LazyInitializationException。

注解的结果生成了以下DDL：

```sql
CREATE TABLE books
(
    library_id BIGINT       NOT NULL,
    book      VARCHAR(255) NOT NULL
);

CREATE TABLE library
(
    id        BIGINT GENERATED BY DEFAULT AS IDENTITY NOT NULL,
    name      VARCHAR(255),
    addresses VARCHAR(255)                            NOT NULL,
    CONSTRAINT pk_library PRIMARY KEY (id)
);

ALTER TABLE books
    ADD CONSTRAINT fk_books_on_library FOREIGN KEY (library_id) REFERENCES library (id);
```

我们可以看到@CollectionTable设置了第二个表的名称和引用我们library表的列。此外，外键也适当地创建了。因此，通过使用这种方法中的@ElementCollection，**我们节省了通常需要的第二个实体用于OneToMany链接**。

## 4. 属性转换器

另一种选择是使用转换器。为此，我们必须使用我们期望的对象实现通用的AttributeConverter。在我们的例子中，这是List```````````````<String>```````````````；期望的格式可以是String，例如。**在convertToDatabaseColumn(List```````````````<String>``````````````` stringList)方法中，返回值是对象最终在数据库中应该具有的数据类型**，参数是我们的列表。

**另一方面，convertToEntityAttribute(String string)方法定义了如何将列中的字符串转换回** List```````````````<String>```````````````。在我们的例子中，我们使用字符“;”来分隔字符串：

```java
@Converter
public class StringListConverter implements AttributeConverter<List```````````````<String>```````````````, String> {
    private static final String SPLIT_CHAR = ";";

    @Override
    public String convertToDatabaseColumn(List```````````````<String>``````````````` stringList) {
        return stringList != null ? String.join(SPLIT_CHAR, stringList) : "";
    }

    @Override
    public List```````````````<String>``````````````` convertToEntityAttribute(String string) {
        return string != null ? Arrays.asList(string.split(SPLIT_CHAR)) : emptyList();
    }
}
```

我们还必须在字段上添加我们的转换器@Convert：

```java
@Convert(converter = StringListConverter.class)
@Column(name = "addresses", nullable = false)
private List```````````````<String>``````````````` addresses = new ArrayList<>();
```

或者，我们可以将列表作为JSON字符串存储在列中。当我们决定使用AttributeConverter时，**我们必须牢记我们的列表将增长到多大，因为它必须适应所选列的大小**。

在我们的情况下，它必须适合varchar(255)的addresses列。在ElemenCollection方法中，我们的列表可以有无限数量的项目，每个项目仅受列本身的varchar(255)限制。

## 5. 比较

接下来，我们将创建LibraryRepository并测试我们的解决方案：

```java
@Repository
public interface LibraryRepository extends CrudRepository`<Library, Long>` {
}
```

现在当我们执行代码时，我们将像往常一样向library实体添加列表项：

```java
Library library = new Library();
library.setAddresses(Arrays.asList("Address 1", "Address 2"));
library.setBooks(Arrays.asList("Book 1", "Book 2"));

libraryRepository.save(library);
Library lib = libraryRepository.findById(library.getId().longValue());
System.out.println("lib.getAddresses() = " + lib.getAddresses());
System.out.println("lib.getBooks() = " + lib.getBooks());
```

我们将得到以下输出：

```java
lib.getAddresses() = [Address 1, Address 2]
lib.getBooks() = [Book 1, Book 2]
```

正如我们所看到的，两种实现都按预期工作，并且各自有自己的优势：

| | 元素集合 | 转换器 |
| --- | --- | --- |
| 默认获取类型 | 延迟 | 即时 |
| 列表限制 | 无限列表项 | 受列长度限制 |
| 每个字符串的限制 | 受列长度限制 | 受列表项数限制，因此也受列长度限制 |
| 表 | 创建额外的表 | 不需要自己的表 |

## 6. 结论

在本文中，我们讨论了在JPA中存储实体的字符串列表的可能性。虽然我们展示了可能存在的限制以及各种可能性之间的差异。

如往常一样，示例代码可在GitHub上找到。